운영체제에서 트랜잭션과 동시성 관리는 중요하다.

## 트랜잭션

* 단일 논리 작업 단위를 수행하는 명령어 또는 연산의 집합
* 이 연산 과정에 있어서 원자성을 보장해야한다.
* 일련의 읽기와 쓰기 연산을 구성 됨
* 성공적으로 완료시 커밋하고, 실패 시 롤백되어 모든 변경사항을 취소한다.

### 트랜잭션 복구

1. 로그 기반 복구 (Log based recovery)
	* 트랜잭션이 수행한 모든 수정사항을 기록하는 로그를 안정 저장소에 저장한다.
	* 일반적으로 사용하는 방식은 사전 기록이다.
2. 체크포인트
	* 로그가 길어지면 복구가 길어진다는 단점이 있어, 이를 줄이기 위해 주기적인 체크 포인트를 설정한다.
	* 체크 포인트를 통해 마지막 체크 포인트 이후에 시작된 트랜잭션만 복구한다.
3. 동시 원자 트랜잭션 (Concurrent Atomic Transactions)
	* 동시 실행되는 트랜잭션은 어떤 순서로든 직렬로 실행되는 것과 동일해야한다.
	* 베른 스타인 조건을 만족해야합니다.
	* 이를 위해 Locking Protocol 이나 타임스탬프 기반 프로토콜을 사용한다.


>베른스타인 조건은 병렬 프로그래밍에서 중요한 개념입니다. 이 조건은 여러 프로세스가 동시에 실행될 때 서로 간섭하지 않고 안전하게 실행될 수 있는지를 판단합니다. 이를 위해 다음 세 가지 조건을 충족해야 합니다:
>1. **읽기-쓰기 조건 (Read-Write Condition)**: 어떤 프로세스가 다른 프로세스의 쓰기 연산을 읽지 않아야 합니다.
>2. **쓰기-읽기 조건 (Write-Read Condition)**: 어떤 프로세스가 다른 프로세스의 읽기 연산에 쓰지 않아야 합니다.
>3. **쓰기-쓰기 조건 (Write-Write Condition)**: 두 프로세스가 같은 데이터를 동시에 쓰지 않아야 합니다.
>이 조건들을 만족시키기 위해 잠금 프로토콜(Locking Protocol)이나 타임스탬프 기반 프로토콜(Timestamp-Based Protocol)을 사용할 수 있습니다.

## 동시성 문제와 해결 방안

1. 동시성 문제
	* 원자성 버그: 동시 실행시 원하는 직렬화 순서가 깨질 수 있습니다.
	* 순서 위반 버그: 메모리 접근 순서가 바뀌어야할 때 발생합니다.
	* 교착 상태(Dead Lock): 두 개 이상의 프로세스가 서로 자원을 기다리며 멈추는 상태입니다.
2.  해결 방안
	* 잠금 사용: 공유 변수에 대한 접근을 잠금으로 보호합니다.
	* 조건 변수 사용: 특정 조건이 충족될 떄까지 스레드를 대기시킵니다.
	* 데드락 방지: 자원 요청 순서를 정하거나, 교착 상태를 피하기 위한 스케줄링 사용합니다.

## 교착 상태 해결 방안

교착 상태란 두 스레드가 서로가 소유한 잠금을 기다리는 상황을 피하기 위해 자원 요청 순서를 정하거나, 스케줄링을 통해 교착 상태를 방지합니다.

1. 교착 상태 방지
	* 상호 배제(Mutual Exclusion) : 자원을 공유하지 않거나, 공유 자원에 대해 잠금을 사용하여 방지합니다.
	* 대기 및 보유(Hold and Wait) : 프로세스가 자원을 요청할 때 다른 자원을 보유하지 않도록 합니다.
	* 비선점(No Preemption) : 프로세스가 자원을 선점하지 않도록 합니다.
	* 순환 대기(Circular Wait) : 자원 요청 순서를 정하여 순환 대기를 방지합니다.

2. 교착 상태 회피    
    - 시스템이 안전 상태를 유지하도록 자원 할당을 동적으로 관리합니다.
    - 은행가 알고리즘(Banker’s Algorithm)을 사용하여 시스템이 교착 상태에 빠지지 않도록 합니다.

3. 교착 상태 탐지와 회복
    - 주기적으로 시스템 상태를 검사하여 교착 상태를 탐지합니다.
    - 교착 상태가 발생하면 프로세스를 중단하거나 자원을 회수하여 회복합니다.

## Banker's 알고리즘

Banker's 알고리즘은 자원 할당에서 안전 상태를 판단하기 위해 사용됩니다. 은행에서 대출을 관리하는 방식에서 유래되었습니다. 은행이 모든 고객에게 대출을 해줄 때, 모든 고객이 대출을 상환할 수 있을 때까지 자원을 적절히 관리하는 것과 같습니다. 이 알고리즘은 시스템이 항상 안정적인 상태를 유지하도록 보장합니다.

## 데드락 방지

데드락은 두 개 이상의 프로세스가 서로의 자원을 기다리며 무한히 대기하는 상황입니다. 데드락을 방지하기 위해 여러 가지 방법이 있습니다:

1. **예방 (Prevention)**: 데드락이 발생하지 않도록 미리 방지하는 방법입니다.
2. **회피 (Avoidance)**: 데드락이 발생할 가능성을 회피하는 방법입니다.
3. **탐지 및 복구 (Detection and Recovery)**: 데드락이 발생했을 때 이를 탐지하고 해결하는 방법입니다.
## Safety Algorithm

안전 알고리즘은 시스템이 안전한 상태에 있는지를 검사하는 알고리즘입니다. 이 알고리즘은 자원 할당 시 시스템이 안전 상태를 유지하는지를 판단합니다. 예를 들어, 구명보트에 탈 수 있는 최대 인원을 초과하지 않도록 항상 확인하는 것과 비슷합니다. 안전 상태를 유지하기 위해 현재 할당된 자원과 필요한 자원을 검사합니다.
## 이벤트 기반 동시성 처리

이벤트 기반 동시성 처리는 비동기 프로그래밍에서 중요한 개념입니다. `async`와 `await` 키워드를 사용하여 이벤트가 발생할 때마다 비동기로 작업을 처리합니다. 예를 들어, 여러 사람이 동시에 음식을 주문하는 상황을 생각해 보세요. 각 주문은 독립적으로 처리되며, 음식이 준비되면 고객에게 알려줍니다. 이 과정에서 대기 시간이 최소화되고 효율적으로 처리됩니다.

- **이벤트 루프(Event Loop)**
    - 시스템 호출이나 네트워크 요청과 같은 이벤트가 발생할 때까지 대기합니다.
    - 이벤트가 발생하면 해당 이벤트를 처리합니다.
    
- **비동기 I/O(Asynchronous I/O)**
    - 비동기 I/O를 사용하여 시스템 호출이 완료될 때까지 기다리지 않고 바로 제어를 반환합니다.
    - UNIX 신호를 사용하여 비동기 I/O가 완료되었음을 알립니다.
    
- **상태 관리(State Management)**
    - 이벤트 기반 코드에서는 프로그램 상태를 다음 이벤트 핸들러가 사용할 수 있도록 패키지화합니다.
    - 수동 스택 관리가 필요합니다.