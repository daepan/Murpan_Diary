  
### 페이지 선택 정책

- **운영체제(OS)는 페이지를 메모리로 가져올 시기를 결정해야 합니다**.
- **운영체제에 몇 가지 다른 옵션을 제공합니다**.
    - **프리페칭(Prefetching)**
        - 운영체제가 페이지가 곧 사용될 것이라고 예측하고, 미리 메모리로 가져옵니다.
        - 예를 들어, 페이지 2가 곧 접근될 가능성이 높으므로 메모리로 가져와야 합니다.
    - **클러스터링, 그루핑(Clustering, Grouping)**
        - 여러 개의 보류 중인 쓰기를 메모리에 함께 모아 두었다가 한 번의 쓰기로 디스크에 기록합니다.
        - 많은 작은 쓰기보다 한 번의 큰 쓰기를 더 효율적으로 수행합니다.

### 프레임 할당

- **다양한 프로세스들 사이에서 고정된 양의 자유 메모리를 어떻게 할당할까요?**
- **각 프로세스는 최소한의 페이지 수가 필요합니다 (아키텍처에 의해 정의됨)**.
- **글로벌 대 로컬 할당**
    - **글로벌 교체(Global replacement)** – 프로세스가 모든 프레임의 집합에서 교체 프레임을 선택; 한 프로세스가 다른 프로세스의 프레임을 가져갈 수 있습니다.
    - **로컬 교체(Local replacement)** – 각 프로세스가 자신에게 할당된 프레임 집합에서만 선택합니다.

### 주요 할당 체계

- **고정 할당(Fixed Allocation)**
    
    - **동등 할당(Equal allocation)** – 예를 들어, 100개의 프레임과 5개의 프로세스가 있다면, 각각에게 20개의 페이지를 제공합니다.
        - m: 프레임 수, n: 프로세스 수, m/n: 각 프로세스의 프레임 수
    - **비례 할당(Proportional allocation)** – 프로세스의 크기에 따라 할당합니다.
- **우선순위 할당(Priority Allocation)**
    
    - 크기가 아닌 우선순위를 사용하는 비례 할당 체계를 사용합니다.
    - 프로세스 Pi가 페이지 폴트를 발생시키면,
        - 교체를 위해 그 프로세스의 프레임 중 하나를 선택합니다.
        - 우선순위가 낮은 프로세스의 프레임 중에서 교체할 프레임을 선택합니다.


### 쓰레싱 (Thrashing)

- **쓰레싱은 프로세스가 페이지를 메모리에 들어오고 나가게 하는 작업에 바쁜 상태를 의미합니다** (지역성).
    - 메모리가 과도하게 사용되어 실행 중인 프로세스 세트의 메모리 요구가 사용 가능한 물리 메모리를 초과합니다.
    - 이는 낮은 CPU 이용률로 이어집니다. 운영 체제는 멀티프로그래밍의 정도를 늘려야 한다고 판단합니다. 시스템에 다른 프로세스가 추가됩니다.
    - 프로세스의 부분 집합을 실행하지 않기로 결정합니다.
    - 메모리에 맞는 축소된 프로세스 작업 세트.

### 지역성 모델

- **지역성은 함께 활발히 사용되는 페이지 세트입니다**.
- **프로세스는 한 지역성에서 다른 지역성으로 이동합니다**.
- **지역성은 중첩될 수 있습니다**.

### 왜 쓰레싱이 발생하나요?

- **지역성의 크기가 전체 메모리 크기보다 큰 경우 발생합니다**.

### 작업 세트 모델 (Working-Set Model)

- **Δ는 작업 세트 창으로, 고정된 수의 페이지 참조를 의미합니다**.
    - 예: 10,000개의 명령어
- **WSSi (프로세스 Pi의 작업 세트)** = 가장 최근 Δ에서 참조된 페이지의 총 수 (시간에 따라 변함).
    - Δ가 너무 작으면 전체 지역성을 포함하지 못할 수 있습니다.
    - Δ가 너무 크면 여러 지역성을 포함할 수 있습니다.
    - Δ = ∞이면 전체 프로그램을 포함하게 됩니다.
- **D = Σ WSSi는 총 요구 프레임을 의미합니다**.
- **D > m인 경우 쓰레싱이 발생합니다**.
- **정책: D > m인 경우, 하나의 프로세스를 중단합니다**.


#### 프리페이징 (Prepaging)

- **초기 페이징의 높은 페이지 폴트율을 방지하기 위해**
    - 프로세스 시작 시 발생하는 많은 페이지 폴트 수를 줄입니다.
    - 참조되기 전에 프로세스가 필요로 할 페이지의 전부 또는 일부를 미리 페이징합니다.
    - 그러나 프리페이징된 페이지가 사용되지 않으면 I/O와 메모리가 낭비됩니다.
    - s 페이지가 프리페이징되고, 그 중 α 비율의 페이지가 사용된다고 가정할 때,
        - s * α 페이지 폴트를 줄이는 비용이 s * (1- α) 불필요한 페이지를 프리페이징하는 비용보다 큰지 또는 작은지를 고려해야 합니다.
        - α가 0에 가까우면 프리페이징이 손실됩니다.

#### 페이지 크기 선택

- **페이지 크기 (2의 거듭제곱; 512에서 16384까지)**
    - 단편화
    - 테이블 크기
    - I/O 오버헤드
    - 지역성

#### TLB 리치 (TLB Reach)

- **TLB로 접근할 수 있는 메모리의 양**
    - TLB Reach = (TLB 크기) x (페이지 크기)
    - 이상적으로, 각 프로세스의 작업 세트는 TLB에 저장됩니다.
    - 그렇지 않으면 페이지 폴트가 많이 발생합니다.

#### 페이지 크기 증가

- **큰 페이지 크기로 인해 단편화가 증가할 수 있으며, 모든 애플리케이션에 큰 페이지 크기가 필요한 것은 아닙니다**.

#### 다양한 페이지 크기 제공

- **큰 페이지 크기가 필요한 애플리케이션에 기회를 제공하면서 단편화 증가 없이 사용할 수 있게 합니다**.

#### I/O 인터록

- **페이지가 메모리에 고정되어야 할 때가 있습니다**
    - I/O 페이지가 페이징 아웃될 수 있습니다.
        - 사용자 메모리에 I/O를 수행하지 않거나,
        - 페이지를 메모리에 고정할 수 있도록 허용합니다.
    - 잠금은 매우 유용하지만 해로울 수 있습니다.

#### I/O 고려

- **디바이스에서 파일을 복사하는 데 사용되는 페이지는 페이지 교체 알고리즘에 의해 선택되지 않도록 잠금 처리해야 합니다**.

#### 수요 세그먼테이션

- **수요 페이징을 구현하기에 충분한 하드웨어가 없을 때 사용됩니다**.
    - 세그먼트 설명자는 세그먼트가 현재 메모리에 있는지 여부를 나타내는 유효 비트를 포함합니다.
    - 세그먼트가 메인 메모리에 있으면 접근이 계속되고,
    - 메모리에 없으면 세그먼트 폴트가 발생합니다.

#### 프로그램 구조

- **배열 A[1024, 1024] 정수**
    - 각 행은 한 페이지에 저장됩니다 (행 우선).
    - 프로그램 1: `for j := 1 to 1024 do for i := 1 to 1024 do A[i,j] := 0;` → 1024 x 1024 페이지 폴트
    - 프로그램 2: `for i := 1 to 1024 do for j := 1 to 1024 do A[i,j] := 0;` → 1024 페이지 폴트
### 스와핑

- **프로세스는 일시적으로 메모리에서 백업 저장소로 스왑되었다가 계속 실행을 위해 다시 메모리로 가져올 수 있습니다**.
- **백업 저장소(Backing store)**
    - 모든 사용자의 모든 메모리 이미지 사본을 수용할 수 있는 충분히 큰 고속 디스크; 이 메모리 이미지에 대한 직접 접근을 제공해야 합니다.
- **롤 아웃, 롤 인(Roll out, roll in)**
    - 우선순위 기반 스케줄링 알고리즘을 위해 사용되는 스와핑 변형; 낮은 우선순위의 프로세스가 스왑 아웃되어 높은 우선순위의 프로세스를 로드하고 실행할 수 있습니다.
- **스왑 시간의 주요 부분은 전송 시간이며, 전체 전송 시간은 스왑된 메모리 양에 비례합니다**.
    - 스왑 시간 = 탐색 시간 + 대기 시간 + 전송 시간 (디스크 접근 시간)
![[Pasted image 20240421180257.png]]
### 복사-쓰기 (Copy-on-Write, COW)

- **복사-쓰기(Copy-on-Write)**는 부모 프로세스와 자식 프로세스가 초기에 동일한 메모리 페이지를 공유할 수 있게 합니다. 공유된 페이지를 어느 한 쪽이 수정하면 그때 페이지가 복사됩니다.
- **COW는 수정된 페이지만 복사되기 때문에 더 효율적인 프로세스 생성을 가능하게 합니다**.
![[Pasted image 20240421180304.png]]
### 메모리 매핑 파일

- **메모리 매핑 파일 I/O는 디스크 블록을 메모리의 페이지에 매핑함으로써 파일 I/O를 일반 메모리 접근처럼 처리할 수 있게 합니다**.
- **파일 I/O를 메모리를 통해 처리함으로써 파일 접근을 단순화합니다** (read(), write() 시스템 호출 대신).
- **또한 여러 프로세스가 동일한 파일을 매핑할 수 있게 하여 메모리의 페이지를 공유할 수 있습니다**.


![[Pasted image 20240421180318.png]]
### CPU 가상화: 프로세스

- **프로세스는 순수하게 가상의 개념입니다**.
- **정책과 메커니즘을 분리하면 모듈성이 가능해집니다**.
- **운영 체제는 서버로서, 하드웨어와 프로세스로부터의 요청에 반응합니다**.
    - 프로세스는 운영 체제 및 다른 프로세스로부터 격리됩니다.
    - 프로세스는 하드웨어에 직접 접근할 수 없습니다.
    - 프로세스는 가상 메모리에서 실행됩니다.
- **운영 체제는 시스템 호출을 통해 기능을 제공합니다**.
- **프로세스는 주소 공간, 관련된 커널 상태(예: 열린 파일, 네트워크 채널) 및 하나 이상의 실행 스레드로 구성됩니다**.

### CPU 가상화: 스케줄링

- **컨텍스트 스위치와 선점은 운영 체제가 제어를 유지하고 더 높은 수준의 스케줄링 정책을 구현할 수 있도록 하는 기본 메커니즘입니다**.
- **스케줄러는 다양한 지표(활용도, 처리 시간, 응답 시간, 공정성 및 진행)를 최적화해야 합니다**.
    - FIFO: 간단하고, 비선점 스케줄러
    - SJF: 비선점, 프로세스 정체 방지
    - STFC: 선점, 늦은 프로세스의 정체 방지
    - RR: 선점, 빠른 응답 시간, 나쁜 처리 시간
    - MLFQ: 선점, 가장 현실적
    - CFS: 시간을 가상화하여 공정한 스케줄러
- **과거 행동은 미래 행동의 좋은 예측자입니다**.

### 메모리 가상화: 세분화

- **운영 체제는 제한된 자원에 대한 접근을 관리합니다**.
    - 원칙: 필요할 때 제한된 직접 실행(가능할 때는 베어 메탈, 필요할 때는 가로채기)
    - CPU: 프로세스 간의 시간 공유 (전환 비용이 낮음)
    - 메모리: 공간 공유 (디스크 I/O가 느리므로 시간 공유가 비쌈)
- **프로그램은 동적 데이터를 사용합니다**.
    - 스택: 프로그램 호출 프레임
    - 힙: 순서가 없는 데이터, 사용자 공간 라이브러리(할당자)에 의해 관리됨
- **시간 공유: 하나의 프로세스가 모든 메모리를 사용합니다**.
- **베이스 레지스터: 공간을 공유하고, 오프셋을 통해 프로세스 주소를 계산합니다**.
- **베이스 + 바운드: 공간을 공유하고, 프로세스의 주소 공간을 제한합니다**.
- **세그먼트: 이동 가능한 세그먼트, 세그먼트 기저로 가상 오프셋**

### 메모리 가상화: 페이징

- **단편화: 내부 또는 외부 패딩으로 인해 손실된 공간**
- **페이징: MMU가 가상 주소와 물리 주소 사이를 완전히 변환합니다**.
    - 단일 평면 페이지 테이블(배열)
    - 다중 레벨 페이지 테이블
    - 장점? 단점? 크기 요구 사항은 무엇인가요?
- **페이징과 스와핑은 작업 세트만 메모리에 있으면서 프로세스가 실행될 수 있게 하고, 나머지 페이지는 디스크에 저장할 수 있습니다**.