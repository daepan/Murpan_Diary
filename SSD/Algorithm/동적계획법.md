## 개념

* 분할 정복
	* 문제를 위에서부터 아래로 분할
	* 쪼갠 각 부분 문제는 완전히 독립적인 문제로 다룰 수 있음
* 동적 계획법
	* 제일 작은 부분문제부터 상위에 있는 문제로 접근
	* 각 단계에 있는 부분 문제들은 그 이전 단계에 있는 문제들의 답에 의존
	* 분할 정복과 달리 한 번 푼 적 있는 문제의 답을 다시 푸는 일이 없도록 테이블 등에 저장

## 동작 방식

* 1단계 : 문제를 부분문제로 나눔
* 2단계 : 가장 작은 부분 문제부터 해를 구한 뒤 테이블에 저장
* 3단계 : 테이블에 저장된 부분 문제의 해를 이용하여 점차적으로 상위 부분의 최적해를 구함


### 충족하기 위한 조건
* 문제가 최적 부분 구조를 갖춰야함
	* 최적 부분 구조란?
		* 전체 문제의 최적해가 부분문제의 최적해로부터 만들어지는 구조


## 피보나치 수 동적계획 법으로 구현하기

* 동적 계획법으로 재구성하면 On 으로 향상
* 제일 먼저 이 문제가 최적 부분 구조로 이루어져있는 지 부터 확인
	* 피보나치 수는 부분 문제의 답에서 전체 문제의 답을 얻을 수 있으므로 최적 부분 구조로 이루어져 있다고 할 수 있음
	* 따라서 동적계획법을 사용할 수 있다.

![[Pasted image 20240616144045.png]]

## LCS 알고리즘

* LCS란?
	* Logest Common Subsequence의 약어
	* 수열 : 어떤 물건이나 객체의 목록을 가리키는 용어
	* 부분 수열 : 수열 에서 일부 요소를 제거한 것
	* 공통 부분 수열 : 두 수열 사이에 공통적으로 존재하는 부분 수열
	* 최장 공통 부분 수열 : 여러 개의 공통 부분 수열 중 가장 긴 것
	* 최장 공통 부분 수열 알고리즘은 두 데이터를 비교할 때 아주 유용하다.
* LCS 점화식
![[Pasted image 20240616144327.png]]
* 테이블 점화
![[Pasted image 20240616144342.png]]

### 동적 계획법 기반 LCS 알고리즘의 구현

* LCS 문제를 동적 계획법으로 풀 때도 동적 계획법 설계 절차에 따른다.
	* LCS 문제에서는 LCS테이블의 각 요소가 각 부분 문제
	* 테이블의 오른쪽 아래 방향으로 내려가면서 나타나는 요소들이 부분 문제를 포함하는 상위 문제
	* 가장 오른쪽 아래 모서리에 있는 요소가 전체 문제
	* 따라서 테이블의 왼쪽 위 모서리부터 시작해서 오른쪽 아래로 내려가면서 계산을 수행하면 가장 작은 문제부터 해를 구하고, 이를 기반으로 상위 문제의 해를 구하게 된다.
	* 앞에서 살펴본 LCS 점화식에 따르면 i = 0 이거나 j = 0 인경우 Table i, j = 0
		* 따라서 모든 j에 대해 Table 0, j 를 0으로 만들고 모든 i에 대해 모든 i,0를 0으로 만든다.

### LCS 테이블에서 LCS를 추적하는 알고리즘
❶ 오른쪽 아래 모서리 요소를 시작 셀로 지정하고, LCS의 요소를 담기 위한 리스트를 하나 준비
❷ 현재 위치한 셀의 값이 왼쪽(←), 왼쪽 위(↖), 위(↑) 셀의 값보다 크면 현재 셀의 값을 리스트 헤드에 삽입하고
왼쪽 위 셀(↖)로 이동
❸ 현재 위치한 셀의 조건이 단계 ❷에 해당하지 않으며 현재 셀의 값과 왼쪽(←) 셀의 값이 같고 위(↑) 셀의
값보다 큰 경우 왼쪽(←)으로 이동. 이동만 할 뿐 리스트에는 아무것도 넣지 않음
❹ 단계 ❷, ❸ 중 어느 경우에도 해당하지 않으면 위(↑) 셀로 이동. 역시 리스트에는 아무것도 넣지 않음
❺ i = 0 또는 j = 0이 될 때까지 ❷~❹ 단계를 반복

![[Pasted image 20240617115216.png]]01 12장에서 분할 정복 기법을 이용하여 만든 피보나치 수 구하기 알고리즘과 이 장에서 동적 계획법을 이용하여 만든 피보나치 수 구하기 알고리즘을 구조면에서 비교해보자.

결론적으로, 분할 정복 기법과 동적 계획법은 피보나치 수를 구하는 데 서로 다른 접근 방식을 사용합니다.

분할 정복 기법: 이 방법은 재귀적으로 문제를 나누어 해결하며, 피보나치 수열의 계산을 위해 행렬 거듭 제곱을 사용합니다. 이는 행렬의 거듭 제곱을 통해 피보나치 수열을 효율적으로 계산하는 방식으로, 피보나치 수열의 n번째 값을 구할 때 O(logn)의 시간 복잡도를 가집니다. 예를 들어, 10번째 피보나치 수를 구할 때, 행렬을 거듭 제곱하여 빠르게 계산할 수 있습니다.

동적 계획법: 이 방법은 반복적으로 문제를 해결하며, 피보나치 수열의 중간 결과를 저장하기 위해 테이블(배열)을 사용합니다. 피보나치 수열의 초기값부터 시작해 순차적으로 다음 값을 계산하며, 각 값을 테이블에 저장하여 중복 계산을 피합니다. 동적 계획법은 피보나치 수열의 n번째 값을 구할 때

O(n)의 시간 복잡도를 가지며, 이를 통해 피보나치 수열의 값을 효율적으로 계산합니다. 예를 들어, 10번째 피보나치 수를 구할 때, 앞의 값을 이용해 순차적으로 계산하여 결과를 얻습니다.

따라서, 분할 정복 기법은 행렬 거듭 제곱을 사용하여 피보나치 수를 빠르게 계산하는 반면, 동적 계획법은 중간 결과를 저장하여 반복적으로 피보나치 수를 계산합니다. 두 방법 모두 피보나치 수열의 값을 효율적으로 구할 수 있지만, 구조적으로는 상당히 다른 접근 방식을 취하고 있습니다.

02 9장에서 다룬 데이크스트라의 최단 경로 알고리즘은 동적 계획법으로 만들어진 것일까? ‘그렇다’ 또는 ‘그렇지 않다’라고 생각한다면 그 이유를 설명해보자.

차이점: 동적 계획법과 데이크스트라 알고리즘은 문제를 해결하는 접근 방식에서 차이가 있습니다. 동적 계획법은 문제를 작은 부분 문제로 나누어 해결하며, 이 부분 문제들의 해를 저장하고 재사용하여 전체 문제의 해를 구합니다. 반면, 데이크스트라 알고리즘은 그래프 탐색 알고리즘으로, 각 노드의 최단 경로를 점진적으로 업데이트하며 해결합니다.

데이크스트라 알고리즘의 원리: 데이크스트라 알고리즘은 시작 노드에서 다른 모든 노드로의 최단 경로를 찾는 방식으로, 각 노드의 경로 길이를 업데이트하며 탐색합니다. 이는 우선순위 큐를 사용하여 현재까지 발견된 최단 경로를 기반으로 탐색 범위를 넓혀가는 방식입니다.

동적 계획법의 특징: 동적 계획법은 최적 부분 구조와 중복 부분 문제를 이용하여 문제를 해결합니다. 데이크스트라 알고리즘은 최적 부분 구조를 이용하지만, 중복 부분 문제를 해결하는 방식이 아니라, 최단 경로를 찾기 위해 각 노드의 경로를 반복적으로 갱신하며 탐색하는 방식입니다.

결론: 따라서, 데이크스트라 알고리즘은 동적 계획법을 이용한 알고리즘이라고 볼 수 없으며, 주로 그리디 알고리즘으로 분류됩니다.