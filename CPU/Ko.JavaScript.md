# 함수심화학습

  

## 재귀와 스택

  

재귀란 함수가 자기 자신을 호출하는 것.

예시로는 제곱, 피보나치 수열 등이 있다.

  

자바스크립트 엔진에서는 최대 재귀 깊이를 제한한다.

만번까지는 가능하지만, 십만 이상을 대부분의 엔진이 소화하지는 못한다.

엔진 내부에서 `tail calls optimization`라는 최적화를 일부 엔진에서 최적화를 한다.

  

### 자바스크립트에서의 재귀

  

자바스크립트에서는 실행 중인 함수의 실행절차에 대한 정보는 해당 함수의 실행 컨텍스트에 저장된다.

  

이 실행 컨텍스트에는 함수 실행에 대한 세부정보를 담고 있는 내부 데이터 구조이다.

세부정보로는 예를 들어, 제어 흐름의 현재 위치, 변수의 현재 값, this의 값 등이 있다.

  

함수 호출 1회 당 정확히 하나의 실행 컨텍스트가 생성된다.

재귀와 같은 중첩 호출이 있을때는 아래와 같은 절차가 있다.

  

- 현재 함수의 실행이 일시 중지된다.

- 중지된 함수와 연관된 실행 컨텍스트는 실행 컨텍스트 스택이라는 특별한 자료구조에 저장된다.

- 중첩 호출이 실행된다.

- 중첩 호출 실행이 끝난 이후 실행 컨텍스트 스택에 저장도니 실행 컨텍스트를 꺼내오고 중단한 함수의 실행을 이어간다.

  

이렇게 재귀를 하게되면 함수의 실행 과정에 대한 정보를 저장하는 실행 컨텍스트 스택이라는 메모리 공간을 사용하는 것이다.

  

그렇기에 반복문 기반 알고리즘의 경우 메모리가 절약이 되는 이점이 있다. 그렇게 크진 않다.

  

## 나머지 매개변수와 전개 구문

  

자바스크립트의 내장 함수는 인수의 제약을 크게 두지 않는다.

  

```js

function sum(a, b) {

  return a + b;

}

  

alert(sum(1, 2, 3, 4, 5));

```

  

이렇게 써도 에러가 안 난다.

  

### ... 나머지 매개변수

  

나머지 매개변수는 여분의 인수를 전달할 수 있는 방법이다.

사용 시 주의할 점은 반드시 매개변수의 맨 뒤에 있어야한다.

  

```js

function showName(firstName, lastName, ...titles) {

  //function showName(firstName,  ...titles, lastName) 이렇게 쓰면 에러가 난다!

  alert(firstName + " " + lastName); // Bora Lee

  

  // 나머지 인수들은 배열 titles의 요소가 됩니다.

  // titles = ["Software Engineer", "Researcher"]

  alert(titles[0]); // Software Engineer

  alert(titles[1]); // Researcher

  alert(titles.length); // 2

}

  

showName("Bora", "Lee", "Software Engineer", "Researcher");

```

  

### ... 스프레드 문법

  

위의 나머지 매개변수 `...`과는 다른 내용이다.

위에서는 매개변수 목록을 배열로 가져오는 방법이지만, 이는 배열 통째로를 매개변수로 넘겨줄 때 사용하는 것이다. 둘은 다른 것이다.

  

```js

let arr = [3, 5, 1];

let arr2 = [8, 3, -8, 1];

  

alert(Math.max(arr)); // NaN

alert(Math.max(...arr)); // 5

alert(Math.max(...arr1, ...arr2)); // 8

```

  

이 스프레드 문법은 이터러블 객체이면 활용할 수 있다.

  

문자배열도 가능하고 Array.from을 통해 활용해도 같은 결과가 나온다.

  

```js

let str = "Hello";

  

alert([...str]); // H,e,l,l,o

// Array.from은 이터러블을 배열로 바꿔줍니다.

alert(Array.from(str)); // H,e,l,l,o

```

  

## 변수의 유효범위와 클로저

  

자바스크립트는 함수 지향 언어이다. 그렇기에 함수를 동적으로 생성할 수 있고, 생성한 함수를 다른 함수에게 인수로 넘길 수 있고, 생성된 곳이 아닌 곳에서도 함수를 호출할 수 있다.

함수 내부에서 함수 외부에 있는 변수에 접근할 수 있다는 사실은 모두 알고 있다.

  

그렇다면, 함수가 생성된 이후 외부 변수가 변경되면 어떤 일이 일어날까?

  

### 자바스크립트에서의 함수 내부 동작

  

자바스크립트에서는 실행 중인 함수, 코드 블록 `{...}`, 스크립트 전체는 렉시컬 환경이라 불리는 내부 숨김 연관 객체를 갖는다.

  

이 렉시컬 환경 객체는 두 개로 구성된다.

  

1. Enviroment Record 환경 레코드

  

- 모든 지역 변수를 프로퍼티로 저장하는 객체

- this와 같은 기타정보도 포함된다.

  

2. Outer Lexical Enviroment 외부 렉시컬 환경에 대한 참조

  

여기서 변수는 환경 레코드의 프로퍼티일 뿐이다. 변수를 가져오거나 변경하는 것은 환경 레코드의 프로퍼티를 가져오거나 변경하는 것이다.

  

이렇게 스크립트 전체와 관련된 렉시컬 환경은 전역 렉시컬 환경이라고 한다.

  

함수는 변수와 마찬가지인 값이지만, 함수 선언문으로 선언한 함수는 일반 변수와 달리 바로 초기화 된다는 차이가 있다.

  

함수 선언문으로 선언한 함수는 렉시컬 환경이 만들어지는 즉시 사용이 가능하다.

  

**보통 이렇게 변수명이 있어서 실행되면서 바로 인식하는 작용을 호이스팅이라고 한다**

  

함수를 호출해 실행하면 함수에 대한 새로운 렉시컬 환경이 자동으로 생성된다.

이 렉시컬 환경엔 함수 호출시 넘겨 받은 매개변수와 함수의 지역변수가 저장된다.

  

함수 호출 중엔 **호출 중인 내부 렉시컬 환경** 과 **내부 렉시컬 환경이 가리키는 외부 렉시컬 환경**을 갖게된다.

  

코드에서 변수에 접근할 때 순서는 아래와 같다.

  

- 먼저 내부 렉시컬 환경을 검색 범위로 잡는다.

- 내부 렉시컬 환경에 원하는 변수가 없다는 내부 렉시컬 환경이 참조하는 외부 렉시컬 환경으로 확장한다.

- 이 과정을 반복해서 원하는 변수를 전역 렉시컬 환경까지 탐색한다.

  

이를 통해 위에서 질문 했던 외부함수에 있던 변수에 접근할 때는 해당 변수가 어디에 있던 그 변수를 찾는 순간에 기억된 렉시컬 환경을 타고 올라고 해당 변수의 값을 가져오기에 해당 변수가 코드의 흐름에 맞게 읽힌다는 것을 알 수 있습니다.

  

이러한 **내부 함수에서 외부 함수에 있는 변수에 접근하는 것에 있어서 외부 변수가 사라지지 않고 접근 가능한 현상을 클로저** 라고 한다.

  

또한 이렇게 각 내부 함수에서 함수의 환경에 대한 정보를 가져오는 것은 자바스크립트 내부에서 호출장소와 상관 없이 함수가 자신의 생성된 곳을 기억할 수 있는 `[[Enviroment]]`라는 프로퍼티가 있기에 가능한 것이다.

  

이러한 것처럼 함수가 살아 있는 동아네은 모든 외부 변수 역시 메모리에 유지되지만, 실제 자바스크립트 엔진인 V8에서는 최적화 과정에서 제거된 변수를 사용할 수 없다는 단점이 있음을 알아두면 좋을 것 같다.

  

## 오래된 var

  

변수 선언에는 3가지가 있다.

  

1. let

2. const

3. var

  

var는 let과 const와는 다른 방식으로 동작한다.

  

### var의 특징

  

- 블록스코프가 없다.

  - 아무렇게나 외부에서 접근이 가능하다.

  - 함수 수준 스코프를 갖는다.

- 변수의 중복 선언을 허용한다.

  - 정말 똑같이 선언이 가능하다.

- 선언하기 전에 사용도 가능하다.

  - 시작되는 시점은 전역공간으로 처리된다.

  - 자동으로 호이스팅되어 사용이 가능하다.

  - 대신 할당 되기 이전이기에 undefined가 출력된다.

  

## 전역 객체

  

전역 객체는 window, Nodejs 환경에서는 global을 말한다.

즉, 언어 자체나 호스트 환경에 기본 내장되는 기본적으로 세팅되는 객체이며, 어디서든 접근 가능한 변수를 만들 수 있다.

표준이 있긴 한데 역시 브라우저는 지원되진 않지만 우리에게는 폴리필이 있다.

  

## 객체로서의 함수와 기명 함수 표현식

  

자바스크립트에서 함수는 값이다. 함수의 자료형은 객체이다. 쉽게 생각하면 호출 가능한 행동 객체이다.

  

함수에는 이름을 가져오는 .name 프로퍼티와 인수의 길이를 가져오는 .length를 지원한다.

  

함수 표현식으로 함수를 정의할때 이름이 있는 함수를 기명 함수 표현식이라고 한다.

  

## new Function 문법

  

함수 표현식, 선언식 외의 함수 생성 방법이다.

  

```js

let func = new Function([arg1, arg2, ...argN], functionBody);

```

  

이런 식으로 생성한다고 한다.

  

일반적으로 서버에서 동적인 데이터를 받아 그 데이터에 맞게 함수를 생성해야하는 경우 해당 방식을 많이 차용한다고 한다. 런타임에 관련된 작업 시 활용한다.

  

이전에 함수는 특별한 프로퍼티 `[[Environment]]`에 저장된 정보를 이용해 자기 자신이 태어난 곳을 기억합니다. `[[Environment]]`는 함수가 만들어진 렉시컬 환경을 참조한다고 설명한 적이 있다.

  

new Function을 사용하여 생성된 함수는 프로퍼티 `[[Environment]]`에 현재 렉시컬이 아닌 전역 렉시컬을 참조한다.

  

그렇기에 이렇게 동적으로 생성되는 함수는 외부 변수에 접근할 없으며, 오직 전역 변수에만 접근이 가능하다.

  

## setTimeout과 setInterval을 이용한 호출 스케줄링

  

일정 시간이 지난 후 원하는 함수를 예약 실행하는 것을 호출 스케줄링이라고 한다.

자바스크립트에서는 2가지 구현 방식이 있으며, setTimeout, setInterval 이 있다.

  

### setTimeout

  

```js

let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)

```

  

- 매개변수

  - `func|code`

    - 실행하고자 하는 코드로, 함수 또는 문자열 형태입니다. 대개는 이 자리에 함수가 들어갑니다. 하위 호환성을 위해 문자열도 받을 수 있게 해놓았지만 추천하진 않습니다.

    - return 하는 함수를 두어야 한다.

  - `delay`

    - 실행 전 대기 시간으로, 단위는 밀리초(millisecond, 1000밀리초 = 1초)이며 기본값은 0입니다.

  - `arg1, arg2…`

    - 함수에 전달할 인수들로, IE9 이하에선 지원하지 않습니다.

  

해당 함수를 호출하면 타이머 식별자가 반환된다. 혹여나 중간에 스케줄링을 취소하고 싶다면 clearTiemout 함수를 활용하면 된다.

  

만약 delay를 0으로 세팅한 경우에는 즉시 실행은 아니고, `현재 스크립트의 실행이 완료된 후 가능한 한 빠르게` 원하는 함수를 호출할 수 있습니다.

  

### setInterval

  

setTimeout과 동일한 문법을 활용한다.

차이점은 단 한번만 실행하는 setTimeout과 달리 함수를 주기적으로 실행하게 한다.

  

중단을 원하는 경우 clearInterval를 활용한다.

  

## call/apply와 데코레이터, 포워딩

  

자바스크립트에서의 함수 간의 호출을 어떻게 포워딩 하는지 어떻게 데코레이팅 하는가?

  

이거는 처음이라 예시를 좀 넣어보겠다.

CPU를 많이 잡아먹지만 결과는 안정적인 함수` slow(x)`가 있다고 가정.

`slow(x)`가 자주 호출된다면, 결과를 어딘가에 저장(캐싱)해 재연산에 걸리는 시간을 줄이고 싶은 경우가 있을 수 있다

  

```js

function slow(x) {

  // CPU 집약적인 작업이 여기에 올 수 있습니다.

  alert(`slow(${x})을/를 호출함`);

  return x;

}

  

function cachingDecorator(func) {

  let cache = new Map();

  

  return function (x) {

    if (cache.has(x)) {

      // cache에 해당 키가 있으면

      return cache.get(x); // 대응하는 값을 cache에서 읽어옵니다.

    }

  

    let result = func(x); // 그렇지 않은 경우엔 func를 호출하고,

  

    cache.set(x, result); // 그 결과를 캐싱(저장)합니다.

    return result;

  };

}

  

slow = cachingDecorator(slow);

  

alert(slow(1)); // slow(1)이 저장되었습니다.

alert("다시 호출: " + slow(1)); // 동일한 결과

  

alert(slow(2)); // slow(2)가 저장되었습니다.

alert("다시 호출: " + slow(2)); // 윗줄과 동일한 결과

```

  

`cachingDecorator`같이 인수로 받은 함수의 행동을 변경시켜주는 함수를 `데코레이터(decorator)` 라고 한다.

  

하지만 해당 코드는 `this`가 올바르게 전달되지 않아 에러 발생한다.

이를 `func.call`을 사용하여 `this`를 명시적으로 전달 할 수 있다.

  

```js

function cachingDecorator(func) {

  let cache = new Map();

  return function (x) {

    if (cache.has(x)) {

      return cache.get(x);

    }

    let result = func.call(this, x);

    cache.set(x, result);

    return result;

  };

}

```

  

apply도 call과 동일하게 동작하지만 차이점이 있다.

  

- 전개 구문 `...`은 이터러블 `args`을 분해 해 call에 전달할 수 있도록 해준다.

- apply는 오직 유사 배열 형태의 `args`만 받는다.

  

대부분의 자바스크립트 엔진은 내부에서 `apply`를 최적화 하기 때문에 `apply`를 사용하는 게 좀 더 빠르긴 하다.

  

이렇게 컨텍스트와 함께 인수 전체를 다른 함수에 전달하는 것을 `콜 포워딩(call forwarding)` 이라고 한다.

  

## 함수 바인딩

  

`this`가 사라지는 경우가 있다.

객체 메서드가 객체 내누박 아닌 다른 곳에 전달되어 호출되면 `this`가 사라진다.

  

```js

let user = {

  firstName: "John",

  sayHi() {

    alert(`Hello, ${this.firstName}!`);

  },

};

setTimeout(user.sayHi, 1000); // Hello, undefined!

// 1. wrapper 함수를 통한 해결

setTimeout(function () {

  user.sayHi(); // Hello, John!

}, 1000);

```

  

이렇게 된 이유는 setTimeout에 객체에서 분리된 함수인 user.sayHi가 전달되기 때문이다.

여기서 함수 사용하는 위치가 전역이기에 this는 전역객체를 가리키게 되어 this.firstName은 undefined가 됩니다.

  

이를 방지하는 방법으로는 wrapper 함수를 사용하거나 bind를 하는 방법이 있습니다.

  

### bind

  

bind는 모든 함수는 this를 수정하게 해주는 내장 메서드이다.

  

```js

let user = {

  firstName: "John",

};

  

function func() {

  alert(this.firstName);

}

  

let funcUser = func.bind(user);

funcUser(); // John

```

  

## 화살표 함수

  

화살표 함수는 몇 가지 독특하고 유용한 기능을 제공합니다.

  

### 화살표 함수에는 this가 없다.

  

화살표 함수 본문에서 this에 접근하면, 외부에서 값을 가져옵니다.

  

### 화살표 함수엔 'arguments’가 없다

  

- 화살표 함수는 일반 함수와는 다르게 모든 인수에 접근할 수 있게 해주는 유사 배열 객체 arguments를 지원하지 않는다.

  

이런 특징은 현재 this 값과 arguments 정보를 함께 실어 호출을 포워딩해 주는 데코레이터를 만들 때 유용하게 사용된다.

  

```js

function defer(f, ms) {

  return function () {

    setTimeout(() => f.apply(this, arguments), ms);

  };

}

  

function sayHi(who) {

  alert("안녕, " + who);

}

  

let sayHiDeferred = defer(sayHi, 2000);

sayHiDeferred("철수"); // 2초 후 "안녕, 철수"가 출력됩니다.

```

  

### new와 함께 호출할 수 없다.

  

- this가 없기 때문에 화살표 함수는 생성자 함수로 사용할 수 없다는 제약이 있다.

- 화살표 함수는 new와 함께 호출할 수 없다.

  

### 화살표 함수는 super가 없다

  

- this가 없다

  

화살표 함수는 컨텍스트가 있는 긴 코드보다는 자체 '컨텍스트’가 없는 짧은 코드를 담을 용도로 만들어졌습니다.