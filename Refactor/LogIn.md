# 로그인 리팩토링: useState 줄이기
## 서론
간단하게 이번 디깅과 관련해서 어떤 주제를 하면 좋을지를 생각했지만, 아무래도 코인에서 코인리코드로 넘어오면서 우리가 생각했던 것 보다 state를 남발하고 있다는 생각을 하게 되었고
state를 필요한 곳에서만 적재적소하게 사용하는 것을 최대 목표로 하였습니다.

그렇다면 state와 관련되어서 어떤 것이 문제인지 간단한 예제를 제시해보겠습니다.

[코인 로그인 페이지 입력 시 계속 리렌더링 표시가 남]

이렇게 우리가 의도하지 않은 단순한 입력이지만 페이지에서 강제적으로 렌더링 하는 것을 확인할 수 있다. 
과연 이런 부분에서 state를 사용할 필요가 있을까라는 생각을 하게 되었고, 실제 코드를 분석하고 useState의 어떤 부분에서 이런 문제가 발생하는지 분석해보자

## useState란?
useState는 React에서 제공하는 Hook 중 하나입니다. 함수형 컴포넌트에서 상태를 관리할 때 사용됩니다.

useState를 사용하면 현재 상태 값과 해당 값을 업데이트할 수 있는 함수를 반환합니다. 이를 통해 상태를 생성하고 변경할 수 있습니다. 상태 값은 컴포넌트의 렌더링 사이클 동안 유지되며, 상태가 변경될 때마다 컴포넌트가 리렌더링됩니다.

예를 들어, 다음과 같이 useState를 사용하여 상태를 관리할 수 있습니다.

```js
import React, { useState } from 'react';

const ExampleComponent = () => {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(count + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
};

export default ExampleComponent;
```

## useState의 내부 동작 

* 상태 초기화: useState는 매개변수로 초기 상태 값을 받습니다. 이 초기값은 컴포넌트가 처음 렌더링될 때만 사용됩니다.

* 상태 저장 및 업데이트 함수 생성: useState는 상태 값을 저장하고 해당 값을 업데이트할 수 있는 함수를 생성합니다. 이 함수는 상태를 변경할 때 사용됩니다. 이때, 상태 값과 업데이트 함수는 클로저로 묶여 해당 컴포넌트 내에서만 사용됩니다.

* 컴포넌트 렌더링: useState를 호출하는 컴포넌트가 렌더링될 때마다 useState는 현재 상태 값을 반환합니다.

* 상태 변경: useState가 반환한 업데이트 함수를 호출하여 상태를 변경할 수 있습니다. 상태를 변경하면 React는 변경된 상태를 감지하고, 해당 컴포넌트를 리렌더링합니다.

## setState의 비동기
`Props`, `state`는 현재 화면에 대한 영향을 준다는 것을 이해하셨을 것입니다.

여기서 `setState`는 비동기적 호출방식을 사용합니다. 
`setState` 호출 이후에 `this.state`에 의존하여 계산하는 방식은 지양하도록 합니다.
현재 `state`를 기반으로 값을 계산해야 하는 경우 객체 대신 업데이터 함수를 전달합니다


> setState는 비동기적으로 호출된다.
> 그렇기 때문에 setState로 호출한 이후에 즉각적으로 this.state를 통해 접근한다면 개발자의 예상과 벗어난 결과를 초래할 것입니다.
> 이를 방지하기 위해 객체 대신 함수를 활용하여 값을 전달합니다.

## setState는 언제 비동기일까?
`setState`는 현재 이벤트 핸들러내부에서 비동기적으로 작동합니다.

이렇게 하면 부모와 자식간의 관계에서 동시에 클릭이벤트가 발생시켰을 때  자식은 두 번 재렌더링 하지 않습니다.
대신 React는 브라우저 이벤트가 끝날 때 상태 업데이트를 한꺼번에 합니다.
이러한 동작 방식은 리액트의 성능에 큰 향상을 불러옵니다.

</br>

> 그렇다면 왜 setState는 비동기적으로 할까요? </br>
> 이유는 총 세가지가 있습니다. </br>
> React는 모든 변경사항을 한번에 처리하기 때문에 다시 렌더링을 하기전에 이벤트 핸들에서 호출할 때까지 의도적으로 기다립니다. 이렇게 해야 불필요한 렌더링을 줄일 수 있기 때문입니다. </br>
> 두 번째로는 Props와 state의 지속성이 붕괴되어 디버깅이 어려워진다입니다. </br>
> 세 번째는 리액트팀에서 앞으로 만들 기능들에 대해 구현을 어렵게 한다는 이유입니다.</br>

Reference: [Component State – React](https://reactjs.org/docs/faq-state.html)

## useRef를 활용한 current를 활용


## Digging Tech useState는 어떻게 상태를 확인하고 업데이트할까?

# 회원가입 부분 // 다음 내용


