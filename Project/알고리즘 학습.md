1. 파이썬 입출력
```python
# 정수 
// 정수
a, b = map(int, input().split())
// 문자열
# 문자열 
a, b = input().split()
```

2. 기초 자료구조 : 스택, 큐, 덱, 문자열

```python
// 스택
stack = []
# 데이터 추가
stack.append(1)
stack.append(2)
stack.append(3)

# 데이터 제거
print(stack.pop())  # 3
print(stack.pop())  # 2
print(stack.pop())  # 1

// 큐
from collections import deque

queue = deque()
# 데이터 추가
queue.append(1)
queue.append(2)
queue.append(3)

# 데이터 제거
print(queue.popleft())  # 1
print(queue.popleft())  # 2
print(queue.popleft())  # 3

//덱
from collections import deque

deque_obj = deque()
# 앞쪽에 추가
deque_obj.appendleft(1)
# 뒤쪽에 추가
deque_obj.append(2)

# 앞쪽에서 제거
print(deque_obj.popleft())  # 1
# 뒤쪽에서 제거
print(deque_obj.pop())      # 2

// 문자열 처리
text = "hello world"
// 문자열 길이 구하기
print(len(text))  // 11

# 문자열 나누기
words = text.split()  // ['hello', 'world']

# 문자열 조합
sentence = " ".join(words)  // 'hello world'

# 문자열 슬라이싱
print(text[0:5])  // 'hello'

# 문자열 대체
new_text = text.replace("world", "Python")  // 'hello Python'

```
## 동적 계획법
- 큰 문제를 작은 문제로 분할
- 아래 2가지 속성이 성립해야함
- Overlapping Subproblem : 피보나치
	- Fn = Fn-1 + Fn-2
	- 서로가 영향을 줌
	- 큰 문제를 작은 문제로 구할 수 있다.
- Optimal Substructure
	- 문제의 정답을 작은 문제의 정답에서 구할 수 있다.
- 한번만 풀어야한다
- 메모이제이션을 활용
- 푸는 방법은 2가지
	- Top-down
		- 재귀함수
		- 문제를 작은 문제로 나눈다.
	- bottom-up
		- 문제를 크기가 작은 문제부터 풀이
		- 작은 문제를 통해 큰 문제를 푸는 방식

## 그래프
- 정점과 간선으로 이루어진 관계
- 인접 행렬
	- 선언 및 기본 템플릿
```python
n, m = map(int, input().split())  # 정점 개수(n), 간선 개수(m)
graph = [[0] * n for _ in range(n)]  # n x n 인접 행렬 초기화

for _ in range(m):
    u, v = map(int, input().split())
    graph[u][v] = 1  # 방향 그래프인 경우
    graph[v][u] = 1  # 무방향 그래프라면 추가

```

	- DFS
```python
def dfs_matrix(v, visited):
    visited[v] = True
    print(v, end=" ")  # 방문한 정점 출력
    for i in range(n):
        if graph[v][i] == 1 and not visited[i]:
            dfs_matrix(i, visited)

```

	- BFS
```python
from collections import deque

def bfs_matrix(start, visited):
    queue = deque([start])
    visited[start] = True
    while queue:
        v = queue.popleft()
        print(v, end=" ")  # 방문한 정점 출력
        for i in range(n):
            if graph[v][i] == 1 and not visited[i]:
                queue.append(i)
                visited[i] = True

```
- 인접 리스트
	- 선언 및 기본 템플릿
```python
n, m = map(int, input().split())  # 정점 개수(n), 간선 개수(m)
graph = [[] for _ in range(n)]  # 인접 리스트 초기화

for _ in range(m):
    u, v = map(int, input().split())
    graph[u].append(v)  # 방향 그래프인 경우
    graph[v].append(u)  # 무방향 그래프라면 추가

```
	- DFS
```python
def dfs_list(v, visited):
    visited[v] = True
    print(v, end=" ")  # 방문한 정점 출력
    for neighbor in graph[v]:
        if not visited[neighbor]:
            dfs_list(neighbor, visited)

```
	- BFS
```python
from collections import deque

def bfs_list(start, visited):
    queue = deque([start])
    visited[start] = True
    while queue:
        v = queue.popleft()
        print(v, end=" ")  # 방문한 정점 출력
        for neighbor in graph[v]:
            if not visited[neighbor]:
                queue.append(neighbor)
                visited[neighbor] = True

```

- 간선 리스트
	- 선언 및 기본 템플릿
```python
n, m = map(int, input().split())  # 정점 개수(n), 간선 개수(m)
edges = []  # 간선 리스트 초기화

for _ in range(m):
    u, v = map(int, input().split())
    edges.append((u, v))  # 방향 그래프인 경우
    edges.append((v, u))  # 무방향 그래프라면 추가

```
	- DFS
```python
def dfs_edges(v, visited, edges):
    visited[v] = True
    print(v, end=" ")  # 방문한 정점 출력
    for u, w in edges:
        if u == v and not visited[w]:
            dfs_edges(w, visited, edges)

```
	- BFS
```python
from collections import deque

def bfs_edges(start, visited, edges):
    queue = deque([start])
    visited[start] = True
    while queue:
        v = queue.popleft()
        print(v, end=" ")  # 방문한 정점 출력
        for u, w in edges:
            if u == v and not visited[w]:
                queue.append(w)
                visited[w] = True

```