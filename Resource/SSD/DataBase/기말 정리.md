## 데이터 검색

- 데이터 검색은 쿼리문을 통해 탐색
	- SELECT *  FROM ~~ WHERE
	- DISTINCT
		- 중복 제외
	- AND, OR, NOT
		- 여러 조건 결합
	- BETWEEN A AND B
		- A와 B 사이
	- IN (A, B, C)
		- 속성값 중 하나라도 일치 시 참
	- IS NULL
		- NULL은 어떤 비교를 해도 거짓
		- IS NOT NULL 
	- LIKE
		- WHERE DNAME LINK H%n
	- UNION
		- 중복된 결과를 제거하고 하나의 결과 출력
	- UNION ALL
		- 중복된 결과까지 모두 출력
- 집합 연산자
	- 외부 합집합
		- 합병 호환성의 제약 조건
			- 차수가 같아야한다
			- 대응되는 속성의 쌍 별로 타입이 같아야한다.
			- 대응되는 속성의 쌍 별로 의미가 같아야한다.
		- 만약 두 질의 결과가 불일치 한 경우
			- 외부 합집합을 활용
			- 두 질의 결과의 속성수와 타입을 일치시키고, 모든 속성에서 사용할 수 있는 NULL을 통해 강제로 동일한 구조를 생성한다.
-  ORDER BY 절
	- 특정 속성 값을 기준으로 오름차순, 내림차순으로 정렬
	- ORDER BY {column_name} [ASC|DESC]
- 집단 함수
	- SUM 그룹의 합계
	- AVG 그룹의 평균
	- COUNT 그룹의 개수
	- MAX 그룹의 최대값
	- MIN 그룹의 최솟값
	- VAR 그룹의 분산
	- STDEV 그룹의 표준편차
- GROUP BY 절
	- SELECT 절에 집단 연산자는 GROUP BY에 사용한 속성명만 사용가능
	- 각 그룹에서 개별 튜플로 접근 불가
	- HAVING은 GROUP BY 절의 종속절
		- HAVING 각 그룹에 대한 제약 조건을 기술
>SELECT DNO, AVG(SALARY) AS DNOAVGSAL
>FROM EMPLOYEE
>GROUP BY DNO 
>HAVING MAX(SALARY) > 500 
- 부서의 최대 봉급이 500 초과인 부서에 대해서만부서별 사원들의 평균봉급과 부서번호를 출력하시오.
- TOP 함수
	- 기준 최고
SELECT top(5) *
FROM employee
order by salary desc

- SELECT 집단 함수() OVER (PARTITION BY 속성명)



## 조인과 중첩 질의문
- 조인 이란?
	- 여러개의 테이블에 하나의 SQL 질의문으로 한번에 조회할 수 있는 기능
	- 조인 표기법을 통해 SQL문 하나로 여러 테이블에서 검색 가능하다
	- 조인문 시 테이블에 각 접두사와 별명 기능을 통해 사용 가능
- 카티션 프로젝트
	- 두 테이블 모두 가능한 쌍을 생성하는 연산
- 조인의 종류
	- 이중 조인 (테이블이 2개)
		- 동등조인 =
		- 자연조인:  FROM 테이블명 NATURAL JOIN 테이블명
		- 세타조인 >
		- 셀프 조인 자기테이블 선언
	- 다중 조인 (여러 개)
		- 3중 조인
	- 안시 조인
		- 크로스조인
		- 내부조인
		- 외부조인
- 중첩 질의문이란?
	- 여러 SQL 간의 상호 전달 및 처리를 하는 질의문
	- 단일행 서브쿼리
		- 서브쿼리의 결과로 하나의 튜플만 반환
	- 다중행 서브쿼리
		- 서브 쿼리의 결과로 여러 개의 튜플 반환
	- 구분해야하는 이유는?
		- 일반적인 비교 연산자는 속성 값 간의 비교 연산에 의미하고, 집합에 대한 비교 연산은 불가하다
	- 다중행 서브쿼리의 경우 앞에 4개를 붙일 수 있음
		- IN 여러 값중 하나이기만 하면 참
		- ANY, SOME 하나라도 일치하면
		- ALL 모두 일치하면
		- EXIST 서브쿼리의 결과가 하나라도 존재하면
- 상호 연관 서브 쿼리
	- 메인, 서브 쿼리 간의 검색 결과를 교환하는 서브 쿼리
		- 어떤 튜플에 대한 조건을 비교하는가에 따라, 서브쿼리의 결과가 다르게 나온다.
		- 보통 이보다는 조인구문활용이 더 효과적인 경우도 있음

## 트랜잭션과 뷰
- 트랜잭션이란?
	- 논리적인 일의 단위로, 하나의 SQL은 하나의 트랜잭션이다.
	- 이 트랜잭션에 대해서는 동시성 제어가 필요하다
		- 동시에 수행되었을때 서로 간섭하지 못하도록 해야한다.
		- 고장나도 데이터베이스의 일관성을 유지해야한다.
		- 트랜잭션 단위의 회복을 이룸
	- 특성 (원일격영: ACID)
		- 원자성
			- 완전 수행, 완전 미수행
		- 일관성
			- 시간이 지나도 트랜잭션 없이 변하면 안됨
		- 격리성
			- 트랜잭션으로 갱신 중에는 다른 트랜잭션의 영향을 받으면 안됨
		- 지속성
			- 시스템이 고장나도 트랜잭션이 완료된 데이터는 그대로 유지되어야함
	- DB 기능
		- 회복 : 원, 지
		- 동시성제어 : 일, 격
		- 무결성제약 : 일
	![[Pasted image 20241209045038.png]]
	- COMMIT
		- 트랜잭션 수행됨
	- ROLLBACK
		- 트랜재션 취소하고 종료
	- SAVEPOINT
		- 현재 트랜잭션에서 ROLLBAKC 시킬 위치 지정
	- 이를 통해 
		- 데이터 무결성을 보장하고, 변경 전 상황을 확인하고
		- 논리적으로 연관된 작업의 그룹화를 할 수 있다.
	- 3 가지 트랜잭션 모드
		- 자동 커밋 트랜잭션
			- 하나의 명령문 = 하나의 트랜잭션을 기본
		- 명시적 트랜잭션
			- 명시적으로 사용자가 정의
		- 묵시적 트랜잭션
			- 복수개의 명령문을 하나의 트랜잭션으로 간주
	- 트랜잭션 주요 제어문
		- 트랜잭션 내에서 SAVEPOINT의 지정
			- SAVE TRAN 저장점명
		- 저장점 위치로 취소
			- ROLLBACK TRAN 저장점
- 뷰
	- 한마디로 가상 테이블
	- 뷰를 정의한 기본 테이블에 적용 가능하며, 무결성 제약 조건을 유지한다.
	- 왜 사용하는가
		- 사용자마다 특정 객체만 조회할 수 잇고, 복잡한 질의문을 단순화 가능하며, 데이터의 중복성을 최소화 할 수 있다.
	- 장점
		- 논리적 독립성, 보안, 데이터 단순화
	- 단점
		- 뷰의 정의 변경 불가
		- 삽삭갱 연산 제한
	- 단순 뷰
		- 하나의 기본 테이블 위에 정의된 뷰
	- 복합 뷰
		- 두 개 이상의 기본테이블로 파생된 뷰
	- 인라인 뷰
		- 하나의 질의문 내에서만 생성되어 사용하고, 종료되면 사라지는 뷰
	- WITH 절
		- 인라인 뷰의 또 다른 정의

## 색인
- 데이터 조직법
	- 순차 : 순서대로 저장
		- 쉬운레코드이지만, 필요한 레코드를 찾기 위해서 N 검색
	- 색인: 자료구조를 통한 데이터의 빠른 접근을 지원
		- 키값으로 빠르게 가능, 새로운 레코드 삽입 시 느리다는 단점
		- 인덱스가 효율적인 경우가 더 많다.
			- 변경이 드물고 WHREE이나 조인 조건에 자주 사용되는 컬럼들이 많다.
	- 해싱: 해싱함수를 통한 데이터 그룹핑

- 색인의 종류
	- 고유 인덱스
		- 유일값을 가지는 속성에 대하여 생성
	- 비고유 인덱스
		- 중복된 값을 가지는 속성에 생성
	- 단일 인덱스
		- 하나의 속성
	- 결합 인덱스
		- 두 개 이상의 속성
	- 집중 인덱스
		- 테이블의 튜플이 저장된 물리적 순서로 해당 색인의 키값 순서와 동일하게 유지되도록 구성된 색인
	- 비집중 인덱스
		- 집중 인덱스 아닌거
- 충돌
	- 2 개 이상의 키가 같은 해시값을 갖는 경우 충돌이 발생
	- 방지법
		- 오픈 해싱
			- 같은 해시값 위치에 연결 리스트를 하여 나중에 검색시 순차 검색으로 진행
		- 확장성 해싱
			- 키 값에서 일정 길이 부분의 비트를 해시값으로 활용

## 질의 최적화
- 질의 최적화
![[Pasted image 20241209050430.png]]

### 질의어 처리 과정

1. **SCANNER (토크나이저)**
    - SQL 질의문을 문법 단위(Token)로 분리.
2. **PARSER (구문 분석기)**
    - 문법 검사를 통해 내부 질의문으로 변환.
3. **질의어 최적화기**
    - 효율적인 실행 계획 생성.
4. **질의어 코드 생성기**
    - 실행 계획에 따른 실행 코드 생성.
5. **런타임 데이터베이스 처리기**
    - 실행 코드를 실행하여 질의 결과 생성
### 질의 최적화의 개념

1. **최적화**: 최소 비용으로 질의문을 실행하는 전략 선택.
2. **비용 기준**:
    - **DISK I/O 횟수**: 중요한 최적화 기준.
    - **중간 결과 크기**: 작을수록 네트워크 부하 감소.
    - **처리 시간/응답 시간**: 사용자 대화형 시스템에서 중요.

---

### 5. 최적화 규칙

1. **셀렉션 연산은 가능한 빨리 실행**:  
    
2. **프로젝션 연산은 마지막에 실행**:  
    
3. **조인 조건 우선 적용**:  

4. **교환법칙 사용**:  
    

---

### 6. 의미론적 최적화

- 제약 조건 및 데이터 범위 이용.
- **예시**:
    - 질의: "5학년 이상의 학생 이름 검색".
    - 제약 조건: 학년은 1~4.
    - 결과: "결과 없음"으로 최적화
## 연산자의 구현
### 1. SELECT 연산자의 구현

- **선형 탐색**: 모든 튜플 탐색 (비용: mmm).
- **이원 탐색**: 정렬된 데이터에서 log2mlog_2mlog2​m 비용.
- **색인 탐색**: logxm+1log_xm+1logx​m+1 (색인 트리 깊이 + 튜플 접근).

**문제**  
SELECT 연산자에서 색인 기반 탐색의 시간 복잡도는?  
**답**: logxm+1log_xm + 1logx​m+1.

---

### 2. PROJECT 연산자의 구현

- **중복 제거 없음**: 속성만 선택 (비용: mmm).
- **DISTINCT 포함**: 정렬/해싱 사용 (비용: m+mlog⁡mm + m \log mm+mlogm).

**문제**  
PROJECT 연산에서 DISTINCT가 포함된 경우 시간 복잡도는?  
**답**: m+mlog⁡mm + m \log mm+mlogm.

---

### 3. JOIN 연산자의 구현

- **중첩 루프 조인**: 모든 조합 탐색 (n×mn \times mn×m).
- **인덱스 조인**: 색인 활용 (n×log⁡xm×kn \times \log_xm \times kn×logx​m×k).
- **해시 조인**: 해시 테이블 활용 (n×hn \times hn×h).
- **정렬 합병 조인**: 정렬 후 병합 (nlog⁡n+mlog⁡m+n+mn \log n + m \log m + n + mnlogn+mlogm+n+m).

**문제**  
중첩 루프 조인의 단점과 보완 방식은?  
**답**:

- 단점: 느린 속도 (n×mn \times mn×m).
- 보완: 색인 조인, 해시 조인, 정렬 합병 조인.

---

### 4. 집합 연산자의 구현

- **합집합 (UNION)**: 중복 제거 필요.
- **교집합 (INTERSECT)**: 공통 튜플 확인.
- **차집합 (EXCEPT)**: 한 릴레이션에만 있는 튜플.

**문제**  
UNION과 UNION ALL의 차이점은?  
**답**:

- UNION: 중복 제거.
- UNION ALL: 중복 허용.

---

### 5. 집단 연산자의 구현

- **그룹화와 집계**: 특정 속성으로 그룹화 후 SUM, AVG 등 수행.
## 사용자의 관리
#### 주요 개념
1. **사용자 생성**: 새로운 사용자 생성.
2. **권한 부여 (GRANT)**: 사용자가 특정 작업을 수행할 권한 부여.
3. **권한 회수 (REVOKE)**: 부여된 권한 철회.
4. **역할(Role)**: 여러 권한을 묶어 사용자에게 할당.
```
-- 사용자 생성
CREATE USER 'new_user'@'localhost' IDENTIFIED BY 'password';

-- 권한 부여
GRANT SELECT, INSERT ON database_name.* TO 'new_user'@'localhost';

-- 권한 확인
SHOW GRANTS FOR 'new_user'@'localhost';

-- 권한 회수
REVOKE INSERT ON database_name.* FROM 'new_user'@'localhost';

-- 사용자 삭제
DROP USER 'new_user'@'localhost';
```

1. 다음 중 새로운 사용자를 생성하는 SQL 명령어는?
    - a) CREATE ROLE
    - b) CREATE USER
    - c) GRANT USER
    - d) ALTER USER
2. 사용자 권한을 확인하기 위한 SQL 명령어는 무엇인가?

## 프로시저, 사용자 정의 함수와 트리거

#### 주요 개념
1. **프로시저 (Procedure)**: 미리 저장된 SQL 명령어 집합으로 복잡한 작업 수행.
2. **사용자 정의 함수 (Function)**: 입력값을 받아 특정 값을 반환.
3. **트리거 (Trigger)**: 데이터베이스에서 특정 이벤트가 발생할 때 자동 실행.

## 장애와 회복

#### 주요 개념
1. **장애 유형**:
    - 시스템 장애: 하드웨어 또는 소프트웨어 문제로 인해 데이터 손실.
    - 미디어 장애: 디스크 손상 등 저장 매체 문제.
2. **회복 기법**:
    - 로그 기반 회복: REDO, UNDO.
    - 체크포인트: 복구 시간을 단축하기 위해 사용.
    - 미러링 및 백업.
## 동시성 제어

### 1. 동시성 제어의 필요성

- **공유성(Sharability)**: 여러 사용자가 데이터베이스를 동시에 사용.
    - **장점**: 응답 시간 단축, 시스템 활용도 증가.
    - **단점**: 비일관성, 갱신 분실, 연쇄 복귀 등의 문제 발생.

**문제**  
동시성 제어가 필요한 이유를 3가지 서술하시오.  
**답**: 갱신 분실, 비일관성, 연쇄 복귀.

---

### 2. 스케줄과 직렬 가능성

- **스케줄**: 트랜잭션 실행 순서.
    - **직렬 스케줄**: 순차적 실행. 정확성 보장.
    - **비직렬 스케줄**: 병렬 실행.
    - **직렬 가능 스케줄**: 직렬 스케줄과 결과가 동일한 비직렬 스케줄.

**문제**  
직렬 가능 스케줄의 조건은?  
**답**:

1. 동일 트랜잭션 포함.
2. 최종 데이터베이스 결과가 동일.

---

### 3. 충돌 직렬 가능성과 선행 그래프

- **충돌 직렬 가능**: 연산 순서가 충돌 없이 동일한 스케줄.
- **선행 그래프**: 충돌 관계를 나타낸 그래프. 사이클이 없으면 충돌 직렬 가능.

**문제**  
선행 그래프에서 직렬 가능 스케줄의 조건은?  
**답**: 사이클이 없어야 함.

---

### 4. 동시성 제어 기법

1. **로킹 (Locking)**
    
    - **공유 로크(Shared Lock)**: 읽기 전용.
    - **전용 로크(Exclusive Lock)**: 읽기 및 쓰기 허용.
2. **2단계 로킹 규약 (2PL)**
    
    - **확장 단계**: lock만 수행.
    - **축소 단계**: unlock만 수행.
3. **엄격 2PL (Strict 2PL)**
    
    - 모든 로크는 트랜잭션 종료 시까지 유지.
    - 연쇄 복귀 방지.

**문제**  
2단계 로킹 규약의 단계는 무엇인가?  
**답**: 확장 단계와 축소 단계.

**문제**  
충돌 직렬 가능 스케줄과 불가능 스케줄의 차이를 서술하시오.  
**답**: 충돌 직렬 가능은 선행 그래프에 사이클이 없으며, 불가능은 사이클이 있음.
## 교착상태

#### 주요 개념
1. **교착상태 조건**:
    - 상호 배제, 점유와 대기, 비선점, 순환 대기.
2. **교착상태 해결**:
    - 예방: 교착상태 조건 중 하나를 제거.
    - 회피: 은행가 알고리즘.
    - 탐지 및 복구.