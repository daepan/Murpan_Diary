### 1. 빈칸 채우기

**A. 어휘 분석의 목표**

- 프로그램의 물리적 설명을 (토큰)의 시퀀스로 변환합니다.
- 각 토큰은 (어휘 요소, lexeme)와 연결됩니다.
- 각 토큰은 선택적으로 (속성, attributes)를 가질 수 있으며, 이는 텍스트에서 파생된 추가 정보입니다. 예를 들어 숫자 값 등이 포함될 수 있습니다.
- 이 토큰 시퀀스는 파서에서 프로그램 구조를 복원하는 데 사용됩니다.

**B. 복합 정규 표현식**

- R1과 R2가 정규 표현식이라면, R1R2는 R1과 R2 언어의 (연결, concatenation)를 나타내는 정규 표현식입니다.
- R1과 R2가 정규 표현식이라면, R1 | R2는 R1과 R2의 (합집합, union)을 나타내는 정규 표현식입니다.
- R이 정규 표현식이라면, R*는 R의 (클리니 폐포, Kleene closure)를 나타내는 정규 표현식입니다.
- R이 정규 표현식이라면, (R)는 R과 동일한 의미를 갖는 정규 표현식입니다.

**C. 요약 (어휘 분석)**

- (어휘 요소, lexemes)는 정규 표현식으로 정의되는 문자열 집합입니다.
- 정규 표현식은 NFA로 변환될 수 있고, 그 후 DFA로 변환될 수 있습니다.
- DFA를 사용한 스캔은 빠르게 처리할 수 있습니다.
- 모든 토큰이 원본 소스 코드에서 직접 나오지는 않습니다. (Maximal-munch)

**D. (문맥 자유 문법, CFG)**은 언어를 정의하는 형식 언어입니다.

**E. 파스 트리(parse tree)는 (유도, derivation)의 단계를 인코딩한 트리입니다.

**F. 구문 분석의 목표는 토큰 시퀀스가 묘사하는 (구조, structure)를 복원하는 것입니다.

**G. CFG는 하나의 문자열에 대해 (모호한, ambiguous) 파스 트리가 두 개 이상 존재할 때 모호하다고 합니다.

**H. 문법이 비모호하게 될 수 있다면, 일반적으로 (계층화, layering)를 통해 비모호하게 만듭니다.

**I. 파스 트리는 구체적인 구문 트리이지만, 더 유용한 구조는 입력의 필수 구조만 유지하는 (추상 구문 트리, abstract syntax tree)입니다.

### 2. 빈칸 채우기

**A. 좌측 우선 DFS/BFS 알고리즘은 (백트래킹, backtracking) 알고리즘입니다.

**B. 시작 기호만으로 입력 프로그램을 얻기 위해 사용할 규칙을 어떻게 알 수 있나요? 답: (lookahead) 토큰 사용.

**C. 단순 예측 파서: LL(1) ● 상향식, 예측 파싱:

- L: (Left-to-right) 토큰 스캔
- L: (Leftmost) 유도.
- (1): (Lookahead) 토큰 1개.

**D. 하향식 파서와 대비되는 상향식 파서들은 (shift/reduce) 파서라 부릅니다.

**E. Shift: 다음 터미널을 스택에 (푸시, push)합니다.  
Reduce: 스택에서 몇 개의 심볼을 (팝, pop)한 후 적절한 비터미널을 푸시합니다.

**F. 핸들을 찾는 위치는 스택의 (상단, top)입니다.

**G. Shift/reduce 충돌은 Shift/reduce 파서가 토큰을 (shift)할지 감소할지 결정하지 못할 때 발생합니다.

**H. Reduce/reduce 충돌은 여러 (감소, reductions) 중 어느 것을 선택해야 할지 결정하지 못할 때 발생합니다.




Convert NFA to DFA
![](https://i.imgur.com/qfTL4F7.png)

B. Convert RE a(b|c)* to NFA and convert the NFA to a DFA.
![](https://i.imgur.com/Farhz6e.png)

![](https://i.imgur.com/G2lntD7.png)

**A**와 **B**는 언어에 대한 문법을 설계하는 문제입니다.

- 예를 들어, "0과 1로 이루어진 회문(앞뒤로 읽어도 동일한 문자열)을 생성하는 모든 문자열"에 대한 문법을 작성해야 합니다.
### 5. 질문에 답하기

**A. 정규 표현식으로 두 자리 이상의 홀수 표현하기**

- 정규 표현식 예시: (+|-) [123456789]+ [1234567890]* [13579]

**B. 정규 표현식을 CFG로 변환**

- 예를 들어, S → a*b를 CFG로 변환하는 문제입니다.

---

### 6. 질문에 답하기

**A. BFS의 문제점**

- 시간과 메모리 사용량이 매우 큽니다.
- 많은 문장 형식을 생성하지만 실제로 일치하지 않는 경우가 많음.
- 높은 분기 계수로 인해, 각 문장 형식은 여러 가지 방식으로 확장될 수 있음.

**B. 좌측 우선 BFS의 문제점**

- 특정 문법은 파싱에 지수 시간을 소요하게 만들 수 있으며, 메모리 사용량 또한 지수적으로 증가할 수 있습니다.

---

### 7. 질문에 답하기

**A. 좌측 우선 DFS의 문제점**

- A라는 비터미널이 A ⇒* Aω 형태로 유도될 수 있으면 좌측 우선 DFS는 좌측 재귀 문법에서 실패할 수 있습니다.

**B. 좌측 재귀 제거**

- 좌측 재귀를 제거하는 규칙을 작성해야 합니다.
![](https://i.imgur.com/ExIZ8QS.png)
---

### 8. 질문에 답하기

**A. 각 논터미널 기호의 FIRST와 FOLLOW 구하기**

- 주어진 문법에 대해 FIRST와 FOLLOW 집합을 구하는 문제입니다.

---


### Challenges in Semantic Analysis  
A. Reject the largest number of ( incorrect ) programs.
B. Accept the largest number of ( correct ) programs. 
C. Do so ( quickly ).

### Other Goals of Semantic Analysis
Gather useful information about program for later phases:

1. Determine what variables are meant by each ( identifier ).
    
2. Build an internal ( representation ) of inheritance hierarchies.
    
3. Count how many variables are in ( scope ) at each point.
    

### Implementing Semantic Analysis

( Attribute ) Grammars

1. Augment bison rules to do checking during parsing.
    
2. Approach suggested in the Compilers book.
    
3. Has its limitations; more on that later.
    

( Recursive ) AST Walk

1. Construct the AST, then use virtual functions and recursion to explore the tree.
    
2. The approach we'll take in this class.
    

### Two kinds of checking in Sematic Analysis
( Scope )-Checking

1. How can we tell what object a particular identifier refers to?
    
2. How do we store this information?
    

( Type )-Checking

1. How can we tell whether expressions have valid types?
    
2. How do we know all function calls have valid arguments?
    

<Scope & Symbol Tables>

A. The scope of an entity is the set of ( locations ) in a program where that entity's name refers to that entity.

B. A symbol table is a ( mapping ) from a name to the thing that name

refers to.

### Spaghetti Stacks 
A. Treat the symbol table as a ( linked ) structure of scopes.  
B. Each scope stores a pointer to its ( parents ), but not vice-versa.  
C. From any point in the program, symbol table appears to be a ( stack ).