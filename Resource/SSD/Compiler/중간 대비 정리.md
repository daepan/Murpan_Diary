A. Goals of Lexical Analysis

- Convert from physical description of a program into sequence of (          ).

- Each token is associated with a (          ).

- Each token may have optional (        ) - extra information derived from the text – perhaps a numeric value..  
- The token sequence will be used in the parser to recover the program structure.

tokens, lexeme, attributes

B. Compound Regular Expressions

If R1 and R2 are regular expressions, R1R2 is a regular expression represents the (          ) of the languages of R1 and R2.

If R1 and R2 are regular expressions, R1 | R2 is a regular expression representing the (           ) of R1 and R2.

If R is a regular expression, R* is a regular expression for the (      ) (      ) of R.

If R is a regular expression, (R) is a regular expression with the same meaning as (        ).

concatenation, union, Kleene closure, R

Summary (Lexical Analysis)

C.

(                     ) are sets of strings often defined with regular expressions. 

(                    ) expressions can be converted to NFAs and from there to DFAs

(               ) using an automaton allows for fast scanning.

Not all tokens come directly from the source code.

Lexemes, Regular, Maximal-munch


 A (              ) grammar (or CFG) is a formalism for defining languages. Goals of Lexical Analysis
    
    context-free
    
A parse tree is a tree encoding the steps in a (             ).
    
    derivation.
    

6. Goal of syntax analysis: Recover the (            ) described by a series  of tokens.
    
    structure
    
7. A CFG is said to be (               ) if there is at least one string with two or more parse trees.
    
    ambiguous
    
8. If a grammar can be made unambiguous at all, it is usually made unambiguous through (                        ).
    
    layering
    
9. A parse tree is a concrete syntax tree; it shows exactly how the text was
    derived. A more useful structure is an (              ) syntax tree, which retains only the essential structure of the input.
    
    abstract
    

2. Fill in the blanks.

1. The leftmost DFS/BFS algorithms are (                 ) algorithms.
    
    backtracking
    
2. Given just the start symbol, how do you know which productions to use to get to the input program? Idea: Use (               ) tokens.
    
    lookahead
    

C. A Simple Predictive Parser: LL(1) ● Top-down, predictive parsing:

● L: (                ) scan of the tokens

Left-to-right

● L: (               ) derivation.
 
Leftmost

● (1): One token of (             )

Lookahead



4. The bottom-up parsers we will consider are called shift/reduce parsers. Contrast with the LL(1) (        ) / (           ) parser.
    
    predict, match
    
5. Shift: (             ) the next terminal onto the stack.
    Reduce: (        ) some number of symbols from the stack, then push the appropriate nonterminal.
    
    Push, Pop
    
6. Where do we look for handles? At the (          ) of the stack.
    

top

7. A shift/reduce conflict is an error where a shift/reduce parser cannot tell whether to (            ) a token or perform a reduction.
    
    shift
    
8. A reduce/reduce conflict is an error where a shift/reduce parser cannot tell which of many (                    ) to perform.
    
    reductions



Convert NFA to DFA
![](https://i.imgur.com/qfTL4F7.png)

B. Convert RE a(b|c)* to NFA and convert the NFA to a DFA.
![](https://i.imgur.com/Farhz6e.png)

![](https://i.imgur.com/G2lntD7.png)

**A**와 **B**는 언어에 대한 문법을 설계하는 문제입니다.

- 예를 들어, "0과 1로 이루어진 회문(앞뒤로 읽어도 동일한 문자열)을 생성하는 모든 문자열"에 대한 문법을 작성해야 합니다.
### 5. 질문에 답하기

**A. 정규 표현식으로 두 자리 이상의 홀수 표현하기**

- 정규 표현식 예시: (+|-) [123456789]+ [1234567890]* [13579]

**B. 정규 표현식을 CFG로 변환**

- 예를 들어, S → a*b를 CFG로 변환하는 문제입니다.

---

### 6. 질문에 답하기

**A. BFS의 문제점**

- 시간과 메모리 사용량이 매우 큽니다.
- 많은 문장 형식을 생성하지만 실제로 일치하지 않는 경우가 많음.
- 높은 분기 계수로 인해, 각 문장 형식은 여러 가지 방식으로 확장될 수 있음.

**B. 좌측 우선 BFS의 문제점**

- 특정 문법은 파싱에 지수 시간을 소요하게 만들 수 있으며, 메모리 사용량 또한 지수적으로 증가할 수 있습니다.

---

### 7. 질문에 답하기

**A. 좌측 우선 DFS의 문제점**

- A라는 비터미널이 A ⇒* Aω 형태로 유도될 수 있으면 좌측 우선 DFS는 좌측 재귀 문법에서 실패할 수 있습니다.

**B. 좌측 재귀 제거**

- 좌측 재귀를 제거하는 규칙을 작성해야 합니다.
![](https://i.imgur.com/ExIZ8QS.png)
---

### 8. 질문에 답하기

**A. 각 논터미널 기호의 FIRST와 FOLLOW 구하기**
![](https://i.imgur.com/jXmincF.png)

- 주어진 문법에 대해 FIRST와 FOLLOW 집합을 구하는 문제입니다.
![](https://i.imgur.com/dQvdaHB.png)
 
![](https://i.imgur.com/gRBBzPA.png)

![](https://i.imgur.com/Mo8JS8X.png)

---


### Challenges in Semantic Analysis  
A. Reject the largest number of ( incorrect ) programs.
B. Accept the largest number of ( correct ) programs. 
C. Do so ( quickly ).

### Other Goals of Semantic Analysis
Gather useful information about program for later phases:

1. Determine what variables are meant by each ( identifier ).
    
2. Build an internal ( representation ) of inheritance hierarchies.
    
3. Count how many variables are in ( scope ) at each point.
    

### Implementing Semantic Analysis

( Attribute ) Grammars

1. Augment bison rules to do checking during parsing.
    
2. Approach suggested in the Compilers book.
    
3. Has its limitations; more on that later.
    

( Recursive ) AST Walk

1. Construct the AST, then use virtual functions and recursion to explore the tree.
    
2. The approach we'll take in this class.
    

### Two kinds of checking in Sematic Analysis
( Scope )-Checking

1. How can we tell what object a particular identifier refers to?
    
2. How do we store this information?
    

( Type )-Checking

1. How can we tell whether expressions have valid types?
    
2. How do we know all function calls have valid arguments?
    

<Scope & Symbol Tables>

A. The scope of an entity is the set of ( locations ) in a program where that entity's name refers to that entity.

B. A symbol table is a ( mapping ) from a name to the thing that name

refers to.

### Spaghetti Stacks 
A. Treat the symbol table as a ( linked ) structure of scopes.  
B. Each scope stores a pointer to its ( parents ), but not vice-versa.  
C. From any point in the program, symbol table appears to be a ( stack ).