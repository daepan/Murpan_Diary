## 🔒 해시
해시란, **데이터를 입력받아 완전히 다른 모습의 데이터로 바꾸는 작업**

### 해시의 주요 용도
* 해시 테이블 : 해시값을 테이블 내 주소로 이용하는 탐색의 알고리즘
* 암호화 : 해싱은 원본 데이터를 변경함
* 데이터 축약 : 해시는 길이가 서로 다른 입력 데이터에 대해 일정한 길의 출력을 만들 수 있으며, 커다란 데이터를 해시하면 짧은 길이로 축약가능함


## 🌐 해시테이블

데이터의 해시값을 테이블 내 주소로 이용하는 탐색 알고리즘
배열을 선언하면 메모리에 일정 크기의 메모리가 예약된다.

데이터의 해시값을 테이블 내의 주소로 사용한다.

### 해시테이블의 기본 개념
데이터를 담을 미리 크게 확보해 놓은 후 입력 받은 데이터를 해싱하여 테이블 내 주소를 계산하고 이 주소에 데이터를 담는 것
![[Pasted image 20240418011539.png]]

### 해시 테이블의 특징
![[Pasted image 20240418011600.png]]

### 해시함수 해싱 기법

1. 나눗셈법
2. 자릿수 접기

#### 나눗셈법

> 주소 = 입력값 % 테이블의 크기

나눗셈법으로 구현된 해시 함수가 테이블 내 공간을 효율적활용
* 테이블의크기 n을 소수(Prime Number)로 정하는 것이 좋음
* (소수: 약수가 1과 자기 자신 밖에 없는 수)
 
특히 2의 제곱수와 거리가 먼 소수를 사용하는 해시 함수가 좋은 성능

![[Pasted image 20240418011657.png]]


* 나눗셈법의 단점
	* 충돌(Collision)
		* 서로 다른 입력값에 대해 동일한 해시값, 즉 해시 테이블 내의 동일한 주소를 반환할
		* 가능성이 높음 -> 나머지가 같은 수가 나올 확률이 높음
	
	* 클러스터(Cluster) 
		* 똑같은 해시값이 아니더라도 해시 테이블 내 일부 지역의 주소들을 집중적으로 반환함
		* 데이터가 한 곳에 모이는 문제가 발생할 가능성


#### 자릿수 접기

* 종이를 접듯이 숫자를 접어 일정한 크기 이하의 수로 만드는 방법
* 숫자의 각 자릿수를 더해 해시값을 만드는 방법
![[Pasted image 20240418012047.png]]


* 수의 경우 모든 수는 각 자리마다 0~9까지의 값을 가질 수 있으므로, 7자리수에 대해
	* ‘한 자리씩 접기’ : 최소 0에서 최대 63(9 + 9 + 9 + 9 + 9 + 9 + 9)까지의 해시값
	* 두 자리씩 접기’: 최소 0에서 최대 306(99 + 99 + 99 + 9)까지의 해시값

* 자릿수 접기는 문자열을 키로 사용하는 해시 테이블에 특히 잘 어울리는 알고리즘
	* 문자열의 각 요소를 ASCII 코드 번호로 바꾸고, 이 값들을 각각 더해서 접으면 문자열을 깔끔하게 해시 테이블의 주소로 바꿀 수 있기 때문임

![[Pasted image 20240418012346.png]]

* 자릿수 주소의 문제점
	* 활용되지 않는 주소 문제
		* 해시 테이블의 크기가 12289이고 문자열 키의 최대 길이가 10자리라고 가정한다.
		* 비트 문제
			* 테이블의 크기 12289를 2진수로 표현하면 11 0000 0000 0001
			* 11 0000 0000 0001은 총 14개의 비트
			* 반면에 앞의 코드에 있는 Hash( ) 함수가 반환하는 최대 주소값은 1270(이진수: 100 1111 0110)으로 11비트만 사용
				- 테이블의 주소 중 3개의 비트는 사용되지 않고 있음
		- 해시 함수는 10×127=1270이므로 0에서 1270 사이의 주소만 반환
			- 1271~12288 사이의 주소는 전혀 활용되지 않고 폐가가 됨

### 💥 해시 함수의 한계: 충돌
해시 함수가 서로 다른 입력값에 대해 동일한 해시 테이블 주소를 반환하는 것

> 해결 방법
> 1. 개방 해싱
> 2. 폐쇄 해싱


## 🚑 해시 테이블 충돌 해결 기법

### 체이닝

해시 함수가 서로 다른 키에 대해 같은 주소값을 반환해서 충돌이 발생하면 각 데이터를 해당 주소에 있는 링크드 리스트에 삽입하여 문제를 해결하는 기법
![[Pasted image 20240418013220.png]]


> 체이닝의 성능 향상 방법
> ⁃ 체이닝은 원하는 데이터를 찾기 위해 순차 탐색을 해야 하는 링크드 리스트의 단점을 가짐
> ⁃ 해시 함수의 성능이 좋지 않아 충돌이 잦다면 해시 테이블과 이진 탐색 트리의 결합은 훌륭한 선택

### 탐색 연산

탐색 연산은 앞으로 "발생할 충돌"을 고려해서 설계
##### 체이닝 기반의 해시 테이블에서 탐색 수행 순서
❶ 찾고자 하는 목표값을 해싱하여 링크드 리스트가 저장된 주소를 찾음
❷ 이 주소를 이용하여 해시 테이블에 저장된 링크드 리스트에 대한 포인터를 생성
❸ 링크드 리스트의 앞에서부터 뒤까지 차례대로 이동하며 목표값이 저장되어 있는지 비교
목표값과 링크드 리스트 내 노드값이 일치하면 해당 노드의 주소를 반환


### 삽입 연산

해시 함수를 이용하여 데이터가 삽입될 링크드 리스트의 주소를 얻어낸 후 링크드 리스트가 비어있으면 바로 삽입하고, 그렇지 않다면 링크드 리스트의 헤드 앞에 삽입한다.

![[Pasted image 20240418013456.png]]


### 개방 주소법

충돌이 일어날때 해시 함수에 의해 만들어진 주소가 아니더라도 얼마든지 다른 주소를 사용할 수 있도록 허용하는 충돌 해결 알고리즘

* 선형 탐색
	* 가장 간단한 탐사 방법
	* 해시함수로부터 얻어낸 주소에 이미 다른 데이터가 있을 경우, 현재 주소에서 고정폭으로 주소를 이동
	* 이를 반복
![[Pasted image 20240418013537.png]]


* 제곱 탐사
	* 개념은 선형탐색과 유사
	* 차이점은 선형 탐사에서는 고정폭 만큼 이동하는 것에 비해 이동폭이 제곱수로 늘어남
![[Pasted image 20240418013611.png]]

![[Pasted image 20240418013602.png]]

자리에 대해서 n번 충돌이 일어날때마다 n^2의 위치로 이동한다는 규칙이다.

### 이중 해싱
* 2개의 해시 함수를 준비해서 하나는 최초의 주소를 얻을 떄 또 다른 하는 충돌이 일어날때 탐사 이동폭을 얻기 위해 사용

###  재해싱
* 남은 공간이 거의 없는 해시테이블에서 연쇄충돌이 자주 발생
* 해시테이블의 크기를 늘리고 늘어난 해시테이블의 크기에 맞춰 테이블 내의 모든 데이터를 다시 해싱하여 재배치하는 방법
* 통계적으로 해시테이블의 공간 사용률이 70 ~ 80%에 이르면 성능 저하가 시작

