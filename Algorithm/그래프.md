## 정의

* "정점의 모음"과 이 정점을 잇는 "간선의 모음"이 결합한 것
* 사이클이라는 정점 하나를 두 번 이상 거치도록 되어 있는 경로가 존재할 수 있다.
* 방향성 그래프와 무방향성 그래프
* 연결성
	* 무방향성 그래프 내의 두 정점 사이에 경로가 존재하면 이 두 정점이 연결되어 있다고 표현
	* 그래프 내의 각 정점이 다른 모든 정점과 연결되어 있으면, 이 그래픈 연결되었다고 표현한다.

![[Pasted image 20240615220013.png]]


## 인접 행렬

### 무항성 그래프의 인접 행렬
* 정점끼리의 인접 관계를 나타내는 행렬
	* 그래프의 정점 수를 N.이라고 할 때, N x N 크기의 행렬을 만들어 한 정점과 또 다른 정점을 인접해 있는 경우 정점사이에 간선이 존재하는 경우 행렬의 각 원소를 1로 표시하고 인접해 있지 않은 경우 0으로 표시
![[Pasted image 20240615220408.png]]


### 방향성 그래프의 인접 행렬

* 방향성 그래프에서의 정점은 자신이 직접 간선을 통해 가리키고 있는 정점에 대해서만 인접해 있다고 표현
* 아래 그림에서 정점 1은 정점 2, 3, 4, 5에 인접해 있지만, 3, 4는 인접한 정점이 하나도 없음
![[Pasted image 20240615221036.png]]

## 인접 리스트

* 그래프 내 각 정점의 인접 관계를 표현하는 리스트
	* 각 정점이 자신과 인접한 모든 정점의 목록을 리스트로 관리
	* 모든 정점을 늘어놓고 각 정점의 인접 정점을 옆에 나열
	* 인접 정점들끼리 리스트로 연결한 후 이를 각 정점에 연결
![[Pasted image 20240615221250.png]]


## 인접 행렬과 인접 리스트 비교

* 인접 행렬
	* 장점 = 정점 간의 인접 여부를 빠르게 알 수 있다.
	* 단점 = 인접 관계를 행렬 형태로 저장하기 위한 메모리의 양의 정점의 크기 x N^2 만큼 커짐
* 인접 리스트
	* 장점 = 정점과 간선의 삽입이 빠르고 인접 관계를 표시하는 리스트에 사용되는 메모리가 적다.
	* 단점 = 정점간의 인접 여부를 알기 위해서는 인접 리스트를 타고 순추탐색을 해야한다.


## 그래프 순회 기법

* 깊이 우선 탐색 (DFS)
	* 1단계 : 시작 정점부터 이 정점에 대해 방문했음을 표시
	* 2단계 : 이 정점과 이웃 정점(인접 정점) 중에 직 방문하지 않은 곳을 선택하여 이를 시작 정점으로 삼고 다시 깊이 우선 탐색을 시작, 다시 1단계를 다시 수행
	* 3단계 : 더 이상 방문하지 않은 이웃 정점이 없으면, 이전 정점으로 돌아가 단계 2를 수행
	* 4단계 : 이전 정점으로 돌아가도 더 이상 방문할 이웃 정점이 없다면, 그래프의 모든 정점을 방문했다는 뜻이므로 탐색을 종료
![[Pasted image 20240615222212.png]]

* 너비 우선 탐색(BFS)
	* 1단계 : 시작 정점을 '방문했음'으로 표시하고 큐에 삽입
	* 2단계 : 큐로부터 정점을 제거. 제거한 정점의 인접 정점 중에서 아직 방문하지 않은 곳을 '방문했음'으로 표시하고 큐에 삽입
	* 3단계 : 큐가 비면 탐색이 완료. 따라서 큐가 빌 때까지. 2단계의 과정을 반복.
![[Pasted image 20240615222516.png]]


## 위상 정렬

* 위상 정렬이 가능한 그래프
	* 그래프에 방향성이 있어야 함
	* 그래프 내에 사이클이 없음
* 동작 방식
	* 방향성 간선
		* 진입 간선 : 정점으로 들어가는 간선
		* 진출 간선: 정점에서 나가는 간선
	* 위상 정렬의 과정
		* 1단계 : 리스트를 하나 준비
		* 2단계 : 그래프에서 진입 간선이 없는 정점을 리스트에 추가하고, 해당 정점 자신과 진출 간선을 제거
		* 3단계 : 모든 정점에 대해 2단계를 반복하고 그래프 내에 그래프 내에 정점이 남아 있지 않으면 정렬을 종료. 이때 리스트에는 위상정렬된 그래프가 저장

![[Pasted image 20240616124503.png]]
![[Pasted image 20240616124514.png]]
![[Pasted image 20240616124521.png]]

### 깊이 우선 탐색을 이용한 위상 정렬

* 1단계: 리스트를 하나 준비
* 2단계: 그래프에서 진입 간선이 없는 정점에 대해 깊이 우선 탐색을 시행하고 탐색 중에 더이상 옮겨갈 수 있는 인접 정점이 없는 정점을 만나면 이 정점을 리스트의 헤드로 입력
* 3단계: 2단계를 반복하다가 더 이상 방문할 정점이 없다면 깊이 우선 탐색을 종료. 종료 후 리스트에 위상정렬된 그래프가 남음 

![[Pasted image 20240616131652.png]]
![[Pasted image 20240616131703.png]]
![[Pasted image 20240616131709.png]]
![[Pasted image 20240616131717.png]]
## 최소 신장 트리

1. 신장 트리
	1. 그래프의 모든 정점을 연결하는 트리
	2. 신장트리는 그래프의 하위 개념
2. 최소 신장 트리
	1. 최소 가중치 신장 트리
	2. 여러 간선 중 가중치의 합이 최소가 되는 간선만 남긴 신장 트리
3. 최소 신장 트리 알고리즘의 종류
	1. 프림 알고리즘
	2. 크루스칼 알고리즘


### 프림 알고리즘

* 1단계 : 그래프와 최소 신장 트리를 준비 -> 이때의 최소 신장 트리는 노드가 하나도 없는 상태
* 2단계 : 그래프에서 임의의 정점을 시작 정점으로 선택하여 최소 신장트리의 뿌리노드로 삽입
* 3단계 : 최소 신장 트리에 삽입된 정점들과 이 정점들의 모든 인접 정점 사이에 있는 간선의 가중치를 조사해야한다.
	* 간선 중에 가장 가중치가 작은 것만 골라 이 간선에 연결된 인접 정점을 최소 신장 트리에 삽입
	* 이때 새로 삽입되는 정점은 최소 신장 트리에 삽입된 기존 노드와 사이클을 형성해서는 안된다.
* 4단계 :  3단계의 과정을 반복하다 최소 신장 트리가 그래프의 모든 정점을 연결하게 되면 알고리즘 종료.

![[Pasted image 20240616132447.png]]![[Pasted image 20240616132453.png]]
![[Pasted image 20240616132458.png]]