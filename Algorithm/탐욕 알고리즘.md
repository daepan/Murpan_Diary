
## 동작 과정
* 1단계 : 해 선택 = 현재 상태에서 부분 문제의 최적해를 구한 후 이를 부분해의 집합에 추가
* 2단계 : 실행 가능성 검사 = 새로운 부분해 집합이 실행 가능한 것인지 확인
	* 다시 말해, 문제의 제약 조건을 위반하지 않는 지를 검사
* 3단계 : 새로운 부분해 집합이 문제의 해가 되는지 확인
	* 아직 전체 문제의 해가 완성되지 않았다면, 1단계의 해 선택부터 다시


## 크루스칼 다시 보기

* 탐욕 관점에서 크루스칼 알고리즘
	* 그래프 내 모든 간선을 가중치의 오름차순으로 정렬하여 목록을 생성
	* 1단계 에서 만든 간선의 목록을 차례대로 순회하면서 간선을 최소 신장트리에 추가
		* 이때 추가된 간선으로 인해 사이클이 생성되면 안됨

## 데이크스트라 다시 보기

* 그래프의 한 정점에서 다른 정점으로 향하는 가장 짧은 경로를 구하는 알고리즘

## 허브만 코딩

* 가장 효율적인 이진 코드 기법을 고안하라

### 고정 길이 코드와 접두어 코드

#### 고정 길이 코드

* 모든 코드의 길이가 똑같은 값을 갖는 코드 체계
	* 아스키 코드가 대표적인 예시  - 이 코드 집합의 모든 코드는 8비트 길이를 가진다.
	* 고정 길이 코드의 최대 장점은 다루기 쉽다.


#### 가변 길이 코드

* 저장 공간 절약을 위해 사용
	* 하지만 데이터 처리가 상당히 번거롭다.
	* 접두어 코드는 가변 길이 코드의 한 종류

### 허프만 트리 구축

* 허프만 코딩 알고리즘의 주요 키워드
	* 기호의 빈도
	* 이진 트리

#### 기호의 빈도

* 한 기호가 데이터 안에서 차지하는 비율
	* 문자열의 길이와 내부의 문자의 숫자가 나타나는 횟수를 빈도라고 한다.
* 기호의 빈도는 길이가 짧은 접두어 코드를 빈도가 높은 기호에 부여하기 위해 사용
	* 빈도가 높은 기호에 작은 접두어 코드를 부여하면, 저장공간을 절약하여
		* 압축률을 높힌다.

#### 이진 트리

* 접두어 코드를 표현하기 위해 사용
	* 트리의 노드에서 왼쪽 자식은 0 오른쪽 자식 노드는 1
* 이 트리에서 모든 기호는 잎 노드에만 기록되어 있으며, 뿌리 노드에서부터 잎 노드까지 이르는 경로가 기호의 접두어 코드가 된다.
	* 이 방식으로 접두어 코드를 표현하는 이진트리 허프만 트리가 생성된다.

![[Pasted image 20240616175147.png]]


## 허프만 코딩 동작 방식

* 동작 방식
	* 1단계 해 선택
		* 선택 기준은 현 시점에서 빈도가 가장 작은 노드 2개
		* b, c가 모두 빈도 1로 가장 작은 노드. 이 노드를 선택한 후 두 노드 위에 부모 노드를 새로 만들어가 각각 왼쪽 오른 쪽에 연결
		* 이때 부모 노드의 빈도는 자식 노드 빈도의 합
		* 새로 만든 부모 노드를 노드 집합에 추가
![[Pasted image 20240616175341.png]]
	
* 2단계  실행 가능성 검사
	* 기호를 가진 노드는 잎 노드여야 하는데 아직까지는 규칙을 위반하지 않으므로 실행 가능성 검사를 통과
* 3단계 해 검사
	* 허프만 트리를 완성하지 못했으므로 해검사를 통과하지 못하여 해 선택 단계로 복귀
	* 현재 상테에서 이전 단계에서 새로 만든 b,c의 부모 노드와 d 노드의 빈도가 가장 작으로 이 두 노드를 선택
		* 부모 노드를 새로 만들고 b,c의 부모 노드와 d 노드를 자식 노드를 연



	
		