### 기본 개념

- **멀티프로그래밍으로 최대 CPU 사용률 달성**:
    - 여러 프로그램이 메모리에 동시에 존재함으로써 CPU가 항상 일을 할 수 있도록 합니다.

- **CPU-I/O 버스트 사이클**:
    - 프로세스 실행은 CPU 실행과 I/O 대기의 사이클로 구성됩니다.

- **CPU 버스트 분포**:
    - 짧은 CPU 버스트와 긴 I/O 버스트가 일반적입니다.

### CPU 스케줄러

- **실행 준비가 된 메모리 내 프로세스 중에서 선택하여 CPU를 할당**:
    - CPU 스케줄링 결정은 다음과 같은 경우에 이루어질 수 있습니다:
        1. 프로세스가 실행 상태에서 대기 상태로 전환할 때 (I/O 요청 또는 대기)
        2. 프로세스가 실행 상태에서 준비 상태로 전환할 때 (인터럽트)
        3. 프로세스가 대기 상태에서 준비 상태로 전환할 때 (I/O 완료)
        4. 프로세스가 종료될 때.

- **1번과 4번의 스케줄링은 비선점형입니다**:
    - CPU가 프로세스에 할당되면, 해당 프로세스는 종료하거나 대기 상태로 전환할 때까지 CPU를 유지합니다.

- **그 외의 모든 스케줄링은 선점형입니다**:
    - 선점형 스케줄링은 비용을 발생시킵니다.
        - 특별한 하드웨어(예: 타이머)가 필요합니다.
        - 커널의 설계 복잡성이 증가합니다.

이러한 개념들은 운영 시스템의 CPU 스케줄링 및 프로세스 관리 방법에 대한 이해를 돕습니다.


### 디스패처

- **디스패처 모듈은 단기 스케줄러에 의해 선택된 프로세스에 CPU 제어권을 부여합니다**. 이 과정에는 다음이 포함됩니다:
    
    - 컨텍스트 전환
    - 사용자 모드로 전환
    - 프로그램을 재시작할 적절한 위치로 점프
- **디스패치 지연**:
    
    - 디스패처가 한 프로세스를 중지하고 다른 프로세스를 실행하기까지 걸리는 시간입니다.

### 스케줄링

- **메커니즘: 컨텍스트 스위치**:
    
    - 컨텍스트 스위치 메커니즘은 커널이 한 프로세스에서 다른 프로세스로 전환하는 방법을 처리합니다. 이는 해당 프로세스의 컨텍스트를 저장하고 다른 프로세스의 컨텍스트를 복원함으로써 이루어집니다.
- **메커니즘: 선점**:
    
    - 실행 중인 프로세스를 중지하고 다른 프로세스를 시작하는 작업입니다.
- **스케줄링 정책이란?**:
    
    - 스케줄링 정책은 다음에 실행할 프로세스를 결정합니다. "준비" 상태인 프로세스가 하나만 있다면 답은 간단합니다. 그러나 여러 프로세스가 있을 경우 정책은 프로세스가 실행될 순서를 결정합니다.

이러한 내용은 운영 체제에서 프로세스 간에 효율적으로 CPU를 할당하고 관리하는 방법을 설명합니다. 디스패처는 프로세스 실행의 실제 시작점 역할을 하며, 스케줄링은 시스템의 전체적인 성능과 반응성을 유지하는 데 중요한 역할을 합니다.

### 스케줄러 메트릭스

- **사용률 (Utilization)**:
    
    - CPU가 프로그램을 실행하는 시간의 비율입니다. 목표는 이를 최대화하는 것입니다.
- **반환 시간 (Turnaround time)**:
    
    - 프로세스 생성부터 프로세스 종료까지 걸리는 총 시간입니다. 목표는 이 시간을 최소화하는 것입니다.
- **응답 시간 (Response time)**:
    
    - 요청이 제출된 후 첫 번째 응답이 생성되기까지 걸리는 시간입니다. 목표는 이 시간을 최소화하고, 상호작용 시스템의 응답 시간 변동성을 최소화하는 것입니다.
- **처리량 (Throughput)**:
    
    - 단위 시간당 실행을 완료하는 프로세스의 수입니다. 목표는 이를 최대화하는 것입니다.
- **대기 시간 (Waiting time)**:
    
    - 프로세스가 준비 큐에서 대기한 시간의 총량입니다. 목표는 이 시간을 최소화하는 것입니다.
- **공정성 (Fairness)**:
    
    - 모든 프로세스가 시간이 지남에 따라 동일한 CPU 시간을 얻는 것입니다. 목표는 기아 현상이 없도록 하는 것입니다.
- **진행 (Progress)**:
    
    - 프로세스가 전진 진행을 할 수 있도록 하는 것입니다. 목표는 커널 인터럽트를 최소화하는 것입니다.

이러한 메트릭스는 스케줄러의 성능을 평가하고, 특정 스케줄링 정책의 효과를 측정하는 데 중요한 기준입니다. 각 메트릭스는 시스템의 효율성과 공정성을 유지하면서 사용자와 프로세스의 요구를 충족시키는 데 도움을 줍니다.

## FCFS

## SJF

## SRTN

## 우선순위 스케줄링

- **각 프로세스에는 우선순위 번호(정수)가 연결됩니다**:
    
    - CPU는 가장 높은 우선순위(가장 작은 정수 = 가장 높은 우선순위)를 가진 프로세스에 할당됩니다.
- **선점형 및 비선점형**:
    
    - **선점형**: 더 높은 우선순위의 프로세스가 등장하면 현재 실행 중인 프로세스를 중단시키고 CPU를 즉시 재할당합니다.
    - **비선점형**: 한 번 CPU를 할당받으면 해당 프로세스가 CPU를 해제할 때까지 유지합니다.
- **SJF(Shortest Job First)는 우선순위 스케줄링의 한 예로, 우선순위는 예측된 다음 CPU 버스트 시간에 따라 결정됩니다**.
    
- **문제점  기아(Starvation)**:
    
    - 낮은 우선순위를 가진 프로세스는 실행될 기회를 얻지 못할 수 있습니다.
- **해결책  에이징(Aging)**:
    
    - 시간이 지남에 따라 프로세스의 우선순위를 점진적으로 높여서 오래 대기한 프로세스가 실행될 수 있도록 합니다.

## HRRN (High-Response-Ratio-Next)
* 실행 시간이 긴/짧은 프로세스들간의 불평등 심화 방지 기법
* 응답률이 가장 높은 프로세스에게 우선권을 주는 방식
* 응답률
	* 서비스 시간(service time)에 대한 대기 시간(waiting time) 비율
	
*  특정 프로세스의 장시간 대기 방지
* 준비상태에서 기다리는 시간이 길어질수록 우선 순위 향상됨
* SJF 스케줄링 기법의 효과 얻음
* 단점: 프로세스의 총 실행 시간 추정 오버헤드 발생
![[Pasted image 20240421005505.png]]

### 반환 시간 대 응답 시간

- **반환 시간 최적화**:
    
    - 지금까지는 작업을 가능한 빨리 완료하는 것, 즉 반환 시간을 최적화하는 데 중점을 두었습니다. 반환 시간은 프로세스가 생성되어 완료되기까지 걸리는 전체 시간을 의미합니다.
- **대화형 시스템에서의 응답 시간**:
    
    - 대화형 시스템에서는 응답 시간이 마찬가지로 중요합니다. 응답 시간은 사용자가 작업을 요청하고 그 작업이 스케줄되어 첫 반응이 나타나기까지 걸리는 시간을 말합니다.

대화형 시스템에서 사용자는 작업의 완료보다는 작업이 얼마나 빨리 시작되는지에 더 민감하게 반응할 수 있습니다. 따라서 사용자 경험을 개선하고 시스템의 반응성을 높이기 위해 응답 시간을 최소화하는 것이 중요합니다. 이는 사용자가 시스템과 상호작용할 때 지연을 최소화하여 더 나은 사용자 경험을 제공하는 데 도움이 됩니다.

### 라운드 로빈 (RR) 스케줄링

- **응답 시간 최적화**:
    
    - 준비 상태인 프로세스를 고정된 길이의 시간 조각(time slice)마다 번갈아 가면서 실행합니다.
    - 이 방법은 응답성을 향상시키지만, 동일한 길이의 작업에 대해서는 반환 시간을 증가시킬 수 있습니다.
- **각 프로세스는 작은 단위의 CPU 시간(시간 할당량, 보통 10-100 밀리초)을 받습니다**:
    
    - 이 시간이 경과하면 프로세스는 선점되고 준비 큐의 끝에 추가됩니다.
    - RR은 공정하지만, 반환 시간과 같은 메트릭에서 성능이 좋지 않습니다.
    - 평균 대기 시간은 종종 매우 길어질 수 있습니다.
- **시간 조각의 길이에 따른 효과**:
    
    - **짧은 시간 조각**:
        - 응답 시간이 개선됩니다.
        - 컨텍스트 스위칭의 비용이 전체 성능을 지배할 수 있습니다.
    - **긴 시간 조각**:
        - 컨텍스트 스위칭 비용을 분산시킵니다.
        - 응답 시간이 나빠질 수 있습니다.
- **성능**:
    
    - **큰 q (시간 할당량)** → FIFO(선입선출)와 유사하게 동작합니다.
    - **작은 q** → q는 컨텍스트 스위치에 비해 충분히 커야 하며, 그렇지 않으면 오버헤드가 너무 높아집니다.
- **시간 조각 길이 결정**:
    
    - 시스템 디자이너에게 시간 조각의 길이를 결정하는 것은 트레이드오프를 제시합니다.

라운드 로빈 방식은 프로세스 간에 CPU 시간을 공정하게 분배하려는 목적으로 널리 사용되지만, 작업의 특성과 시스템 요구 사항에 따라 적절한 시간 조각의 길이를 선택하는 것이 중요합니다.

### I/O 통합 예시

- **예시 상황**:
    
    - A와 B가 각각 50ms의 CPU 시간이 필요합니다.
    - A는 10ms 동안 실행된 후 I/O 요청을 합니다.
        - 각 I/O는 10ms가 걸립니다.
    - B는 단순히 CPU를 50ms 동안 사용하고 I/O를 수행하지 않습니다.
    - 스케줄러는 먼저 A를 실행한 다음 B를 실행합니다.
- **작업이 I/O 요청을 시작할 때**:
    
    - 작업은 I/O 완료를 기다리며 차단(blocked) 상태가 됩니다.
    - 스케줄러는 CPU에서 다른 작업을 스케줄해야 합니다.
- **I/O가 완료될 때**:
    
    - 인터럽트가 발생합니다.
    - 운영 시스템은 프로세스를 차단 상태에서 다시 준비 상태로 이동시킵니다.

이러한 과정을 통해 I/O 작업이 필요한 경우에도 CPU의 효율적인 활용이 가능하며, 다른 작업으로의 빠른 전환을 통해 전체 시스템의 성능을 유지할 수 있습니다. I/O 처리 방식은 시스템의 반응성과 효율성을 크게 좌우하는 중요한 요소입니다.

### 고급 스케줄링 목표

- **목적**: 범용 스케줄링
- **도전 과제**: 스케줄러는 장시간 실행되는 배경 작업(배치 프로세스)과 낮은 지연 시간이 필요한 전경 작업(대화형 프로세스) 모두를 지원해야 합니다.
    - **배치 프로세스**: 응답 시간이 중요하지 않으며, 장시간 실행됩니다. 컨텍스트 스위치의 비용을 줄이고, 많은 CPU 시간을 필요로 하지만, 언제 필요한지는 중요하지 않습니다.
    - **대화형 프로세스**: 응답 시간이 매우 중요하며, 짧은 실행 시간을 가집니다. 컨텍스트 스위칭 비용은 중요하지 않으며, 많은 CPU 시간이 필요하지는 않지만 자주 필요합니다.

### 다단계 큐

- **준비 큐는 별도의 큐로 분할됩니다**:
    - 전경(대화형)
    - 배경(배치)
- **각 큐는 자체 스케줄링 알고리즘을 가지고 있습니다**:
    - 전경 큐는 라운드 로빈(RR) 알고리즘을 사용합니다.
    - 배경 큐는 선입선출(FCFS) 알고리즘을 사용합니다.
- **큐 간의 스케줄링이 필요합니다**:
    - **고정 우선순위 스케줄링**: 전경 작업을 모두 처리한 다음 배경 작업을 처리합니다. 이는 기아 상태의 가능성을 내포하고 있습니다.
    - **시간 조각**: 각 큐는 CPU 시간의 일정 비율을 할당받아 자체 프로세스 간에 스케줄할 수 있습니다.
        - 전경에는 80%를 라운드 로빈 방식으로,
        - 배경에는 20%를 선입선출 방식으로 할당합니다.

이러한 고급 스케줄링 접근 방식은 다양한 유형의 작업에 맞추어 시스템의 자원을 효율적으로 분배하고 관리하려는 노력의 일환입니다. 다단계 큐를 통한 스케줄링은 각 작업의 특성에 맞는 처리 방식을 제공하여 시스템 성능을 최적화하고 사용자 경험을 개선할 수 있습니다.

### 멀티프로세서 스케줄링

- **멀티코어 프로세서의 등장**:
    
    - 멀티코어: 여러 CPU 코어가 단일 칩에 패키징됩니다.
- **CPU 추가는 단일 애플리케이션을 더 빠르게 실행시키지 않음**:
    
    - 애플리케이션을 병렬로 실행할 수 있도록 다시 작성해야 하며, 이때 스레드를 사용합니다.
- **여러 CPU가 사용 가능할 때 CPU 스케줄링이 더 복잡해짐**:
    
    - 여러 프로세서에 작업을 할당하고 관리하는 것이 단일 프로세서 시스템보다 복잡합니다.

### 다중 프로세서 스케줄링

- **부하 공유**:
    
    - 프로세스가 특정 프로세서에 할당되지 않습니다.
    - 부하는 프로세서들 사이에 고르게 분배됩니다.
    - 어떤 프로세서도 유휴 상태로 남지 않도록 보장합니다.
    - 전역 큐를 사용합니다.
- **단점**:
    
    - 중앙 큐는 상호 배타적 접근이 필요하며, 여러 프로세서가 동시에 작업을 찾을 때 병목 현상이 발생할 수 있습니다.
    - 선점형 스레드는 같은 프로세서에서 실행을 재개할 가능성이 낮으며, 이는 캐시 사용의 효율성이 떨어질 수 있습니다.
    - 모든 스레드가 전역 큐에 있을 경우, 하나의 프로그램의 모든 스레드가 동시에 프로세서에 접근하지 못할 수 있습니다.

이러한 멀티프로세서 스케줄링 방식은 시스템의 자원을 최대한 활용하려는 목적을 가지고 있으며, 부하 분산 및 효율적인 작업 처리를 위해 여러 전략을 사용합니다.