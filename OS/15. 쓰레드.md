### 스레드: 실행 컨텍스트

- **스레드는 독립적인 실행 컨텍스트입니다**
    - 프로세스와 유사하지만 동일한 주소 공간을 공유합니다.
- **왜 스레드가 필요한가요?**
    - CPU는 매우 빠르게 동작하지만, 데이터를 가져오는 동안 차단될 수 있습니다.
    - 병렬 작업을 수행할 수 있는 여러 CPU가 사용 가능합니다.
- **멀티 스레드 프로그램**
    - 멀티 스레드 프로그램은 둘 이상의 실행 지점을 가집니다.
    - 여러 개의 프로그램 카운터(PCs)가 있으며, 동일한 주소 공간을 공유합니다.

### 스레드: 실행 컨텍스트

- **각 스레드는 자신만의 프로그램 카운터와 레지스터 세트를 가지고 있습니다**.
    - 각 스레드의 상태를 저장하는 하나 이상의 스레드 제어 블록(TCBs)이 필요합니다.
- **한 스레드(T1)에서 다른 스레드(T2)로 전환할 때**,
    - T1의 레지스터 상태는 저장됩니다.
    - T2의 레지스터 상태는 복원됩니다.
    - 주소 공간은 동일하게 유지됩니다.
- **이점**
    - 반응성, 자원 공유, 경제성 (프로세스 생성 비용), 확장성 (멀티프로세서 아키텍처 활용)
- **일반적인 용어**
    - 스레드 생성(및 종료)이 프로세스보다 시간이 적게 걸립니다.
    - 동일한 프로세스 내 두 스레드 간 전환하는 데 시간이 적게 걸립니다.
    - 동일한 프로세스 내의 스레드는 메모리와 파일을 공유하기 때문에, 커널을 호출하지 않고 서로 통신할 수 있습니다.

### 관련 스레드의 스택

- **스레드마다 하나의 스택이 있습니다**.
![[Pasted image 20240421180718.png]]

### 병렬성과 동시성

- **병렬성(Parallelism)**: 단일 작업에 대해 여러 스레드(또는 프로세스)가 여러 CPU 코어를 사용하여 작업을 수행합니다.
- **동시성(Concurrency)**: 작업이 겹치는 시간 동안 시작, 실행 및 완료될 수 있습니다. 예를 들어, 실행을 교차하여 시간 다중화를 통해 또는 동시에 실행될 때 병렬성을 통해 수행됩니다.

### 생산자-소비자 문제 (동시 프로그램)

- **공유 메모리를 사용한 유계 버퍼 문제 해결책은 한 번에 최대 n – 1개의 항목을 버퍼에 허용합니다**.
- **생산자-소비자 문제에 대한 해결책을 제공하고자 합니다. 이 문제는 모든 버퍼를 채우기를 원합니다**.
    - 이를 위해 처음에는 0으로 설정된 버퍼의 수를 추적하는 정수 카운트를 사용할 수 있습니다.
    - 생산자가 새로운 버퍼를 생산한 후에는 카운트를 증가시키고, 소비자가 버퍼를 소비한 후에는 카운트를 감소시킵니다.


###   임계 구역 문제

- **n개의 프로세스가 공유 데이터를 사용하기 위해 경쟁합니다**.
- **각 프로세스는 공유 데이터에 접근하는 코드 부분인 임계 구역을 가지고 있습니다**.
- **문제점** – 한 프로세스가 임계 구역에서 실행 중일 때, 다른 프로세스가 그들의 임계 구역에서 실행되는 것을 허용하지 않아야 합니다.
- **프로세스 Pi의 구조**:
    
    plaintextCopy code
    
    `do {   입장 구역   임계 구역   퇴장 구역   나머지 구역 } while (true);`
    

### 임계 구역 문제에 대한 해결책

- **다음 요구 사항을 충족해야 합니다**:
    1. **상호 배제**: 프로세스 Pi가 임계 구역에서 실행 중이면, 다른 프로세스는 그들의 임계 구역에서 실행될 수 없습니다.
    2. **진행**: 임계 구역에서 실행 중인 프로세스가 없고 임계 구역에 들어가고자 하는 프로세스가 있는 경우, 나머지 구역에서 실행 중이지 않은 프로세스만이 다음에 임계 구역에 들어갈 프로세스를 결정하는 데 참여할 수 있으며, 이 선택은 무기한 연기될 수 없습니다.
    3. **유계 대기**: 프로세스가 임계 구역에 들어가기 위해 요청한 후 그 요청이 허용되기 전에 다른 프로세스가 그들의 임계 구역에 들어가는 횟수에 한계가 있어야 합니다.

### 피터슨의 해결책

- **피터슨의 해결책은 단 두 프로세스, P0과 P1을 위한 것입니다**:
    - LOAD 및 STORE 명령이 원자적이라고 가정합니다; 즉, 중단될 수 없습니다.
    - 두 프로세스는 두 변수를 공유합니다:
        - `int turn;`
        - `Boolean flag[2];`
    - `turn` 변수는 임계 구역에 들어갈 차례가 누구인지를 나타냅니다.
    - `flag` 배열은 프로세스가 임계 구역에 들어갈 준비가 되었는지를 나타냅니다.
        - `flag[i] = true`는 프로세스 Pi가 준비되었다는 것을 의미합니다!

### 프로세스 Pi의 작동
![[Pasted image 20240421181004.png]]


### 피터슨의 알고리즘
![[Pasted image 20240421180947.png]]`
- **상호 배제**:
    - Pi가 임계 구역에 들어가는 것은 flag[j] == false 이거나 turn == i 일 때만 가능합니다.
- **진행 및 유계 대기**:
    - Pj가 준비되지 않았다면 (flag[j] = false), Pi가 임계 구역에 들어갑니다.
    - Pj가 flag[j] = true를 설정하고 while 루프를 실행 중이면, turn = i일 때 Pi가, turn = j일 때 Pj가 임계 구역에 들어갑니다.
    - Pj가 flag[j] = false로 설정한 후 Pi가 임계 구역에 들어갑니다.
    - Pi가 임계 구역에 들어가기 위해 Pj에 의해 최대 한 번의 진입이 이루어진 후에 진입합니다 (유계 대기).