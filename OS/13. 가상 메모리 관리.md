### 가상 메모리 관리

- **배경**
    
    - 전체 프로그램의 모든 부분이 동시에 필요하지 않을 수 있습니다.
- **가상 메모리**는 사용자의 논리 메모리와 물리 메모리를 분리합니다.
    
    - 실행을 위해 프로그램의 일부만 메모리에 있어야 합니다.
    - 따라서 논리 주소 공간은 물리 주소 공간보다 훨씬 클 수 있습니다.
    - 페이지를 스왑 인(swap in) 및 스왑 아웃(swap out)할 수 있어야 합니다 (디스크).
    - 여러 프로세스가 주소 공간을 공유할 수 있습니다.
    - 더 효율적인 프로세스 생성을 허용합니다.
- **가상 메모리 구현 방법**:
    
    - 수요 페이징(Demand paging)
    - 수요 세그먼테이션(Demand segmentation)

### 스왑 공간

- **스왑 공간의 추가**는 운영 체제가 여러 동시 실행 프로세스에 대한 큰 가상 메모리의 환상을 지원할 수 있게 합니다.
- 디스크에 페이지를 왕복 이동하기 위한 일부 공간을 예약합니다.
- 운영 체제는 페이지 크기 단위로 스왑 공간을 기억해야 합니다.

![[Pasted image 20240421140928.png]]


### 물리 메모리보다 큰 가상 메모리

- **수요 페이징(Demand Paging)**
    - 필요할 때만 페이지를 메모리로 가져옵니다 (지연 스왑핑).
        - 더 적은 I/O가 필요합니다.
        - 더 적은 메모리가 필요합니다.
        - 더 빠른 응답이 가능합니다.
        - 더 많은 사용자를 수용할 수 있습니다.
    - **유효-무효 비트(Valid-invalid bit)**
        - 각 페이지 테이블 항목에 유효-무효 비트가 연관됩니다.
            - 1은 메모리 내, 0은 메모리 외.
        - 초기에 모든 항목의 유효-무효 비트는 0으로 설정됩니다.
        - 주소 변환 동안, 페이지 테이블 항목의 유효-무효 비트가 0이면 페이지 폴트가 발생합니다.
![[Pasted image 20240421141027.png]]
### 페이지 테이블: 일부 페이지가 주 메모리에 없을 때

- **페이지 폴트(Page Fault)**
    - 물리 메모리에 없는 페이지에 접근합니다.
        - 페이지가 현재 없고 디스크에 스왑되었다면, 운영 체제는 페이지 폴트를 처리하기 위해 메모리로 페이지를 스왑해야 합니다.
    - **운영 체제 결정**
        - 잘못된 참조라면 중단합니다.
        - 메모리에 없는 경우 메모리로 가져옵니다.
            - 비어 있는 프레임을 찾습니다.
            - 페이지를 프레임으로 스왑합니다.
            - 테이블을 재설정하고, 유효 비트를 1로 설정합니다.
            - 명령을 재시작합니다
### 물리 메모리보다 큰 가상 메모리
![[Pasted image 20240421141520.png]]
- **수요 페이징(Demand Paging)**
    - 필요할 때만 페이지를 메모리로 가져옵니다 (지연 스왑핑).
        - 더 적은 I/O가 필요합니다.
        - 더 적은 메모리가 필요합니다.
        - 더 빠른 응답이 가능합니다.
        - 더 많은 사용자를 수용할 수 있습니다.
    - **유효-무효 비트(Valid-invalid bit)**
        - 각 페이지 테이블 항목에 유효-무효 비트가 연관됩니다.
            - 1은 메모리 내, 0은 메모리 외.
        - 초기에 모든 항목의 유효-무효 비트는 0으로 설정됩니다.
        - 주소 변환 동안, 페이지 테이블 항목의 유효-무효 비트가 0이면 페이지 폴트가 발생합니다.

### 페이지 테이블: 일부 페이지가 주 메모리에 없을 때

- **페이지 폴트(Page Fault)**
    - 물리 메모리에 없는 페이지에 접근합니다.
        - 페이지가 현재 없고 디스크에 스왑되었다면, 운영 체제는 페이지 폴트를 처리하기 위해 메모리로 페이지를 스왑해야 합니다.
    - **운영 체제 결정**
        - 잘못된 참조라면 중단합니다.
        - 메모리에 없는 경우 메모리로 가져옵니다.
            - 비어 있는 프레임을 찾습니다.
            - 페이지를 프레임으로 스왑합니다.
            - 테이블을 재설정하고, 유효 비트를 1로 설정합니다.
            - 명령을 재시작합니다
![[Pasted image 20240421141539.png]]


### 페이지 교체

- **자유 프레임이 없을 때의 OS 작업**
    
    - 새 페이지를 위해 운영체제(OS)가 메모리에 공간을 만듭니다.
    - 메모리 압박으로 인해 OS는 활성 사용 페이지를 위해 다른 페이지를 스왑 아웃(페이징 아웃)하여 공간을 확보하기 시작합니다.
    - 어떤 페이지를 제거할지 결정하는 것은 OS의 교체 정책(replacement policy) 내에 포함됩니다.
- **페이지 교체**
    
    - 메모리에서 실제로 사용되지 않는 페이지를 찾아 스왑 아웃합니다.
    - 최소한의 페이지 폴트가 발생하는 알고리즘을 원합니다.
    - 동일한 페이지가 여러 번 메모리로 가져와질 수 있습니다.
    - 교체 정책을 선택할 때의 목표는 캐시 미스의 수를 최소화하는 것입니다 (메모리 – 디스크: 메모리는 디스크의 캐시입니다).
- **평균 메모리 접근 시간 (AMAT) 계산**
    
    - AMAT = PHit * TM + (PMiss * TD)
        - TM: 메모리 접근 비용
        - TD: 디스크 접근 비용
        - PHit: 캐시에서 데이터 항목을 찾을 확률(적중)
        - PMiss: 캐시에서 데이터를 찾지 못할 확률(미스)

### 페이지 교체 절차

1. 디스크에서 원하는 페이지의 위치를 찾습니다.
2. 자유 프레임을 찾습니다.
    - 자유 프레임이 있다면 사용합니다.
    - 그렇지 않다면 페이지 교체 알고리즘을 사용하여 희생될 프레임을 선택합니다.
    - 희생될 페이지를 디스크로 기록하고, 페이지 및 프레임 테이블을 변경합니다.
3. 원하는 페이지를 (새로운) 자유 프레임으로 읽어 들이고, 페이지 및 프레임 테이블을 변경합니다.
4. 사용자 프로세스를 재시작합니다.

- **수정(더티) 비트 사용**
    
    - 페이지 전송의 오버헤드를 줄이기 위해 수정된 페이지만 디스크로 기록합니다.
- **페이지 교체는 논리적 메모리와 물리적 메모리 사이의 분리를 완성합니다**
    
    - 더 작은 물리 메모리에서 큰 가상 메모리를 제공할 수 있습니다. (수요 페이징)

### 최적 교체 정책

- 전체적으로 가장 적은 수의 미스를 초래하는 교체 정책입니다.
    - 미래에 가장 늦게 접근될 페이지를 교체합니다.
    - 가능한 가장 적은 캐시 미스가 발생합니다.
- 완벽에 가까운 정도를 알기 위한 비교점으로만 사용됩니다.
- 우리는 3페이지 캐시를 가지고 있습니다.

### 간단한 정책: FIFO (First-In-First-Out)

- **교체 발생 시**, 큐의 끝(“처음 들어온” 페이지)에 있는 페이지가 제거됩니다.
    - 구현하기는 간단하지만, 블록의 중요성을 결정할 수는 없습니다.

#### 참조 열 및 결과 캐시 상태

- 참조 열: 0 1 2 0 1 3 0 3 1 2 1
- 접근 결과 및 캐시 상태:
    - 0: 미스 → 0
    - 1: 미스 → 0,1
    - 2: 미스 → 0,1,2
    - 0: 히트 → 0,1,2
    - 1: 히트 → 0,1,2
    - 3: 미스 → 1,2,3 (0이 제거됨)
    - 0: 미스 → 2,3,0 (1이 제거됨)
    - 3: 히트 → 2,3,0
    - 1: 미스 → 3,0,1 (2가 제거됨)
    - 2: 미스 → 0,1,2 (3이 제거됨)
    - 1: 히트 → 0,1,2
- 히트율: 36.4%

#### BELADY의 이상현상

- 캐시가 커질수록 캐시 히트율이 증가할 것으로 기대하지만, FIFO의 경우에는 더 나빠집니다.
    - 더 많은 프레임 → 페이지 폴트 감소

### 또 다른 간단한 정책: 랜덤

- **메모리 압박 하에 임의의 페이지를 교체**합니다.
    - 어떤 블록을 제거할지 지능적으로 선택하려고 하지는 않습니다.
    - 랜덤의 선택이 얼마나 운 좋게 이루어지는지에 전적으로 달려 있습니다.
- 때로는 최적만큼 좋은 결과를 달성하여 예제 추적에서 6번의 히트를 기록하기도 합니다.

### 이력을 사용하는 정책

- **이력 정보 두 가지 유형**:
    - **최근성**: 페이지가 최근에 접근되었다면 다시 접근될 가능성이 높습니다 → LRU (Least-Recently-Used)
    - **빈도**:
        - 페이지가 여러 번 접근되었다면, 분명히 어떤 가치가 있으므로 교체되어서는 안 됩니다 → LFU (Least-Frequently-Used); 가장 적은 횟수
        - 페이지가 여러 번 접근되었다면 교체되어야 합니다 → MFU (Most-Frequently-Used); 가장 많은 횟수




### 무-지역성 워크로드

- **참조는 접근된 페이지 세트 내에서 임의의 페이지로 이루어집니다**.
    - 워크로드는 시간이 지남에 따라 100개의 고유 페이지에 접근합니다.
    - 다음에 참조할 페이지를 무작위로 선택합니다.
- **캐시가 전체 워크로드를 수용할 만큼 충분히 클 때**,
    - 사용하는 정책이 무엇이든 중요하지 않습니다.
![[Pasted image 20240421175533.png]]
### 80-20 워크로드

- **지역성을 보여줍니다**: 참조의 80%가 페이지의 20%에서 이루어집니다.
- **나머지 20%의 참조는 남은 80%의 페이지에서 이루어집니다**.
- **LRU는 더 자주 참조되는 '핫' 페이지를 보유할 가능성이 더 높습니다**.

### 순차적 루프 워크로드

- **50개의 페이지를 순차적으로 참조합니다**.
    - 0부터 시작하여 1, ... , 49 페이지까지 이동한 다음 루프를 시작하며, 총 10,000번의 접근으로 50개의 고유 페이지를 반복 참조합니다.

### 클록 알고리즘을 사용한 워크로드

- **클록 알고리즘은 완벽한 LRU만큼 잘 수행되지는 않지만, 이력을 전혀 고려하지 않는 접근 방식보다는 더 나은 성능을 보입니다**.


