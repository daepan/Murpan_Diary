### 가상 메모리 관리

- **배경**
    
    - 전체 프로그램의 모든 부분이 동시에 필요하지 않을 수 있습니다.
- **가상 메모리**는 사용자의 논리 메모리와 물리 메모리를 분리합니다.
    
    - 실행을 위해 프로그램의 일부만 메모리에 있어야 합니다.
    - 따라서 논리 주소 공간은 물리 주소 공간보다 훨씬 클 수 있습니다.
    - 페이지를 스왑 인(swap in) 및 스왑 아웃(swap out)할 수 있어야 합니다 (디스크).
    - 여러 프로세스가 주소 공간을 공유할 수 있습니다.
    - 더 효율적인 프로세스 생성을 허용합니다.
- **가상 메모리 구현 방법**:
    
    - 수요 페이징(Demand paging)
    - 수요 세그먼테이션(Demand segmentation)

### 스왑 공간

- **스왑 공간의 추가**는 운영 체제가 여러 동시 실행 프로세스에 대한 큰 가상 메모리의 환상을 지원할 수 있게 합니다.
- 디스크에 페이지를 왕복 이동하기 위한 일부 공간을 예약합니다.
- 운영 체제는 페이지 크기 단위로 스왑 공간을 기억해야 합니다.

![[Pasted image 20240421140928.png]]


### 물리 메모리보다 큰 가상 메모리

- **수요 페이징(Demand Paging)**
    - 필요할 때만 페이지를 메모리로 가져옵니다 (지연 스왑핑).
        - 더 적은 I/O가 필요합니다.
        - 더 적은 메모리가 필요합니다.
        - 더 빠른 응답이 가능합니다.
        - 더 많은 사용자를 수용할 수 있습니다.
    - **유효-무효 비트(Valid-invalid bit)**
        - 각 페이지 테이블 항목에 유효-무효 비트가 연관됩니다.
            - 1은 메모리 내, 0은 메모리 외.
        - 초기에 모든 항목의 유효-무효 비트는 0으로 설정됩니다.
        - 주소 변환 동안, 페이지 테이블 항목의 유효-무효 비트가 0이면 페이지 폴트가 발생합니다.
![[Pasted image 20240421141027.png]]
### 페이지 테이블: 일부 페이지가 주 메모리에 없을 때

- **페이지 폴트(Page Fault)**
    - 물리 메모리에 없는 페이지에 접근합니다.
        - 페이지가 현재 없고 디스크에 스왑되었다면, 운영 체제는 페이지 폴트를 처리하기 위해 메모리로 페이지를 스왑해야 합니다.
    - **운영 체제 결정**
        - 잘못된 참조라면 중단합니다.
        - 메모리에 없는 경우 메모리로 가져옵니다.
            - 비어 있는 프레임을 찾습니다.
            - 페이지를 프레임으로 스왑합니다.
            - 테이블을 재설정하고, 유효 비트를 1로 설정합니다.
            - 명령을 재시작합니다
### 물리 메모리보다 큰 가상 메모리
![[Pasted image 20240421141520.png]]
- **수요 페이징(Demand Paging)**
    - 필요할 때만 페이지를 메모리로 가져옵니다 (지연 스왑핑).
        - 더 적은 I/O가 필요합니다.
        - 더 적은 메모리가 필요합니다.
        - 더 빠른 응답이 가능합니다.
        - 더 많은 사용자를 수용할 수 있습니다.
    - **유효-무효 비트(Valid-invalid bit)**
        - 각 페이지 테이블 항목에 유효-무효 비트가 연관됩니다.
            - 1은 메모리 내, 0은 메모리 외.
        - 초기에 모든 항목의 유효-무효 비트는 0으로 설정됩니다.
        - 주소 변환 동안, 페이지 테이블 항목의 유효-무효 비트가 0이면 페이지 폴트가 발생합니다.

### 페이지 테이블: 일부 페이지가 주 메모리에 없을 때

- **페이지 폴트(Page Fault)**
    - 물리 메모리에 없는 페이지에 접근합니다.
        - 페이지가 현재 없고 디스크에 스왑되었다면, 운영 체제는 페이지 폴트를 처리하기 위해 메모리로 페이지를 스왑해야 합니다.
    - **운영 체제 결정**
        - 잘못된 참조라면 중단합니다.
        - 메모리에 없는 경우 메모리로 가져옵니다.
            - 비어 있는 프레임을 찾습니다.
            - 페이지를 프레임으로 스왑합니다.
            - 테이블을 재설정하고, 유효 비트를 1로 설정합니다.
            - 명령을 재시작합니다
![[Pasted image 20240421141539.png]]


### 페이지 교체

- **자유 프레임이 없을 때의 OS 작업**
    
    - 새 페이지를 위해 운영체제(OS)가 메모리에 공간을 만듭니다.
    - 메모리 압박으로 인해 OS는 활성 사용 페이지를 위해 다른 페이지를 스왑 아웃(페이징 아웃)하여 공간을 확보하기 시작합니다.
    - 어떤 페이지를 제거할지 결정하는 것은 OS의 교체 정책(replacement policy) 내에 포함됩니다.
- **페이지 교체**
    
    - 메모리에서 실제로 사용되지 않는 페이지를 찾아 스왑 아웃합니다.
    - 최소한의 페이지 폴트가 발생하는 알고리즘을 원합니다.
    - 동일한 페이지가 여러 번 메모리로 가져와질 수 있습니다.
    - 교체 정책을 선택할 때의 목표는 캐시 미스의 수를 최소화하는 것입니다 (메모리 – 디스크: 메모리는 디스크의 캐시입니다).
- **평균 메모리 접근 시간 (AMAT) 계산**
    
    - AMAT = PHit * TM + (PMiss * TD)
        - TM: 메모리 접근 비용
        - TD: 디스크 접근 비용
        - PHit: 캐시에서 데이터 항목을 찾을 확률(적중)
        - PMiss: 캐시에서 데이터를 찾지 못할 확률(미스)

### 페이지 교체 절차

1. 디스크에서 원하는 페이지의 위치를 찾습니다.
2. 자유 프레임을 찾습니다.
    - 자유 프레임이 있다면 사용합니다.
    - 그렇지 않다면 페이지 교체 알고리즘을 사용하여 희생될 프레임을 선택합니다.
    - 희생될 페이지를 디스크로 기록하고, 페이지 및 프레임 테이블을 변경합니다.
3. 원하는 페이지를 (새로운) 자유 프레임으로 읽어 들이고, 페이지 및 프레임 테이블을 변경합니다.
4. 사용자 프로세스를 재시작합니다.

- **수정(더티) 비트 사용**
    
    - 페이지 전송의 오버헤드를 줄이기 위해 수정된 페이지만 디스크로 기록합니다.
- **페이지 교체는 논리적 메모리와 물리적 메모리 사이의 분리를 완성합니다**
    
    - 더 작은 물리 메모리에서 큰 가상 메모리를 제공할 수 있습니다. (수요 페이징)

### 최적 교체 정책

- 전체적으로 가장 적은 수의 미스를 초래하는 교체 정책입니다.
    - 미래에 가장 늦게 접근될 페이지를 교체합니다.
    - 가능한 가장 적은 캐시 미스가 발생합니다.
- 완벽에 가까운 정도를 알기 위한 비교점으로만 사용됩니다.
- 우리는 3페이지 캐시를 가지고 있습니다.