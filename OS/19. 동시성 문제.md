운영체제에서 트랜잭션과 동시성 관리는 중요하다.

## 트랜잭션

* 단일 논리 작업 단위를 수행하는 명령어 또는 연산의 집합
* 이 연산 과정에 있어서 원자성을 보장해야한다.
* 일련의 읽기와 쓰기 연산을 구성 됨
* 성공적으로 완료시 커밋하고, 실패 시 롤백되어 모든 변경사항을 취소한다.

### 트랜잭션 복구

1. 로그 기반 복구 (Log based recovery)
	* 트랜잭션이 수행한 모든 수정사항을 기록하는 로그를 안정 저장소에 저장한다.
	* 일반적으로 사용하는 방식은 사전 기록이다.
2. 체크포인트
	* 로그가 길어지면 복구가 길어진다는 단점이 있어, 이를 줄이기 위해 주기적인 체크 포인트를 설정한다.
	* 체크 포인트를 통해 마지막 체크 포인트 이후에 시작된 트랜잭션만 복구한다.
3. 동시 원자 트랜잭션 (Concurrent Atomic Transactions)
	* 동시 실행되는 트랜잭션은 어떤 순서로든 직렬로 실행되는 것과 동일해야한다.
	* 베른 스타인 조건을 만족해야합니다.
	* 이를 위해 Locking Protocol 이나 타임스탬프 기반 프로토콜을 사용한다.


>베른스타인 조건은 병렬 프로그래밍에서 중요한 개념입니다. 이 조건은 여러 프로세스가 동시에 실행될 때 서로 간섭하지 않고 안전하게 실행될 수 있는지를 판단합니다. 이를 위해 다음 세 가지 조건을 충족해야 합니다:
>1. **읽기-쓰기 조건 (Read-Write Condition)**: 어떤 프로세스가 다른 프로세스의 쓰기 연산을 읽지 않아야 합니다.
>2. **쓰기-읽기 조건 (Write-Read Condition)**: 어떤 프로세스가 다른 프로세스의 읽기 연산에 쓰지 않아야 합니다.
>3. **쓰기-쓰기 조건 (Write-Write Condition)**: 두 프로세스가 같은 데이터를 동시에 쓰지 않아야 합니다.
>이 조건들을 만족시키기 위해 잠금 프로토콜(Locking Protocol)이나 타임스탬프 기반 프로토콜(Timestamp-Based Protocol)을 사용할 수 있습니다.

## 동시성 문제와 해결 방안

1. 동시성 문제
	* 원자성 버그: 동시 실행시 원하는 직렬화 순서가 깨질 수 있습니다.
	* 순서 위반 버그: 메모리 접근 순서가 바뀌어야할 때 발생합니다.
	* 교착 상태(Dead Lock): 두 개 이상의 프로세스가 서로 자원을 기다리며 멈추는 상태입니다.
2.  해결 방안
	* 잠금 사용: 공유 변수에 대한 접근을 잠금으로 보호합니다.
	* 조건 변수 사용: 특정 조건이 충족될 떄까지 스레드를 대기시킵니다.
	* 데드락 방지: 자원 요청 순서를 정하거나, 교착 상태를 피하기 위한 스케줄링 사용합니다.

## 교착 상태 해결 방안

교착 상태란 두 스레드가 서로가 소유한 잠금을 기다리는 상황을 피하기 위해 자원 요청 순서를 정하거나, 스케줄링을 통해 교착 상태를 방지합니다.

1. 교착 상태 방지
	* 상호 배제(Mutual Exclusion) : 자원을 공유하지 않거나, 공유 자원에 대해 잠금을 사용하여 방지합니다.
	* 대기 및 보유(Hold and Wait) : 프로세스가 자원을 요청할 때 다른 자원을 보유하지 않도록 합니다.
	* 비선점(No Preemption) : 프로세스가 자원을 선점하지 않도록 합니다.
	* 순환 대기(Circular Wait) : 자원 요청 순서를 정하여 순환 대기를 방지합니다.

2. 교착 상태 회피    
    - 시스템이 안전 상태를 유지하도록 자원 할당을 동적으로 관리합니다.
    - 은행가 알고리즘(Banker’s Algorithm)을 사용하여 시스템이 교착 상태에 빠지지 않도록 합니다.

3. 교착 상태 탐지와 회복
    - 주기적으로 시스템 상태를 검사하여 교착 상태를 탐지합니다.
    - 교착 상태가 발생하면 프로세스를 중단하거나 자원을 회수하여 회복합니다.

## Banker's 알고리즘

## 데드락 방지

## Safety Algorithm

## 이벤트 기반 동시성 처리
async 사용
## 