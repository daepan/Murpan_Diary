### 분리 리스트 (Segregated List)

- **분리 리스트**:
    - 인기 있는 요청 크기에 따라 다른 크기의 자유 청크를 별도의 리스트로 유지합니다.
    - **새로운 문제**:
        - 특정 크기의 요청을 전문적으로 처리하는 메모리 풀에 얼마나 많은 메모리를 할애해야 할까요?
    - 이 문제는 슬랩 할당자가 처리합니다.

### 슬랩 할당자 (Slab Allocator)

- **객체 캐시 수를 할당합니다**.
    - 이 객체들은 자주 요청될 가능성이 높습니다.
    - 예를 들어, 락(lock), 파일 시스템의 아이노드(inode) 등입니다.

### 메모리 추상화

메모리 추상화의 복잡성을 나타내는 일곱 가지 계층:

1. **가상화 없음**, 프로그램이 베어 메탈에서 실행
2. **시간 공유**, 한 번에 하나의 프로그램
3. **공간 공유**, 하나의 공유 주소 공간에서 프로그램 재배치
4. **공간 공유**, 세그먼트(기저)를 통한 가상 주소 공간
5. **공간 공유**, 세그먼트(기저+한계)를 통한 가상 주소 공간
6. **공간 공유**, 여러 세그먼트를 통한 가상 주소 공간
7. **공간 공유**, 페이징을 통한 가상 주소 공간

### 세그먼테이션의 한계

- **세그먼테이션**은 물리 주소 공간을 여러 프로세스간에 합리적으로 공유할 수 있게 해줍니다. 그러나 어떤 단점이 있을까요?
    
    - **공간**: 각 세그먼트는 메모리에 완전히 백업되어야 합니다.
    - **공간**: 물리 메모리 영역은 연속적이어야 합니다 (단편화).
    - **ISA**: 명령어가 명시적으로 또는 암시적으로 대상 세그먼트를 인코딩합니다.
- **단편화**: 사용할 수 없는 메모리.
    
    - **외부 단편화**: 할당자(OS)에게 보이는, 예를 들어 세그먼트 사이에 발생합니다.
    - 예를 들어, 16KiB의 메모리가 있습니다. 프로세스 A는 2,048(2KiB)에서 시작하는 4KiB의 코드 세그먼트, 8,096(8KiB)에서 시작하는 4KiB의 데이터 세그먼트, 그리고 14,336(14KiB)에서 시작하는 1KiB의 스택 세그먼트를 가집니다. 시스템에는 2+2+2+1 = 7 KiB의 자유 메모리가 있지만, 최대 연속 공간은 2 KiB입니다. 3KiB의 코드 세그먼트가 필요한 프로세스 B를 시작하는 것은 불가능합니다.
![[Pasted image 20240421134237.png]]

### 페이징(Paging)

- **페이징**은 주소 공간을 페이지라고 불리는 고정 크기 단위로 나눕니다.
    
    - **세그먼테이션**: 논리 세그먼트(코드, 스택, 힙 등)의 크기가 가변적입니다.
    - **내부 단편화**: 0.5 페이지
- **페이징을 사용하면 물리 메모리도 페이지 프레임이라고 불리는 일정 수의 페이지로 분할됩니다**.
    
    - 크기는 2의 거듭제곱으로, 512바이트에서 8192바이트(1KiB~4KiB) 사이입니다.
- **각 프로세스마다 가상 주소를 물리 주소로 변환하기 위한 페이지 테이블이 필요합니다**.
    

### 페이징의 장점

- **유연성**: 주소 공간의 추상화를 효과적으로 지원합니다.
    - 힙과 스택의 성장 방식 및 사용 방식에 대한 가정이 필요 없습니다.
- **단순성**: 자유 공간 관리의 용이성
    - 주소 공간의 페이지와 페이지 프레임이 동일한 크기입니다.
    - 할당하고 자유 목록을 유지하기 쉽습니다.

![[Pasted image 20240421134255.png]]

### 간단한 페이징 예시

- **128바이트의 물리 메모리와 16바이트 페이지 프레임**
- **64바이트 주소 공간과 16바이트 페이지**
![[Pasted image 20240421134426.png]]
### 주소 변환 방식

- **CPU에 의해 생성된 주소는 다음으로 나누어집니다**:
    
    - **페이지 번호(p)**: 페이지 테이블로의 인덱스로 사용되며, 각 페이지의 물리 메모리 내 기저 주소를 포함합니다.
    - **페이지 오프셋(d)**: 기저 주소와 결합되어 메모리 유닛으로 전송되는 물리 메모리 주소를 정의합니다.
- **주어진 논리 주소 공간 2m과 페이지 크기 2n에 대해**:
    
    - 페이지 번호(p), 페이지 오프셋(d)
    - m - n, n
![[Pasted image 20240421134433.png]]
### 페이징: 장단점

- **장점**:
    
    - **외부 단편화 없음**: 페이지는 고정 크기이므로 외부 단편화 발생하지 않습니다.
    - **할당 및 해제가 빠름**: 공간을 찾기 위한 검색이 없으며, 해제 시 통합이 필요 없습니다.
    - **핵심 매핑을 조정하기 쉬움**: 나중에 매핑된 하위 집합을 조정하기가 간단합니다.
- **단점**:
    
    - **페이지 테이블을 참조하기 위한 추가 메모리 참조 필요** (힌트: 캐시 사용)
    - **내부 단편화**: 페이지 크기에 대한 긴장이 존재합니다.
    - **페이지 테이블에 필요한 공간이 상당할 수 있음**:
        - 예: 32비트 주소 공간에서 4KB 페이지를 사용하는 경우, VPN에 20비트가 필요하며, 페이지 테이블 항목당 4바이트를 곱한 4MB의 크기가 필요합니다.
![[Pasted image 20240421134442.png]]

### 페이지 테이블이란?

- **페이지 테이블**은 가상 주소를 물리 주소로 매핑하는 데 사용되는 데이터 구조입니다(선형 페이지 테이블, 배열 형태).

### 페이지 테이블 항목의 일반적인 플래그

- **유효 비트(Valid Bit)**: 특정 변환의 유효성을 나타냅니다.
- **보호 비트(Protection Bit)**: 페이지가 읽기, 쓰기, 실행이 가능한지를 나타냅니다.
- **현재 비트(Present Bit)**: 해당 페이지가 물리 메모리에 있는지, 아니면 디스크에 스왑되어 있는지를 나타냅니다.
- **더티 비트(Dirty Bit)**: 메모리에 들어온 이후 페이지가 수정되었는지를 나타냅니다.
- **참조 비트(Reference Bit/Accessed Bit)**: 페이지가 접근되었음을 나타냅니다.

### x86 페이지 테이블 항목

- **P(Present)**: 현재, **R/W(Read/Write bit)**: 읽기/쓰기, **U/S(Supervisor)**: 감독자, **A(Accessed bit)**: 접근됨, **D(Dirty bit)**: 더티, **PFN(Page Frame Number)**: 페이지 프레임 번호

### 페이지 테이블의 구현

- **페이지 테이블은 주 메모리에 유지됩니다**.
- **페이지 테이블 기저 레지스터(PTBR)**: 페이지 테이블을 가리킵니다.
- **페이지 테이블 길이 레지스터(PRLR)**: 페이지 테이블의 크기를 나타냅니다.
- **모든 데이터/명령어 접근은 두 번의 메모리 접근을 요구합니다**:
    - 하나는 페이지 테이블을 위한 것이고, 다른 하나는 데이터/명령어를 위한 것입니다. → 속도 저하
- **두 번의 메모리 접근 문제는 특별한 빠른 조회 하드웨어 캐시인 연관 레지스터나 변환 색인 버퍼(TLB: Translation Look-aside Buffers, 8~2048 항목)의 사용으로 해결할 수 있습니다**.

### TLB (Translation Look-aside Buffer)

- **TLB는 칩의 메모리 관리 유닛(MMU)의 일부입니다**.
- **가상 주소에서 물리 주소로의 변환을 저장하는 하드웨어 캐시입니다**.
![[Pasted image 20240421134527.png]]
### TLB를 포함한 페이징 하드웨어

- **페이징 하드웨어는 TLB를 포함하여 효율적인 주소 변환을 지원합니다**.
![[Pasted image 20240421134533.png]]
### 효과적 접근 시간 (Effective Access Time, EAT)

- **연관 조회(Associative Lookup) 시간**: ε 시간 단위
- **메모리 사이클 시간 가정**: 1 마이크로초 (a 시간)
- **히트 비율(Hit ratio)**:
    - 페이지 번호가 연관 레지스터에서 발견되는 횟수의 비율;
    - 연관 레지스터의 수에 관련됨.
    - 히트 비율 = α
- **효과적 접근 시간 (EAT) 계산**:
    - EAT = (1 + ε)α + (2 + ε)(1 – α)
    - = 2 + ε – α
    - (또 다른 형식: EAT = (a + ε)α + (2a + ε)(1 – α) = a(2–α) + ε)
- 예시:
    - ε: 20ns, a: 100ns, α: 80%
    - EAT = 0.8*120 + 0.2*220 = 140ns


### 배열 접근 예시: TLB의 성능 향상 방법

TLB(Translation Look-aside Buffer)는 메모리 접근 시 필요한 주소 변환 정보를 빠르게 제공함으로써 성능을 향상시킬 수 있습니다. 특히 배열과 같은 데이터 구조를 접근할 때 TLB를 통한 빠른 변환은 중요한 역할을 합니다.

### 지역성(Locality)

- **시간적 지역성(Temporal Locality)**:
    - 최근 접근된 명령어나 데이터 항목은 가까운 미래에 다시 접근될 가능성이 높습니다.
![[Pasted image 20240421134656.png]]
- **공간적 지역성(Spatial Locality)**:
    - 프로그램이 x 주소에서 메모리를 접근하면, 곧 x 주변의 메모리를 접근할 가능성이 높습니다.
![[Pasted image 20240421134716.png]]

### TLB 항목

- **TLB는 완전 연관(풀 어소시에이티브) 방식으로 관리됩니다**:
    - 일반적인 TLB는 32, 64, 또는 128개의 항목을 가질 수 있습니다.
    - 하드웨어는 전체 TLB를 동시에 검색하여 원하는 변환을 찾습니다.
- **기타 비트**:
    - 유효 비트(valid bits), 보호 비트(protection bits), 주소 공간 식별자, 더티 비트(dirty bit)
    - 메모리 보호는 각 프레임에 연결된 보호 비트를 통해 구현됩니다 (읽기/쓰기, 읽기 전용).
- **페이지 테이블의 각 항목에는 유효-무효 비트가 부착됩니다**:
    - "유효(valid)"는 관련 페이지가 프로세스의 논리 주소 공간에 있으며, 따라서 합법적인 페이지임을 나타냅니다.
    - "무효(invalid)"는 페이지가 프로세스의 논리 주소 공간에 없음을 나타냅니다.
![[Pasted image 20240421134725.png]]







![[Pasted image 20240421134643.png]]![[Pasted image 20240421134735.png]]
![[Pasted image 20240421134747.png]]

### 또 다른 사례: 두 프로세스가 페이지를 공유

- **프로세스 1이 프로세스 2와 물리 페이지 101을 공유합니다**.
    - P1은 이 페이지를 자신의 주소 공간의 10번째 페이지에 매핑합니다.
    - P2는 이 페이지를 자신의 주소 공간의 50번째 페이지에 매핑합니다.
![[Pasted image 20240421134834.png]]
### 공유 페이지

- **공유 코드**:
    - 읽기 전용(재진입 가능) 코드의 한 복사본이 프로세스 간에 공유됩니다 (예: 텍스트 편집기, 컴파일러, 윈도우 시스템).
    - 공유 코드는 모든 프로세스의 논리 주소 공간에서 같은 위치에 나타나야 합니다.
- **개인 코드와 데이터**:
    - 각 프로세스는 코드와 데이터의 별도 복사본을 유지합니다.
    - 개인 코드와 데이터의 페이지는 논리 주소 공간의 어느 곳에나 나타날 수 있습니다.
![[Pasted image 20240421134842.png]]
### TLB 교체 정책

- **LRU (최근에 가장 적게 사용된)**:
    - 최근에 사용되지 않은 항목을 제거합니다.
    - 메모리 참조 스트림의 지역성을 활용합니다.
![[Pasted image 20240421134928.png]]





### 페이지 테이블 구조

#### 선형 테이블 페이징

- **선형 테이블 페이징**: 전체 가상 주소 공간을 하나의 연속된 페이지 테이블에 매핑합니다.

#### 하이브리드 접근법 (페이징 + 세그먼트)

- **하이브리드 접근법**: 페이징과 세그먼트를 결합하여 각 세그먼트에 대한 별도의 페이지 테이블을 사용합니다. 이는 메모리 사용을 최적화하고 세그먼트 각각의 특성에 맞게 관리할 수 있게 합니다.

#### 계층적 페이징

- **계층적 페이징**: 논리 주소 공간을 여러 페이지 테이블로 분할합니다. 간단한 기술로는 두 단계 페이지 테이블이 있습니다. 이는 주소 공간을 관리하기 위해 두 레벨의 페이지 테이블을 사용하여 메모리 사용의 효율성을 높입니다.

#### 해시 페이지 테이블

- **해시 페이지 테이블**: 가상 주소를 해시하여 해당 페이지의 물리 주소를 찾는 해시 테이블 기반의 접근 방식입니다. 이는 특히 큰 주소 공간을 효율적으로 관리할 때 유용합니다.

#### 역 페이지 테이블

- **역 페이지 테이블**: 전체 물리 메모리를 하나의 페이지 테이블로 매핑하고, 가상 주소에 대한 참조를 역으로 매핑하는 방식입니다. 이는 메모리 오버헤드를 줄이는 데 효과적입니다.

### 페이징: 선형 테이블

- **32비트 주소 공간에 4KB 페이지와 4바이트 페이지 테이블 항목을 가정**.
- **32비트 주소 공간에 16KB 페이지와 4바이트 페이지 테이블 항목을 가정**.
- **페이지 테이블이 너무 커서 너무 많은 메모리를 소비합니다**.
- **큰 페이지는 내부 단편화를 초래합니다**.
- **페이지 테이블의 대부분은 사용되지 않으며, 무효 항목으로 가득 차 있습니다**.

### 하이브리드 접근법: 페이징과 세그먼트

- **페이지 테이블의 메모리 오버헤드를 줄이기 위해**:
    - 기저 주소를 세그먼트 자체를 가리키는 것이 아니라 해당 세그먼트의 페이지 테이블의 물리 주소를 유지하는 데 사용합니다.
    - 경계 레지스터는 페이지 테이블의 끝을 나타내는 데 사용됩니다.
- **각 프로세스는 세 개의 페이지 테이블과 연관되어 있습니다**:
    - 프로세스가 실행 중일 때, 이 세그먼트들 각각의 기저 레지스터에는 해당 세그먼트의 선형 페이지 테이블의 물리 주소가 포함됩니다.
![[Pasted image 20240421135022.png]]
- **하이브리드 접근법도 문제가 없는 것은 아닙니다**:
    - 사용이 적은 큰 힙을 가지고 있어도 여전히 많은 페이지 테이블의 낭비가 발생할 수 있습니다.
    - 외부 단편화가 다시 발생할 수 있습니다.

### 다중 레벨 페이지 테이블

- **선형 페이지 테이블을 나무와 같은 구조로 변환**:
    - 페이지 테이블의 페이지가 유효한지 추적하기 위해, '페이지 디렉토리'라고 불리는 새로운 구조를 사용합니다.

![[Pasted image 20240421135030.png]]
#### 페이지 디렉토리 항목

- **페이지 디렉토리**는 페이지 테이블의 각 페이지에 대한 하나의 항목을 포함합니다.
    - 페이지 디렉토리 항목(PDE)으로 구성됩니다.
    - PDE는 유효 비트와 페이지 프레임 번호(PFN)를 가집니다.

#### 장점

- 사용하는 주소 공간의 양에 비례하여 페이지 테이블 공간만 할당합니다.
- 운영체제는 페이지 테이블을 할당하거나 확장할 필요가 있을 때 다음 자유 페이지를 가져올 수 있습니다.

#### 단점

- 다중 레벨 테이블은 시간-공간 트레이드오프의 작은 예입니다.
- 복잡성이 증가합니다.

#### 간접 참조 수준

- 다중 레벨 구조는 페이지 디렉토리를 사용하여 간접 참조 수준을 조정할 수 있습니다.
    - 간접 참조를 통해 페이지 테이블 페이지를 물리 메모리의 원하는 위치에 배치할 수 있습니다.

### 페이징: 32비트 주소 공간

- 12비트 페이지, 32비트 가상 및 물리 주소 공간, 4바이트 페이지 테이블 항목을 가정할 때:
    - **평면 페이지 테이블의 크기는 얼마입니까?**
    - 페이지 테이블 크기: 항목 수 × 항목 크기
    - 항목 수: 232−12=220=1 MiB232−12=220=1 MiB
    - 페이지 테이블 크기: 1 MiB×4 B=4 MiB1 MiB×4 B=4 MiB
    - 32비트 가상 및 48비트 물리 주소 공간, 8바이트 항목을 가정: 8 MiB
    - 64비트 가상 주소 공간 및 8바이트 항목: 252×8 B(32 PiB)252×8 B(32 PiB). 우리는 더 나은 것이 필요합니다! (거대한 페이지 테이블)

### 페이징: 다중 레벨 테이블

- 각 레벨의 크기는 얼마나 되어야 할까요?
- 아이디어: 32비트 가상/물리에 페이지 그래뉼러리를 사용합니다!
    - 4 KiB 페이지: 1024 × 4 B 항목 (12)
    - 1024 항목은 10비트에 해당합니다 (20 = 32 - 12; 10 = 20 - 10)
    - 주소를 첫 번째 레벨 10비트, 두 번째 레벨 10비트, 오프셋 12비트로 나눕니다.
- 64비트 가상/물리 주소 공간, 4 KiB 페이지로 이동:
    - 4 KiB 페이지는 512 항목(9비트) 공간을 가집니다 (512 × 8 B 항목)
    - 64 - 12 = 52, 즉 6 레벨의 페이지 테이블이 필요합니다 (9 × 6)
- 주소 공간을 48비트로 축소합시다!
    - 48 - 12 = 36, 즉 4 레벨의 페이지 테이블이 필요합니다 (9 × 4)
    - 페이지 워크는 여전히 비용이 많이 들며, 효율성을 위해 높은 TLB 히트율이 필요합니다.
### 이중 레벨 페이징 예시

- **32비트 머신에서 4K 페이지 크기로 구성된 논리적 주소**는 다음과 같이 나뉩니다:
    - 20비트로 구성된 페이지 번호 (백만 개의 항목)
    - 12비트로 구성된 페이지 오프셋
- **페이지 테이블이 페이징되므로 페이지 번호는 더 나뉩니다**:
    - 10비트 페이지 번호
    - 10비트 페이지 오프셋
- **따라서 논리적 주소는 다음과 같이 구성됩니다**:
    - p1은 바깥쪽 페이지 테이블의 인덱스로,
    - p2는 바깥쪽 페이지 테이블의 페이지 내에서의 변위입니다.
![[Pasted image 20240421135254.png]]
![[Pasted image 20240421135246.png]]

### 이중 레벨 페이지 테이블 체계
![[Pasted image 20240421135313.png]]
- **세부적인 다중 레벨 예시**를 통해 다중 레벨 페이지 테이블의 아이디어를 더 잘 이해해 봅시다.
![[Pasted image 20240421135326.png]]
- **페이지 디렉토리**는 페이지 테이블의 각 페이지마다 하나의 항목이 필요합니다:
    - 이는 16개의 항목을 가집니다.
- **페이지 디렉토리 항목이 유효하지 않다면** → 예외를 발생시킵니다 (접근이 유효하지 않음).
![[Pasted image 20240421135344.png]]
- **PDE가 유효하다면, 더 많은 작업을 수행해야 합니다**:
    - 이 페이지 디렉토리 항목이 가리키는 페이지 테이블의 페이지에서 페이지 테이블 항목(PTE)을 가져옵니다.

- **이 페이지 테이블 인덱스는 그 다음 페이지 테이블 자체로 인덱싱하는 데 사용될 수 있습니다**.
![[Pasted image 20240421135356.png]]



### 세부적인 다중 레벨 예시

- **두 레벨 이상의 경우**
    - **페이지 테이블 인덱스**
    - **페이지 디렉토리**
        - 만약 우리의 페이지 디렉토리가 214214개의 항목을 가진다면, 이는 하나의 페이지가 아닌 128페이지에 걸쳐 있습니다.
        - 이 문제를 해결하기 위해, 페이지 디렉토리 자체를 여러 페이지 디렉토리 페이지로 나누어 트리의 추가 레벨을 구축합니다.
![[Pasted image 20240421135442.png]]
### 해시 페이지 테이블

- **32비트 이상의 주소 공간에서 흔히 사용됩니다**.
- **가상 페이지 번호**는 페이지 테이블로 해시됩니다.
    - 이 페이지 테이블은 같은 위치로 해시되는 요소들의 체인을 포함합니다.
- **가상 페이지 번호**들은 이 체인에서 일치하는 항목을 찾기 위해 비교됩니다.
    - 일치하는 항목이 발견되면 해당 물리 프레임이 추출됩니다.
![[Pasted image 20240421135456.png]]
### 클러스터드 페이지 테이블

- **클러스터드 페이지 테이블**: 해시 페이지 테이블과 유사하지만, 해시 테이블의 각 항목이 단일 페이지가 아닌 여러 페이지를 참조합니다.
    - 희소 주소 공간에 유용합니다.

![[Pasted image 20240421135527.png]]



### 역 페이지 테이블

- **각 프로세스는 자신의 페이지 테이블을 가지고 있습니다** -> 큰 메모리 소비.
- **전체 메모리에 대해 단 하나의 페이지 테이블만 유지**:
    - 메모리의 각 실제 페이지마다 한 개의 항목이 있습니다.
- **항목에는 해당 실제 메모리 위치에 저장된 페이지의 가상 주소와 그 페이지를 소유한 프로세스에 대한 정보가 포함됩니다**:
    - 항목은 이 페이지를 사용하는 프로세스와 해당 프로세스의 어떤 가상 페이지가 이 물리 페이지에 매핑되는지를 알려줍니다.
- **각 페이지 테이블을 저장하는 데 필요한 메모리는 감소하지만, 페이지 참조가 발생할 때 테이블을 검색하는 데 필요한 시간은 증가합니다**.
- **검색을 하나 또는 최대 몇 개의 페이지 테이블 항목으로 제한하기 위해 해시 테이블을 사용합니다**.

![[Pasted image 20240421135603.png]]