### 분리 리스트 (Segregated List)

- **분리 리스트**:
    - 인기 있는 요청 크기에 따라 다른 크기의 자유 청크를 별도의 리스트로 유지합니다.
    - **새로운 문제**:
        - 특정 크기의 요청을 전문적으로 처리하는 메모리 풀에 얼마나 많은 메모리를 할애해야 할까요?
    - 이 문제는 슬랩 할당자가 처리합니다.

### 슬랩 할당자 (Slab Allocator)

- **객체 캐시 수를 할당합니다**.
    - 이 객체들은 자주 요청될 가능성이 높습니다.
    - 예를 들어, 락(lock), 파일 시스템의 아이노드(inode) 등입니다.

### 메모리 추상화

메모리 추상화의 복잡성을 나타내는 일곱 가지 계층:

1. **가상화 없음**, 프로그램이 베어 메탈에서 실행
2. **시간 공유**, 한 번에 하나의 프로그램
3. **공간 공유**, 하나의 공유 주소 공간에서 프로그램 재배치
4. **공간 공유**, 세그먼트(기저)를 통한 가상 주소 공간
5. **공간 공유**, 세그먼트(기저+한계)를 통한 가상 주소 공간
6. **공간 공유**, 여러 세그먼트를 통한 가상 주소 공간
7. **공간 공유**, 페이징을 통한 가상 주소 공간

### 세그먼테이션의 한계

- **세그먼테이션**은 물리 주소 공간을 여러 프로세스간에 합리적으로 공유할 수 있게 해줍니다. 그러나 어떤 단점이 있을까요?
    
    - **공간**: 각 세그먼트는 메모리에 완전히 백업되어야 합니다.
    - **공간**: 물리 메모리 영역은 연속적이어야 합니다 (단편화).
    - **ISA**: 명령어가 명시적으로 또는 암시적으로 대상 세그먼트를 인코딩합니다.
- **단편화**: 사용할 수 없는 메모리.
    
    - **외부 단편화**: 할당자(OS)에게 보이는, 예를 들어 세그먼트 사이에 발생합니다.
    - 예를 들어, 16KiB의 메모리가 있습니다. 프로세스 A는 2,048(2KiB)에서 시작하는 4KiB의 코드 세그먼트, 8,096(8KiB)에서 시작하는 4KiB의 데이터 세그먼트, 그리고 14,336(14KiB)에서 시작하는 1KiB의 스택 세그먼트를 가집니다. 시스템에는 2+2+2+1 = 7 KiB의 자유 메모리가 있지만, 최대 연속 공간은 2 KiB입니다. 3KiB의 코드 세그먼트가 필요한 프로세스 B를 시작하는 것은 불가능합니다.
![[Pasted image 20240421134237.png]]

### 페이징(Paging)

- **페이징**은 주소 공간을 페이지라고 불리는 고정 크기 단위로 나눕니다.
    
    - **세그먼테이션**: 논리 세그먼트(코드, 스택, 힙 등)의 크기가 가변적입니다.
    - **내부 단편화**: 0.5 페이지
- **페이징을 사용하면 물리 메모리도 페이지 프레임이라고 불리는 일정 수의 페이지로 분할됩니다**.
    
    - 크기는 2의 거듭제곱으로, 512바이트에서 8192바이트(1KiB~4KiB) 사이입니다.
- **각 프로세스마다 가상 주소를 물리 주소로 변환하기 위한 페이지 테이블이 필요합니다**.
    

### 페이징의 장점

- **유연성**: 주소 공간의 추상화를 효과적으로 지원합니다.
    - 힙과 스택의 성장 방식 및 사용 방식에 대한 가정이 필요 없습니다.
- **단순성**: 자유 공간 관리의 용이성
    - 주소 공간의 페이지와 페이지 프레임이 동일한 크기입니다.
    - 할당하고 자유 목록을 유지하기 쉽습니다.

![[Pasted image 20240421134255.png]]

### 간단한 페이징 예시

- **128바이트의 물리 메모리와 16바이트 페이지 프레임**
- **64바이트 주소 공간과 16바이트 페이지**
![[Pasted image 20240421134426.png]]
### 주소 변환 방식

- **CPU에 의해 생성된 주소는 다음으로 나누어집니다**:
    
    - **페이지 번호(p)**: 페이지 테이블로의 인덱스로 사용되며, 각 페이지의 물리 메모리 내 기저 주소를 포함합니다.
    - **페이지 오프셋(d)**: 기저 주소와 결합되어 메모리 유닛으로 전송되는 물리 메모리 주소를 정의합니다.
- **주어진 논리 주소 공간 2m과 페이지 크기 2n에 대해**:
    
    - 페이지 번호(p), 페이지 오프셋(d)
    - m - n, n
![[Pasted image 20240421134433.png]]
### 페이징: 장단점

- **장점**:
    
    - **외부 단편화 없음**: 페이지는 고정 크기이므로 외부 단편화 발생하지 않습니다.
    - **할당 및 해제가 빠름**: 공간을 찾기 위한 검색이 없으며, 해제 시 통합이 필요 없습니다.
    - **핵심 매핑을 조정하기 쉬움**: 나중에 매핑된 하위 집합을 조정하기가 간단합니다.
- **단점**:
    
    - **페이지 테이블을 참조하기 위한 추가 메모리 참조 필요** (힌트: 캐시 사용)
    - **내부 단편화**: 페이지 크기에 대한 긴장이 존재합니다.
    - **페이지 테이블에 필요한 공간이 상당할 수 있음**:
        - 예: 32비트 주소 공간에서 4KB 페이지를 사용하는 경우, VPN에 20비트가 필요하며, 페이지 테이블 항목당 4바이트를 곱한 4MB의 크기가 필요합니다.
![[Pasted image 20240421134442.png]]

### 페이지 테이블이란?

- **페이지 테이블**은 가상 주소를 물리 주소로 매핑하는 데 사용되는 데이터 구조입니다(선형 페이지 테이블, 배열 형태).

### 페이지 테이블 항목의 일반적인 플래그

- **유효 비트(Valid Bit)**: 특정 변환의 유효성을 나타냅니다.
- **보호 비트(Protection Bit)**: 페이지가 읽기, 쓰기, 실행이 가능한지를 나타냅니다.
- **현재 비트(Present Bit)**: 해당 페이지가 물리 메모리에 있는지, 아니면 디스크에 스왑되어 있는지를 나타냅니다.
- **더티 비트(Dirty Bit)**: 메모리에 들어온 이후 페이지가 수정되었는지를 나타냅니다.
- **참조 비트(Reference Bit/Accessed Bit)**: 페이지가 접근되었음을 나타냅니다.

### x86 페이지 테이블 항목

- **P(Present)**: 현재, **R/W(Read/Write bit)**: 읽기/쓰기, **U/S(Supervisor)**: 감독자, **A(Accessed bit)**: 접근됨, **D(Dirty bit)**: 더티, **PFN(Page Frame Number)**: 페이지 프레임 번호

### 페이지 테이블의 구현

- **페이지 테이블은 주 메모리에 유지됩니다**.
- **페이지 테이블 기저 레지스터(PTBR)**: 페이지 테이블을 가리킵니다.
- **페이지 테이블 길이 레지스터(PRLR)**: 페이지 테이블의 크기를 나타냅니다.
- **모든 데이터/명령어 접근은 두 번의 메모리 접근을 요구합니다**:
    - 하나는 페이지 테이블을 위한 것이고, 다른 하나는 데이터/명령어를 위한 것입니다. → 속도 저하
- **두 번의 메모리 접근 문제는 특별한 빠른 조회 하드웨어 캐시인 연관 레지스터나 변환 색인 버퍼(TLB: Translation Look-aside Buffers, 8~2048 항목)의 사용으로 해결할 수 있습니다**.

### TLB (Translation Look-aside Buffer)

- **TLB는 칩의 메모리 관리 유닛(MMU)의 일부입니다**.
- **가상 주소에서 물리 주소로의 변환을 저장하는 하드웨어 캐시입니다**.
![[Pasted image 20240421134527.png]]
### TLB를 포함한 페이징 하드웨어

- **페이징 하드웨어는 TLB를 포함하여 효율적인 주소 변환을 지원합니다**.
![[Pasted image 20240421134533.png]]
### 효과적 접근 시간 (Effective Access Time, EAT)

- **연관 조회(Associative Lookup) 시간**: ε 시간 단위
- **메모리 사이클 시간 가정**: 1 마이크로초 (a 시간)
- **히트 비율(Hit ratio)**:
    - 페이지 번호가 연관 레지스터에서 발견되는 횟수의 비율;
    - 연관 레지스터의 수에 관련됨.
    - 히트 비율 = α
- **효과적 접근 시간 (EAT) 계산**:
    - EAT = (1 + ε)α + (2 + ε)(1 – α)
    - = 2 + ε – α
    - (또 다른 형식: EAT = (a + ε)α + (2a + ε)(1 – α) = a(2–α) + ε)
- 예시:
    - ε: 20ns, a: 100ns, α: 80%
    - EAT = 0.8*120 + 0.2*220 = 140ns






