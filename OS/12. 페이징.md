### 분리 리스트 (Segregated List)

- **분리 리스트**:
    - 인기 있는 요청 크기에 따라 다른 크기의 자유 청크를 별도의 리스트로 유지합니다.
    - **새로운 문제**:
        - 특정 크기의 요청을 전문적으로 처리하는 메모리 풀에 얼마나 많은 메모리를 할애해야 할까요?
    - 이 문제는 슬랩 할당자가 처리합니다.

### 슬랩 할당자 (Slab Allocator)

- **객체 캐시 수를 할당합니다**.
    - 이 객체들은 자주 요청될 가능성이 높습니다.
    - 예를 들어, 락(lock), 파일 시스템의 아이노드(inode) 등입니다.

### 메모리 추상화

메모리 추상화의 복잡성을 나타내는 일곱 가지 계층:

1. **가상화 없음**, 프로그램이 베어 메탈에서 실행
2. **시간 공유**, 한 번에 하나의 프로그램
3. **공간 공유**, 하나의 공유 주소 공간에서 프로그램 재배치
4. **공간 공유**, 세그먼트(기저)를 통한 가상 주소 공간
5. **공간 공유**, 세그먼트(기저+한계)를 통한 가상 주소 공간
6. **공간 공유**, 여러 세그먼트를 통한 가상 주소 공간
7. **공간 공유**, 페이징을 통한 가상 주소 공간

### 세그먼테이션의 한계

- **세그먼테이션**은 물리 주소 공간을 여러 프로세스간에 합리적으로 공유할 수 있게 해줍니다. 그러나 어떤 단점이 있을까요?
    
    - **공간**: 각 세그먼트는 메모리에 완전히 백업되어야 합니다.
    - **공간**: 물리 메모리 영역은 연속적이어야 합니다 (단편화).
    - **ISA**: 명령어가 명시적으로 또는 암시적으로 대상 세그먼트를 인코딩합니다.
- **단편화**: 사용할 수 없는 메모리.
    
    - **외부 단편화**: 할당자(OS)에게 보이는, 예를 들어 세그먼트 사이에 발생합니다.
    - 예를 들어, 16KiB의 메모리가 있습니다. 프로세스 A는 2,048(2KiB)에서 시작하는 4KiB의 코드 세그먼트, 8,096(8KiB)에서 시작하는 4KiB의 데이터 세그먼트, 그리고 14,336(14KiB)에서 시작하는 1KiB의 스택 세그먼트를 가집니다. 시스템에는 2+2+2+1 = 7 KiB의 자유 메모리가 있지만, 최대 연속 공간은 2 KiB입니다. 3KiB의 코드 세그먼트가 필요한 프로세스 B를 시작하는 것은 불가능합니다.
![[Pasted image 20240421134237.png]]

### 페이징(Paging)

- **페이징**은 주소 공간을 페이지라고 불리는 고정 크기 단위로 나눕니다.
    
    - **세그먼테이션**: 논리 세그먼트(코드, 스택, 힙 등)의 크기가 가변적입니다.
    - **내부 단편화**: 0.5 페이지
- **페이징을 사용하면 물리 메모리도 페이지 프레임이라고 불리는 일정 수의 페이지로 분할됩니다**.
    
    - 크기는 2의 거듭제곱으로, 512바이트에서 8192바이트(1KiB~4KiB) 사이입니다.
- **각 프로세스마다 가상 주소를 물리 주소로 변환하기 위한 페이지 테이블이 필요합니다**.
    

### 페이징의 장점

- **유연성**: 주소 공간의 추상화를 효과적으로 지원합니다.
    - 힙과 스택의 성장 방식 및 사용 방식에 대한 가정이 필요 없습니다.
- **단순성**: 자유 공간 관리의 용이성
    - 주소 공간의 페이지와 페이지 프레임이 동일한 크기입니다.
    - 할당하고 자유 목록을 유지하기 쉽습니다.

![[Pasted image 20240421134255.png]]

### 간단한 페이징 예시

- **128바이트의 물리 메모리와 16바이트 페이지 프레임**
- **64바이트 주소 공간과 16바이트 페이지**
![[Pasted image 20240421134426.png]]
### 주소 변환 방식

- **CPU에 의해 생성된 주소는 다음으로 나누어집니다**:
    
    - **페이지 번호(p)**: 페이지 테이블로의 인덱스로 사용되며, 각 페이지의 물리 메모리 내 기저 주소를 포함합니다.
    - **페이지 오프셋(d)**: 기저 주소와 결합되어 메모리 유닛으로 전송되는 물리 메모리 주소를 정의합니다.
- **주어진 논리 주소 공간 2m과 페이지 크기 2n에 대해**:
    
    - 페이지 번호(p), 페이지 오프셋(d)
    - m - n, n
![[Pasted image 20240421134433.png]]
### 페이징: 장단점

- **장점**:
    
    - **외부 단편화 없음**: 페이지는 고정 크기이므로 외부 단편화 발생하지 않습니다.
    - **할당 및 해제가 빠름**: 공간을 찾기 위한 검색이 없으며, 해제 시 통합이 필요 없습니다.
    - **핵심 매핑을 조정하기 쉬움**: 나중에 매핑된 하위 집합을 조정하기가 간단합니다.
- **단점**:
    
    - **페이지 테이블을 참조하기 위한 추가 메모리 참조 필요** (힌트: 캐시 사용)
    - **내부 단편화**: 페이지 크기에 대한 긴장이 존재합니다.
    - **페이지 테이블에 필요한 공간이 상당할 수 있음**:
        - 예: 32비트 주소 공간에서 4KB 페이지를 사용하는 경우, VPN에 20비트가 필요하며, 페이지 테이블 항목당 4바이트를 곱한 4MB의 크기가 필요합니다.
![[Pasted image 20240421134442.png]]

### 페이지 테이블이란?

- **페이지 테이블**은 가상 주소를 물리 주소로 매핑하는 데 사용되는 데이터 구조입니다(선형 페이지 테이블, 배열 형태).

### 페이지 테이블 항목의 일반적인 플래그

- **유효 비트(Valid Bit)**: 특정 변환의 유효성을 나타냅니다.
- **보호 비트(Protection Bit)**: 페이지가 읽기, 쓰기, 실행이 가능한지를 나타냅니다.
- **현재 비트(Present Bit)**: 해당 페이지가 물리 메모리에 있는지, 아니면 디스크에 스왑되어 있는지를 나타냅니다.
- **더티 비트(Dirty Bit)**: 메모리에 들어온 이후 페이지가 수정되었는지를 나타냅니다.
- **참조 비트(Reference Bit/Accessed Bit)**: 페이지가 접근되었음을 나타냅니다.

### x86 페이지 테이블 항목

- **P(Present)**: 현재, **R/W(Read/Write bit)**: 읽기/쓰기, **U/S(Supervisor)**: 감독자, **A(Accessed bit)**: 접근됨, **D(Dirty bit)**: 더티, **PFN(Page Frame Number)**: 페이지 프레임 번호

### 페이지 테이블의 구현

- **페이지 테이블은 주 메모리에 유지됩니다**.
- **페이지 테이블 기저 레지스터(PTBR)**: 페이지 테이블을 가리킵니다.
- **페이지 테이블 길이 레지스터(PRLR)**: 페이지 테이블의 크기를 나타냅니다.
- **모든 데이터/명령어 접근은 두 번의 메모리 접근을 요구합니다**:
    - 하나는 페이지 테이블을 위한 것이고, 다른 하나는 데이터/명령어를 위한 것입니다. → 속도 저하
- **두 번의 메모리 접근 문제는 특별한 빠른 조회 하드웨어 캐시인 연관 레지스터나 변환 색인 버퍼(TLB: Translation Look-aside Buffers, 8~2048 항목)의 사용으로 해결할 수 있습니다**.

### TLB (Translation Look-aside Buffer)

- **TLB는 칩의 메모리 관리 유닛(MMU)의 일부입니다**.
- **가상 주소에서 물리 주소로의 변환을 저장하는 하드웨어 캐시입니다**.
![[Pasted image 20240421134527.png]]
### TLB를 포함한 페이징 하드웨어

- **페이징 하드웨어는 TLB를 포함하여 효율적인 주소 변환을 지원합니다**.
![[Pasted image 20240421134533.png]]
### 효과적 접근 시간 (Effective Access Time, EAT)

- **연관 조회(Associative Lookup) 시간**: ε 시간 단위
- **메모리 사이클 시간 가정**: 1 마이크로초 (a 시간)
- **히트 비율(Hit ratio)**:
    - 페이지 번호가 연관 레지스터에서 발견되는 횟수의 비율;
    - 연관 레지스터의 수에 관련됨.
    - 히트 비율 = α
- **효과적 접근 시간 (EAT) 계산**:
    - EAT = (1 + ε)α + (2 + ε)(1 – α)
    - = 2 + ε – α
    - (또 다른 형식: EAT = (a + ε)α + (2a + ε)(1 – α) = a(2–α) + ε)
- 예시:
    - ε: 20ns, a: 100ns, α: 80%
    - EAT = 0.8*120 + 0.2*220 = 140ns


### 배열 접근 예시: TLB의 성능 향상 방법

TLB(Translation Look-aside Buffer)는 메모리 접근 시 필요한 주소 변환 정보를 빠르게 제공함으로써 성능을 향상시킬 수 있습니다. 특히 배열과 같은 데이터 구조를 접근할 때 TLB를 통한 빠른 변환은 중요한 역할을 합니다.

### 지역성(Locality)

- **시간적 지역성(Temporal Locality)**:
    - 최근 접근된 명령어나 데이터 항목은 가까운 미래에 다시 접근될 가능성이 높습니다.
![[Pasted image 20240421134656.png]]
- **공간적 지역성(Spatial Locality)**:
    - 프로그램이 x 주소에서 메모리를 접근하면, 곧 x 주변의 메모리를 접근할 가능성이 높습니다.
![[Pasted image 20240421134716.png]]

### TLB 항목

- **TLB는 완전 연관(풀 어소시에이티브) 방식으로 관리됩니다**:
    - 일반적인 TLB는 32, 64, 또는 128개의 항목을 가질 수 있습니다.
    - 하드웨어는 전체 TLB를 동시에 검색하여 원하는 변환을 찾습니다.
- **기타 비트**:
    - 유효 비트(valid bits), 보호 비트(protection bits), 주소 공간 식별자, 더티 비트(dirty bit)
    - 메모리 보호는 각 프레임에 연결된 보호 비트를 통해 구현됩니다 (읽기/쓰기, 읽기 전용).
- **페이지 테이블의 각 항목에는 유효-무효 비트가 부착됩니다**:
    - "유효(valid)"는 관련 페이지가 프로세스의 논리 주소 공간에 있으며, 따라서 합법적인 페이지임을 나타냅니다.
    - "무효(invalid)"는 페이지가 프로세스의 논리 주소 공간에 없음을 나타냅니다.
![[Pasted image 20240421134725.png]]







![[Pasted image 20240421134643.png]]![[Pasted image 20240421134735.png]]
![[Pasted image 20240421134747.png]]

### 또 다른 사례: 두 프로세스가 페이지를 공유

- **프로세스 1이 프로세스 2와 물리 페이지 101을 공유합니다**.
    - P1은 이 페이지를 자신의 주소 공간의 10번째 페이지에 매핑합니다.
    - P2는 이 페이지를 자신의 주소 공간의 50번째 페이지에 매핑합니다.
![[Pasted image 20240421134834.png]]
### 공유 페이지

- **공유 코드**:
    - 읽기 전용(재진입 가능) 코드의 한 복사본이 프로세스 간에 공유됩니다 (예: 텍스트 편집기, 컴파일러, 윈도우 시스템).
    - 공유 코드는 모든 프로세스의 논리 주소 공간에서 같은 위치에 나타나야 합니다.
- **개인 코드와 데이터**:
    - 각 프로세스는 코드와 데이터의 별도 복사본을 유지합니다.
    - 개인 코드와 데이터의 페이지는 논리 주소 공간의 어느 곳에나 나타날 수 있습니다.
![[Pasted image 20240421134842.png]]
### TLB 교체 정책

- **LRU (최근에 가장 적게 사용된)**:
    - 최근에 사용되지 않은 항목을 제거합니다.
    - 메모리 참조 스트림의 지역성을 활용합니다.
![[Pasted image 20240421134928.png]]





### 페이지 테이블 구조

#### 선형 테이블 페이징

- **선형 테이블 페이징**: 전체 가상 주소 공간을 하나의 연속된 페이지 테이블에 매핑합니다.

#### 하이브리드 접근법 (페이징 + 세그먼트)

- **하이브리드 접근법**: 페이징과 세그먼트를 결합하여 각 세그먼트에 대한 별도의 페이지 테이블을 사용합니다. 이는 메모리 사용을 최적화하고 세그먼트 각각의 특성에 맞게 관리할 수 있게 합니다.

#### 계층적 페이징

- **계층적 페이징**: 논리 주소 공간을 여러 페이지 테이블로 분할합니다. 간단한 기술로는 두 단계 페이지 테이블이 있습니다. 이는 주소 공간을 관리하기 위해 두 레벨의 페이지 테이블을 사용하여 메모리 사용의 효율성을 높입니다.

#### 해시 페이지 테이블

- **해시 페이지 테이블**: 가상 주소를 해시하여 해당 페이지의 물리 주소를 찾는 해시 테이블 기반의 접근 방식입니다. 이는 특히 큰 주소 공간을 효율적으로 관리할 때 유용합니다.

#### 역 페이지 테이블

- **역 페이지 테이블**: 전체 물리 메모리를 하나의 페이지 테이블로 매핑하고, 가상 주소에 대한 참조를 역으로 매핑하는 방식입니다. 이는 메모리 오버헤드를 줄이는 데 효과적입니다.

### 페이징: 선형 테이블

- **32비트 주소 공간에 4KB 페이지와 4바이트 페이지 테이블 항목을 가정**.
- **32비트 주소 공간에 16KB 페이지와 4바이트 페이지 테이블 항목을 가정**.
- **페이지 테이블이 너무 커서 너무 많은 메모리를 소비합니다**.
- **큰 페이지는 내부 단편화를 초래합니다**.
- **페이지 테이블의 대부분은 사용되지 않으며, 무효 항목으로 가득 차 있습니다**.

### 하이브리드 접근법: 페이징과 세그먼트

- **페이지 테이블의 메모리 오버헤드를 줄이기 위해**:
    - 기저 주소를 세그먼트 자체를 가리키는 것이 아니라 해당 세그먼트의 페이지 테이블의 물리 주소를 유지하는 데 사용합니다.
    - 경계 레지스터는 페이지 테이블의 끝을 나타내는 데 사용됩니다.
- **각 프로세스는 세 개의 페이지 테이블과 연관되어 있습니다**:
    - 프로세스가 실행 중일 때, 이 세그먼트들 각각의 기저 레지스터에는 해당 세그먼트의 선형 페이지 테이블의 물리 주소가 포함됩니다.
![[Pasted image 20240421135022.png]]
- **하이브리드 접근법도 문제가 없는 것은 아닙니다**:
    - 사용이 적은 큰 힙을 가지고 있어도 여전히 많은 페이지 테이블의 낭비가 발생할 수 있습니다.
    - 외부 단편화가 다시 발생할 수 있습니다.

### 다중 레벨 페이지 테이블

- **선형 페이지 테이블을 나무와 같은 구조로 변환**:
    - 페이지 테이블의 페이지가 유효한지 추적하기 위해, '페이지 디렉토리'라고 불리는 새로운 구조를 사용합니다.

![[Pasted image 20240421135030.png]]