### 운영 시스템 설계

- 시스템의 설계는 하드웨어 선택과 시스템의 유형에 영향을 받습니다.
- 설계 시작 시 목표와 사양을 정의해야 합니다.

### 사용자와 시스템의 목표

- **사용자 목표**: 운영 시스템은 사용하기 편리하고 배우기 쉬우며, 신뢰할 수 있고 안전하며 빠르게 작동해야 합니다.
- **시스템 목표**: 운영 시스템은 설계, 구현 및 유지 관리가 쉽고, 유연하며 신뢰성 있고 오류가 없고 효율적이어야 합니다.

### 중요한 원칙: 정책과 메커니즘의 분리

- **정책(Policy)**: 무엇을 할 것인가?
- **메커니즘(Mechanism)**: 어떻게 할 것인가?

메커니즘은 어떻게 무언가를 할지를 결정하고, 정책은 무엇을 할지 결정합니다. 정책과 메커니즘의 분리는 매우 중요한 원칙으로, 나중에 정책 결정이 변경되어야 할 경우 최대한의 유연성을 제공합니다.

### 운영 시스템 구조의 발전

- 초기에는 작고 간단하며 제한된 시스템으로 시작하여 원래 범위를 넘어서 확장되었습니다. 결과적으로 잘 정의된 구조를 갖지 못했습니다.

### 간단한 구조

- **MS-DOS**: 최소한의 공간에서 최대한의 기능을 제공하도록 작성되었습니다.
    - 모듈로 나누어지지 않은 구조를 가지고 있습니다.
    - MS-DOS는 일부 구조를 가지고 있지만, 그 인터페이스와 기능 수준은 잘 분리되어 있지 않습니다.
![[Pasted image 20240420211711.png]]
### 시스템 구조 – 단순 접근법 (계속)

- **UNIX**:
    - 커널은 시스템 호출 인터페이스 아래와 물리적 하드웨어 위의 모든 것을 포함합니다.
    - 파일 시스템, CPU 스케줄링, 메모리 관리 등의 운영 체제 기능을 제공합니다. 한 레벨에 많은 기능을 포함하는 것은 대규모 기능을 가진 단일 레벨이 됩니다.
    - 모놀리식 커널로 구성됩니다.

![[Pasted image 20240420211720.png]]

## 시스템 구조 - 계층적 구조

- 운영 시스템은 여러 계층(레벨)으로 나누어집니다. 각 계층은 그 아래 계층 위에 구축됩니다. 가장 낮은 계층(레벨 0)은 하드웨어이고, 가장 높은 계층(레벨 N)은 사용자 인터페이스입니다.
    
- 모듈성을 통해, 각 계층은 오직 그 아래 계층의 기능(작업)과 서비스만을 사용하도록 선택됩니다.
    
    - 시스템의 설계와 구현이 단순화됩니다.
    - 추상화 과정을 통해 구현합니다.
- 주요 어려움은 다양한 계층의 적절한 정의에 있습니다.
    
- 계층적 접근법은 다른 접근법보다 효율이 떨어질 수 있습니다.
    
    - 각 계층은 시스템 호출에 오버헤드를 추가하고, 결과적으로 비계층적 시스템에서의 시스템 호출보다 더 오래 걸릴 수 있습니다.
    - OS/2, Windows NT와 같은 운영 시스템은 느릴 수 있지만, 강력한 하드웨어를 요구합니다.

![[Pasted image 20240420211852.png]]

## 마이크로커널

- **모놀리식 커널**: 모놀리식 커널은 너무 무겁다는 단점이 있습니다.
- **핵심 기능의 커널 할당**: 마이크로커널은 몇 가지 필수 기능만 커널에 할당합니다.
    - 주소 공간 관리
    - 프로세스 간 통신(IPC)
    - 기본 스케줄링
- **핵심 기능 축소**: 핵심 기능을 작게 유지하고 모든 비핵심 기능을 시스템 또는 사용자 수준의 프로그램으로 이동시킵니다.
    - 가능한 많은 기능을 “사용자” 공간으로 옮깁니다.
- **통신**: 사용자 모듈 간의 통신은 메시지 전달을 사용하여 이루어집니다.

### 마이크로커널의 장점:

- **확장 용이성**: 마이크로커널은 확장하기가 더 쉽습니다.
- **새로운 아키텍처로의 이식성**: 운영 시스템을 새로운 아키텍처로 포팅하기가 더 쉽습니다.
- **신뢰성 향상**: 커널 모드에서 실행되는 코드가 더 적으므로 더 신뢰성이 높습니다.
- **보안 강화**

### 마이크로커널의 단점:

- **통신의 성능 오버헤드**: 사용자 공간과 커널 공간 간의 통신은 성능 오버헤드를 초래할 수 있습니다.

마이크로커널은 이러한 장점과 단점을 감안하여, 특히 보안이 중요하고 시스템의 안정성이 요구되는 환경에서 선호되는 운영 체제 구조입니다.


## 모듈

- 대부분의 현대 운영 시스템은 커널 모듈을 구현합니다.
    - 객체 지향 접근법을 사용합니다.
    - 각 핵심 구성 요소는 분리되어 있습니다.
    - 각 구성 요소는 알려진 인터페이스를 통해 서로 통신합니다.
    - 각 모듈은 필요에 따라 커널 내에서 로드됩니다.
- 전반적으로, 계층 구조와 유사하지만 더 유연합니다.

현대 운영 시스템에서 모듈 구조는 시스템의 확장성과 유지 관리를 용이하게 하며, 필요에 따라 개별 모듈을 독립적으로 업데이트하거나 교체할 수 있는 유연성을 제공합니다.
![[Pasted image 20240420212020.png]]

## 시스템 생성 (SYSGEN)

- 운영 시스템은 다양한 종류의 기계에서 실행될 수 있도록 설계되어 있으며, 특정 컴퓨터 사이트마다 설정을 구성해야 합니다. 이를 시스템 생성 또는 시스템 설치라고 합니다.
- SYSGEN 프로그램은 하드웨어 시스템의 구체적인 설정에 대한 정보를 획득합니다.
    - CPU 유형, 메모리 크기, 연결된 장치, 운영 체제의 옵션 등을 포함합니다.

### 부팅

- 커널을 메모리에 로드하여 컴퓨터를 시작하는 과정입니다.

### 부트스트랩 프로그램

- 커널을 찾아서 메모리에 로드하고 실행을 시작할 수 있는 ROM에 저장된 코드입니다.

### 운영 시스템 디버깅

- 운영 시스템은 오류 정보를 포함하는 로그 파일을 생성합니다.
- 응용 프로그램의 실패는 프로세스의 메모리를 포착하는 코어 덤프 파일을 생성할 수 있습니다.
- 운영 시스템의 실패는 커널 메모리를 담고 있는 크래시 덤프 파일을 생성할 수 있습니다.
- 시스템 성능을 최적화하기 위해 성능 조정을 넘어서 디버깅이 필요할 수 있습니다.
- 커니건의 법칙에 따르면 "디버깅은 처음에 코드를 작성하는 것보다 두 배 어렵다. 따라서 가능한 가장 교묘하게 코드를 작성한다면, 정의상 당신은 그것을 디버깅할 만큼 똑똑하지 않다."
- 프로파일링은 주기적으로 명령 포인터를 샘플링하여 어떤 코드가 실행되고 있는지를 결정합니다.

이러한 과정들은 운영 체제가 각기 다른 하드웨어 환경에 맞춰 설치되고 유지되며, 문제가 발생할 경우 원인을 분석하고 해결하기 위한 정보를 수집하는 방법을 설명합니다.


## 현대 OS의 특징

* 마이크로 커넬 아키텍쳐
* 멀티 쓰레딩
	* 프로세스는 동시에 실행할 수 있는 스레드로 나누어집니다.
* 쓰레드
	* 작업을 할당할 수 있는 단위 ▪ 순차적으로 실행되며, 중단이 가능합니다.
* 대칭형 멀티 프로세싱
	* 여러 프로세스가 있을 때 동일한 주 메모리와 I/O 장치를 공유합니다.
	* 모든 프로세서는 동일한 기능을 수행할 수 있습니다.
* 분산 운영체제
	* 단일 주 메모리의


현대 운영 체제의 특징: ❖ 마이크로커널 아키텍처 ❖ 멀티스레딩 ▪ ❖ 스레드 ▪  ❖ 프로세스는 하나 이상의 스레드의 집합입니다. ❖ 대칭형 멀티프로세싱 ▪ 여러 프로세서가 있습니다. ▪ 이 프로세서들은 동일한 주 메모리와 I/O 시설을 공유합니다. ▪ 모든 프로세서는 동일한 기능을 수행할 수 있습니다. -19-현대 운영 체제의 특징 ❖ 분산 운영 체제 ▪ 단일 주 메모리의 환상을 제공합니다. ▪ 분산 파일 시스템에 사용됩니다. ❖ 객체 지향 디자인 ▪ 작은 커널에 모듈식 확장을 추가하는 데 사용됩니다. ▪ 프로그래머가 시스템 무결성을 방해하지 않고 운영 체제를 사용자 정의할 수 있게 합니다.