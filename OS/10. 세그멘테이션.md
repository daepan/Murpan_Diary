### 연속 할당 (Contiguous Allocation)

- **주요 메모리는 보통 두 부분으로 나뉩니다**:
    
    - 상주 운영체제는 보통 저메모리에 위치하며 인터럽트 벡터를 포함합니다.
    - 사용자 프로세스는 고메모리에 위치합니다.
- **단일 파티션 할당** (전체 사용자 메모리 사용, 유연성):
    
    - 사용자 프로세스들 사이에서 서로를 보호하기 위해 재배치 레지스터 방식이 사용됩니다.
    - 재배치 레지스터는 가장 작은 물리 주소의 값을 포함합니다.
    - 한계 레지스터는 논리 주소 범위를 포함하며, 모든 논리 주소는 한계 레지스터보다 작아야 합니다.
- **고정 크기 파티션**은 하나의 프로세스만 포함할 수 있습니다:
    
    - MFT: 다중 연속 고정 파티션 할당 - 현재는 사용되지 않음.

### 커널 및 파티션 구조 예시

- partition-A (10MB)
- partition-B (10MB)
- partition-C (20MB)
- partition-D (30MB)
- partition-E (50MB)
![[Pasted image 20240421131758.png]]
### 연속 할당 (계속)

- **다중 파티션 할당**:
    - MVT: 다중 연속 가변 파티션 할당
    - **홀(hole)** - 사용 가능한 메모리 블록; 메모리 전체에 다양한 크기의 홀이 흩어져 있습니다.
    - 프로세스가 도착하면, 그것을 수용할 수 있는 충분히 큰 홀에서 메모리가 할당됩니다.
    - 운영체제는 할당된 파티션과 자유 파티션(홀)에 대한 정보를 유지 관리합니다.
*  인접 공간 통합 작업
	* 인접한 빈 분할 영역들을 하나의 분할 영역으로 통합
* 기억장소 통합 작업
	* 모든 빈 분할 영역들을 하나로 통합
	* 프로그램의 적재 공간이 부족할 경우 수행
	* 주기억장치 내의 모든 프로세스들의 재배치 작업 수행 필요
	* 작업시간이 매우 긺
	* 많은 시스템 자원을 소비하는 결과를 초래
![[Pasted image 20240421131808.png]]


### 동적 저장소(또는 메모리) 할당 문제

- **요구 사항**: 자유 홀 목록에서 크기 n의 요청을 만족시키는 방법.
- **첫 번째 맞춤(First-fit)**: 충분히 큰 첫 번째 홀을 할당합니다.
- **최적 맞춤(Best-fit)**: 충분히 큰 가장 작은 홀을 할당합니다; 크기 순으로 정렬되지 않은 경우 전체 목록을 검색해야 합니다. 가장 작은 잔여 홀을 생성합니다.
- **최악 맞춤(Worst-fit)**: 가장 큰 홀을 할당합니다; 이 또한 전체 목록을 검색해야 합니다. 가장 큰 잔여 홀을 생성합니다.

### 단편화(Fragmentation)

- **외부 단편화(External fragmentation)**: 요청을 만족시킬 수 있는 총 메모리 공간은 존재하지만 연속적이지 않습니다.
- **내부 단편화(Internal fragmentation)**: 할당된 메모리가 요청된 메모리보다 약간 더 클 수 있습니다; 이 크기 차이는 파티션 내부의 메모리에 있지만 사용되지 않습니다.
- **외부 단편화 감소 방법**: 단속
    - 메모리 내용을 섞어 모든 자유 메모리를 하나의 큰 블록으로 모읍니다.
    - 단속은 동적 재배치가 가능하고 실행 시간에 이루어질 때만 가능합니다.
    - **I/O 문제**:
        - I/O에 관여하는 동안 메모리에서 작업을 고정합니다.
        - OS 버퍼로만 I/O를 수행합니다.

### 메모리 단속

메모리 단속은 분산되어 있는 자유 메모리를 하나의 큰 연속된 블록으로 통합하는 과정입니다. 이는 동적 재배치가 가능하며 실행 시간에 진행됩니다.

### 세분화(Segmentation)

- **프로그램**: 다양한 크기의 세그먼트 모음입니다.
- **세그먼트**: 특정 길이의 주소 공간의 연속된 부분입니다.
    - 논리적으로 다른 세그먼트: 코드, 스택, 힙
- **각 세그먼트 배치**: 물리 메모리의 다른 부분에 배치할 수 있습니다.
    - 각 세그먼트마다 기반과 한계가 있습니다.

#### 세그먼트 예시

- 코드: 기저 32K, 크기 2K
- 힙: 기저 34K, 크기 2K
- 스택: 기저 28K, 크기 2K

### 세그먼트 아키텍처

- **논리 주소**: <세그먼트 번호, 오프셋>의 튜플로 구성됩니다.
- **세그먼트 테이블**: 이차원 물리 주소를 매핑합니다; 각 테이블 항목에는 다음이 포함됩니다.
    - 기저(base): 세그먼트가 메모리에서 거주하는 시작 물리 주소를 포함합니다.
    - 한계(limit): 세그먼트의 길이를 지정합니다.
- **세그먼트 테이블 기저 레지스터(STBR)**: 메모리 내 세그먼트 테이블의 위치를 가리킵니다.
- **세그먼트 테이블 길이 레지스터(STLR)**: 프로그램에 의해 사용되는 세그먼트 수를 나타냅니다; 세그먼트 번호 s는 s < STLR 일 경우 합법적입니다.
* 세그멘테이션 예제

![[Pasted image 20240421132253.png]]


## 세그먼트 공유

![[Pasted image 20240421133428.png]]

### 세그먼트 주소 변환 (오류)

- **세그먼트 오류 또는 위반**:
    
    - 힙의 끝을 넘어서는 7KB와 같은 불법 주소가 참조될 경우, 운영체제에서 세그먼트 오류가 발생합니다.
    - 하드웨어는 주소가 범위를 벗어났음을 감지합니다.
- **명시적 접근 방식**:
    ![[Pasted image 20240421133456.png]]
    - 가상 주소의 상위 몇 비트를 기준으로 주소 공간을 세그먼트로 나눕니다.
    - 예: 가상 주소 4200 (01000001101000)
        - 세그먼트 비트:
            - 코드: 00
            - 힙: 01
            - 스택: 10
![[Pasted image 20240421133504.png]]
### 세그먼트 주소 변환 (스택)

- **스택은 뒤로 성장합니다**.
- **추가 하드웨어 지원이 필요합니다**:
    - 하드웨어는 세그먼트가 어느 방향으로 성장하는지 확인합니다.
    - 1: 양의 방향, 0: 음의 방향
    - 예:
        - 코드: 기저 32K, 크기 2K, 양의 방향에서 성장
        - 힙: 기저 34K, 크기 2K, 양의 방향에서 성장
        - 스택: 기저 28K, 크기 2K, 음의 방향에서 성장
![[Pasted image 20240421133440.png]]
### 세그먼트 주소 변환 (공유)

- **세그먼트는 주소 공간 사이에 공유될 수 있습니다**:
    
    - 오늘날 시스템에서도 코드 공유가 여전히 사용됩니다.
    - 이를 위해 추가 하드웨어 지원이 필요합니다.
- **추가 하드웨어 지원이 보호 비트 형태로 필요합니다**:
    
    - 각 세그먼트마다 읽기, 쓰기, 실행 권한을 나타내는 몇 개의 추가 비트가 필요합니다.
![[Pasted image 20240421133523.png]]
- **세그먼트 크기 (세밀하게 또는 거칠게)**:
    
    - 거친 세분화는 소수의 세그먼트로 구성됩니다 (예: 코드, 힙, 스택).
    - 세밀한 세분화는 초기 시스템에서 주소 공간에 대해 더 많은 유연성을 허용합니다.
    - 많은 세그먼트를 지원하기 위해서는 세그먼트 테이블이 있는 하드웨어 지원이 필요합니다.