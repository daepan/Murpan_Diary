
### 페이지 선택 정책

- **운영체제(OS)는 페이지를 메모리로 가져올 시기를 결정해야 합니다**.
- **운영체제에 몇 가지 다른 옵션을 제공합니다**.
    - **프리페칭(Prefetching)**
        - 운영체제가 페이지가 곧 사용될 것이라고 예측하고, 미리 메모리로 가져옵니다.
        - 예를 들어, 페이지 2가 곧 접근될 가능성이 높으므로 메모리로 가져와야 합니다.
    - **클러스터링, 그루핑(Clustering, Grouping)**
        - 여러 개의 보류 중인 쓰기를 메모리에 함께 모아 두었다가 한 번의 쓰기로 디스크에 기록합니다.
        - 많은 작은 쓰기보다 한 번의 큰 쓰기를 더 효율적으로 수행합니다.

### 프레임 할당

- **다양한 프로세스들 사이에서 고정된 양의 자유 메모리를 어떻게 할당할까요?**
- **각 프로세스는 최소한의 페이지 수가 필요합니다 (아키텍처에 의해 정의됨)**.
- **글로벌 대 로컬 할당**
    - **글로벌 교체(Global replacement)** – 프로세스가 모든 프레임의 집합에서 교체 프레임을 선택; 한 프로세스가 다른 프로세스의 프레임을 가져갈 수 있습니다.
    - **로컬 교체(Local replacement)** – 각 프로세스가 자신에게 할당된 프레임 집합에서만 선택합니다.

### 주요 할당 체계

- **고정 할당(Fixed Allocation)**
    
    - **동등 할당(Equal allocation)** – 예를 들어, 100개의 프레임과 5개의 프로세스가 있다면, 각각에게 20개의 페이지를 제공합니다.
        - m: 프레임 수, n: 프로세스 수, m/n: 각 프로세스의 프레임 수
    - **비례 할당(Proportional allocation)** – 프로세스의 크기에 따라 할당합니다.
- **우선순위 할당(Priority Allocation)**
    
    - 크기가 아닌 우선순위를 사용하는 비례 할당 체계를 사용합니다.
    - 프로세스 Pi가 페이지 폴트를 발생시키면,
        - 교체를 위해 그 프로세스의 프레임 중 하나를 선택합니다.
        - 우선순위가 낮은 프로세스의 프레임 중에서 교체할 프레임을 선택합니다.


### 쓰레싱 (Thrashing)

- **쓰레싱은 프로세스가 페이지를 메모리에 들어오고 나가게 하는 작업에 바쁜 상태를 의미합니다** (지역성).
    - 메모리가 과도하게 사용되어 실행 중인 프로세스 세트의 메모리 요구가 사용 가능한 물리 메모리를 초과합니다.
    - 이는 낮은 CPU 이용률로 이어집니다. 운영 체제는 멀티프로그래밍의 정도를 늘려야 한다고 판단합니다. 시스템에 다른 프로세스가 추가됩니다.
    - 프로세스의 부분 집합을 실행하지 않기로 결정합니다.
    - 메모리에 맞는 축소된 프로세스 작업 세트.

### 지역성 모델

- **지역성은 함께 활발히 사용되는 페이지 세트입니다**.
- **프로세스는 한 지역성에서 다른 지역성으로 이동합니다**.
- **지역성은 중첩될 수 있습니다**.

### 왜 쓰레싱이 발생하나요?

- **지역성의 크기가 전체 메모리 크기보다 큰 경우 발생합니다**.

### 작업 세트 모델 (Working-Set Model)

- **Δ는 작업 세트 창으로, 고정된 수의 페이지 참조를 의미합니다**.
    - 예: 10,000개의 명령어
- **WSSi (프로세스 Pi의 작업 세트)** = 가장 최근 Δ에서 참조된 페이지의 총 수 (시간에 따라 변함).
    - Δ가 너무 작으면 전체 지역성을 포함하지 못할 수 있습니다.
    - Δ가 너무 크면 여러 지역성을 포함할 수 있습니다.
    - Δ = ∞이면 전체 프로그램을 포함하게 됩니다.
- **D = Σ WSSi는 총 요구 프레임을 의미합니다**.
- **D > m인 경우 쓰레싱이 발생합니다**.
- **정책: D > m인 경우, 하나의 프로세스를 중단합니다**.


#### 프리페이징 (Prepaging)

- **초기 페이징의 높은 페이지 폴트율을 방지하기 위해**
    - 프로세스 시작 시 발생하는 많은 페이지 폴트 수를 줄입니다.
    - 참조되기 전에 프로세스가 필요로 할 페이지의 전부 또는 일부를 미리 페이징합니다.
    - 그러나 프리페이징된 페이지가 사용되지 않으면 I/O와 메모리가 낭비됩니다.
    - s 페이지가 프리페이징되고, 그 중 α 비율의 페이지가 사용된다고 가정할 때,
        - s * α 페이지 폴트를 줄이는 비용이 s * (1- α) 불필요한 페이지를 프리페이징하는 비용보다 큰지 또는 작은지를 고려해야 합니다.
        - α가 0에 가까우면 프리페이징이 손실됩니다.

#### 페이지 크기 선택

- **페이지 크기 (2의 거듭제곱; 512에서 16384까지)**
    - 단편화
    - 테이블 크기
    - I/O 오버헤드
    - 지역성

#### TLB 리치 (TLB Reach)

- **TLB로 접근할 수 있는 메모리의 양**
    - TLB Reach = (TLB 크기) x (페이지 크기)
    - 이상적으로, 각 프로세스의 작업 세트는 TLB에 저장됩니다.
    - 그렇지 않으면 페이지 폴트가 많이 발생합니다.

#### 페이지 크기 증가

- **큰 페이지 크기로 인해 단편화가 증가할 수 있으며, 모든 애플리케이션에 큰 페이지 크기가 필요한 것은 아닙니다**.

#### 다양한 페이지 크기 제공

- **큰 페이지 크기가 필요한 애플리케이션에 기회를 제공하면서 단편화 증가 없이 사용할 수 있게 합니다**.

#### I/O 인터록

- **페이지가 메모리에 고정되어야 할 때가 있습니다**
    - I/O 페이지가 페이징 아웃될 수 있습니다.
        - 사용자 메모리에 I/O를 수행하지 않거나,
        - 페이지를 메모리에 고정할 수 있도록 허용합니다.
    - 잠금은 매우 유용하지만 해로울 수 있습니다.

#### I/O 고려

- **디바이스에서 파일을 복사하는 데 사용되는 페이지는 페이지 교체 알고리즘에 의해 선택되지 않도록 잠금 처리해야 합니다**.

#### 수요 세그먼테이션

- **수요 페이징을 구현하기에 충분한 하드웨어가 없을 때 사용됩니다**.
    - 세그먼트 설명자는 세그먼트가 현재 메모리에 있는지 여부를 나타내는 유효 비트를 포함합니다.
    - 세그먼트가 메인 메모리에 있으면 접근이 계속되고,
    - 메모리에 없으면 세그먼트 폴트가 발생합니다.

#### 프로그램 구조

- **배열 A[1024, 1024] 정수**
    - 각 행은 한 페이지에 저장됩니다 (행 우선).
    - 프로그램 1: `for j := 1 to 1024 do for i := 1 to 1024 do A[i,j] := 0;` → 1024 x 1024 페이지 폴트
    - 프로그램 2: `for i := 1 to 1024 do for j := 1 to 1024 do A[i,j] := 0;` → 1024 페이지 폴트