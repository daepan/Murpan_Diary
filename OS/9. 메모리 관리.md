### 메모리 관리

- **프로그램은 실행되기 위해 메모리에 가져와지고 프로세스 내에 배치되어야 합니다**:
    
    - 정확한 운영을 보장하기 위해 메모리 보호가 필요합니다.
- **메인 메모리와 레지스터는 CPU가 직접 접근할 수 있는 유일한 저장소입니다**:
    
    - 레지스터 접근은 한 CPU 클록(또는 그 이하)에 이루어집니다.
    - 메인 메모리 접근은 많은 사이클이 소요될 수 있습니다.
- **캐시는 메인 메모리(하위 메모리)와 CPU 레지스터(상위 메모리) 사이에 위치합니다**:
    
    - 캐시는 CPU와 메인 메모리 사이의 데이터 전송 속도 차이를 줄이기 위해 사용되며, CPU가 더 빠르게 데이터에 접근할 수 있도록 돕습니다.

이러한 메모리 관리 방식은 시스템의 성능을 최적화하고, 프로그램이 안정적으로 실행될 수 있도록 중요한 역할을 합니다. 메모리 보호와 캐시 사용은 데이터 무결성을 유지하고, 프로세스의 실행 속도를 개선하는 데 필수적인 요소입니다.

### 바인딩

- **바인딩**: 심볼릭 주소(예: 변수 이름)이 이동 가능한 주소로 매핑됩니다.

### 명령어와 데이터의 주소 바인딩

- **주소 바인딩은 세 가지 다른 단계에서 발생할 수 있습니다**:
    - **컴파일 시간 (Compile time)**: 메모리 위치가 사전에 알려져 있으면 절대 코드를 생성할 수 있습니다; 시작 위치가 변경되면 코드를 다시 컴파일해야 합니다.
    - **로드 시간 (Load time)**: 컴파일 시에 메모리 위치를 알 수 없다면 이동 가능한 코드를 생성해야 합니다.
    - **실행 시간 (Execution time)**: 실행 중에 프로세스가 메모리 세그먼트 사이에서 이동할 수 있는 경우, 실행 시까지 바인딩을 지연시킵니다. 주소 맵을 위한 하드웨어 지원이 필요합니다(예: 베이스 및 제한 레지스터).

이러한 주소 바인딩 방법은 시스템에서 프로그램이 어떻게 메모리 주소에 연결되는지를 결정합니다. 각 바인딩 단계는 메모리 할당과 프로그램 실행의 유연성과 효율성을 다루는 데 있어 장단점을 가지고 있으며, 시스템의 요구 사항과 제약에 따라 적절한 시점에 선택되어야 합니다.


![[Pasted image 20240421012034.png]]


### 동적 로딩 (Dynamic Loading)

- **동적 로딩은 특정 루틴이 호출될 때까지 로드되지 않습니다**:
    - 메모리 공간 활용도가 높아지며, 사용되지 않는 루틴은 로드되지 않습니다.
    - 자주 발생하지 않는 경우를 처리하기 위해 대량의 코드가 필요할 때 유용합니다.

### 동적 링킹 (Dynamic Linking)

- **실행 시까지 링킹을 연기합니다**:
    - 작은 코드 조각인 스텁(stub)을 사용하여 메모리에 상주하는 적절한 라이브러리 루틴을 찾습니다.
        - 적절한 메모리 상주 라이브러리 루틴을 찾는 방법
        - 루틴이 이미 존재하지 않을 경우 라이브러리를 로드하는 방법
    - 스텁은 루틴의 주소로 자신을 대체하고 루틴을 실행합니다.
- **운영체제는 루틴이 프로세스의 메모리 주소에 있는지 확인해야 합니다**:
    - 운영체제는 여러 프로세스가 동일한 메모리 주소에 접근할 수 있도록 허용합니다 => 리눅스의 공유 라이브러리 또는 윈도우의 DLL(Dynamic Link Library)과 같습니다.
- **동적 링킹은 특히 라이브러리에 유용합니다**.

### 메모리 가상화

- **메모리 가상화란?**
    - 운영체제는 물리적 메모리를 가상화합니다.
    - 운영체제는 각 프로세스마다 메모리 공간의 환상을 제공합니다.
    - 각 프로세스가 전체 메모리를 사용하는 것처럼 보입니다.
- **메모리 가상화의 이점**:
    - 프로그래밍에서 사용하기 쉽습니다.
    - 시간과 공간 측면에서 메모리 효율성을 제공합니다.
    - 프로세스뿐만 아니라 운영체제의 격리 보장:
        - 다른 프로세스의 잘못된 접근으로부터 보호합니다.

이러한 기술은 효율적인 시스템 리소스 관리와 프로그램의 성능 향상을 위해 중요합니다. 동적 로딩과 링킹은 필요에 따라 자원을 할당하며, 메모리 가상화는 각 프로세스에 독립적인 작업 환경을 제공하여 시스템의 안정성과 보안을 강화합니다.

### 메모리에 프로세스 로드

- **초기 시스템에서는 메모리에 하나의 프로세스만 로드**:
    
    - 이 방식은 이용률과 효율성이 낮습니다.
    ![[Pasted image 20240421012155.png]]
- **메모리에 여러 프로세스를 로드하는 방식(멀티프로그래밍)**:
    
    - 짧은 시간 동안 한 프로세스를 실행합니다.
    - 메모리 내에서 프로세스 간에 전환합니다.
    - 이용률과 효율성을 증가시킵니다.
- **중요한 보호 문제를 야기합니다**:
    
    - 다른 프로세스로부터의 잘못된 메모리 접근 문제가 발생할 수 있습니다.
![[Pasted image 20240421012203.png]]
멀티프로그래밍 방식은 시스템의 리소스 활용도를 높이며, 동시에 여러 작업을 처리할 수 있게 해줍니다. 그러나 이 방식은 다른 프로세스로부터의 부적절한 메모리 접근을 막기 위한 추가적인 보호 조치가 필요하며, 이는 시스템의 보안과 안정성을 유지하는 데 중요한 요소입니다.

### 오버레이 (Overlays)

- **오버레이는 메모리에 필요한 시점에 필요한 지시사항과 데이터만을 유지하는 기술입니다**.
- **필요할 때 다른 지시사항이 로드되며, 이전에 더 이상 필요하지 않은 지시사항이 차지했던 공간을 사용합니다**.
- **사용자에 의해 구현되며, 운영체제로부터 특별한 지원이 필요 없습니다. 하지만 오버레이 구조의 프로그래밍 설계는 복잡합니다**.
![[Pasted image 20240421012240.png]]
### 주소 공간

- **운영체제는 물리적 메모리의 추상화를 생성합니다**.
    - 주소 공간은 실행 중인 프로세스에 관한 모든 것을 포함합니다.
    - 프로그램 코드, 힙, 스택 등이 이에 포함됩니다.
![[Pasted image 20240421012245.png]]
#### 구성 요소

- **코드 (Code)**:
    - 명령어가 저장되는 곳입니다.
- **힙 (Heap)**:
    - 동적으로 메모리를 할당합니다.
        - C 언어에서는 `malloc`, 객체지향 언어에서는 `new`를 사용합니다.
- **스택 (Stack)**:
    - 반환 주소나 값들을 저장합니다.
    - 루틴에 대한 로컬 변수와 인수들을 포함합니다.

### 주소 공간 확장

- **주소 공간은 모든 주소 가능한 메모리를 캡슐화합니다**.
- **시스템은 일정량의 물리적 메모리를 가지고 있으며, 이는 사용 가능한 물리적 메모리로 결과됩니다**.
- **간단히 말해, 각 주소는 바이트를 가리킨다고 가정합니다**.
- **가상 주소 공간과 물리적 주소 공간의 크기는 서로 다를 수 있습니다**.
- **실제 존재하는 메모리는 물리적 주소 공간 크기와 같거나 작습니다**.
- **예시**: 현대의 64비트 CPU는 48비트 가상 주소 공간을 가지고 있으며(64비트 포인터 사용), 48비트의 물리적 주소 공간에 매핑됩니다. 대부분의 기계는 256 TiB(2^40) 미만의 메모리를 가지고 있습니다.

이러한 개념들은 메모리 관리와 시스템의 효율적인 작동을 위해 중요하며, 프로그램의 성능 최적화와 자원 사용 최소화에 기여합니다.


### 가상 주소

- **실행 중인 모든 프로그램의 주소는 가상 주소입니다**.
    - 운영체제는 가상 주소를 물리적 주소로 변환합니다.

이는 운영체제가 가상 메모리 시스템을 통해 각 프로세스에 독립된 주소 공간을 제공하며, 실제 메모리 위치와는 독립적으로 작동할 수 있게 하는 기능입니다. 이로 인해 프로그램은 더 큰 메모리를 사용하는 것처럼 작동할 수 있으며, 프로세스 간 메모리 충돌 없이 안전하게 실행될 수 있습니다.

![[Pasted image 20240421012253.png]]


### 함수 호출 프레임

- **함수를 호출할 때 호출 프레임이 할당되어 모든 지역 변수와 호출한 함수로 돌아갈 때 필요한 컨텍스트를 저장합니다**.

### `called` 함수의 호출 프레임에 저장되는 데이터

- **int형 `tmp`를 위한 슬롯**
- **파라미터 `a`, `b`를 위한 슬롯**
- **반환 코드 포인터(RIP)를 위한 슬롯**
- **대부분의 ABI(Application Binary Interface, 응용 프로그램 이진 인터페이스)에서의 순서**: `b`, `a`, `RIP`, `tmp`

### 컴파일러 및 스택 작업

- **컴파일러는 ABI에 따라 필요한 코드를 생성합니다**.
- **스택은 함수 호출 프레임의 간단한 저장을 가능하게 합니다**:
    - 호출 컨텍스트와 활성화된 상위 프레임의 순서를 저장합니다.
    - 함수 프롤로그에서 메모리가 할당되고, 반환 시 해제됩니다.

### 함수 반환 시 데이터 처리

- **함수가 반환된 후, 이전 함수의 데이터가 남아 있으며, 다음 함수가 데이터를 초기화할 때 덮어쓰여집니다**.

이러한 방식으로 함수 호출 프레임과 스택의 동작은 프로그램의 함수 호출 구조를 체계적으로 관리하며, 각 함수의 실행과 반환 과정에서 필요한 데이터를 효과적으로 처리합니다.

##  Heap 관리

![[Pasted image 20240421012442.png]]
![[Pasted image 20240421012455.png]]![[Pasted image 20240421012519.png]]


### 논리 주소 공간 vs. 물리 주소 공간

- **논리 주소 (Logical Address)**:
    - CPU에 의해 생성되며, 가상 주소라고도 불립니다.
- **물리 주소 (Physical Address)**:
    - 메모리 단위가 인식하는 주소입니다.

### 주소 바인딩

- **컴파일 시간과 로드 시간 주소 바인딩 스킴에서는 논리 주소와 물리 주소가 동일합니다**.
- **실행 시간 주소 바인딩 스킴에서는 논리(가상) 주소와 물리 주소가 다릅니다**.

### 주소 변환 (Address Translation)

- **하드웨어는 가상 주소를 물리 주소로 변환합니다**:
    - 실제로 원하는 정보는 물리 주소에 저장됩니다.
- **운영체제는 하드웨어를 설정하기 위해 핵심적인 시점에 개입해야 합니다**:
    - 운영체제는 메모리를 현명하게 관리하여 개입해야 합니다.
- **운영체제는 프로세스를 물리 메모리의 0번 주소가 아닌 다른 곳에 배치하고자 합니다 (재배치 주소 공간)**:
    - 주소 공간은 0번 주소에서 시작합니다.

이러한 주소 구조와 변환 방식은 운영체제가 메모리 리소스를 효율적으로 관리하고, 프로세스가 물리적 메모리 어디에 위치하든 독립적으로 실행될 수 있도록 하는 데 중요한 역할을 합니다.

### 메모리 관리 유닛 (Memory-Management Unit, MMU)

- **MMU는 하드웨어 장치로, 가상 주소를 물리 주소로 매핑합니다**.
- **MMU 스킴에서는 재배치 레지스터의 값이 사용자 프로세스에 의해 생성된 모든 주소에 메모리로 보내질 때 추가됩니다**.
- **사용자 프로그램은 논리 주소를 다루며, 실제 물리 주소를 볼 수 없습니다**.

이 구조는 사용자 프로세스가 시스템의 실제 물리적 구조를 알 필요 없이 메모리 주소를 자유롭게 사용할 수 있도록 해줍니다. MMU는 가상 메모리 시스템의 핵심 구성 요소로, 프로그램이 물리 메모리의 위치에 구애받지 않고, 더 큰 메모리 공간을 사용하는 것처럼 작업할 수 있도록 지원합니다. 이러한 방식으로 메모리 접근과 프로세스 관리의 효율성이 크게 향상됩니다.

## 재배치
![[Pasted image 20240421012731.png]]


### 다이내믹(하드웨어 기반) 재배치

- **프로그램 실행 시점**:
    - 운영체제는 프로세스를 물리 메모리의 어디에 로드할지 결정합니다.
    - 베이스 레지스터에 값을 설정합니다.
    - 모든 가상 주소는 범위를 초과하지 않고 음수가 아니어야 합니다.
- **주소 변환 공식**:
    - 물리 주소 = 가상 주소 + 베이스
    - 0 ≤ 가상 주소 < 범위

### 메모리 가상화를 위한 운영체제의 문제

- **중요 시점 세 가지**:
    1. **프로세스 시작 시**:
        - 물리 메모리에서 주소 공간을 위한 공간을 찾습니다.
    2. **프로세스 종료 시**:
        - 사용을 위해 메모리를 다시 확보합니다.
    3. **컨텍스트 스위치 발생 시**:
        - 베이스-앤-바운드 쌍을 저장하고 복원합니다.

### 운영체제 문제: 상세 설명

- **프로세스가 실행을 시작할 때**:
    - 운영체제는 새로운 주소 공간을 위한 공간을 찾아야 합니다.
    - 자유 목록: 사용되지 않는 물리 메모리 범위의 목록.
![[Pasted image 20240421131011.png]]
- **프로세스가 종료될 때**:
    - 운영체제는 메모리를 자유 목록에 다시 올려야 합니다.
![[Pasted image 20240421131034.png]]

- **컨텍스트 스위치가 발생할 때**:
    - 운영체제는 베이스-앤-바운드 쌍을 프로세스 구조 또는 프로세스 제어 블록(PCB)에 저장하고 복원해야 합니다.
![[Pasted image 20240421131020.png]]