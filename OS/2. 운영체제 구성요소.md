배치 시스템은 컴퓨터가 하나의 응용 프로그램만 실행하는 시스템입니다. 여기서는 간단한 배치 시스템에 대한 설명이 포함되어 있습니다:

### 간단한 배치 시스템

- **운영자 고용**: 사용자와 운영자가 다르며, 운영자가 시스템을 관리합니다. 사용자는 시스템과 직접 상호작용하지 않습니다.
- **카드 리더 추가**: 작업 제어를 위해 카드 리더기를 사용합니다. 이는 작업을 제출할 때 사용되는 제어 카드를 읽어들여 처리합니다.
- **유사 작업의 배치로 설정 시간 감소**: 비슷한 작업들을 모아 한 번에 처리함으로써 전체 작업의 설정 시간을 줄입니다.
- **자동 작업 순서화**: 한 작업에서 다른 작업으로 자동으로 제어를 이전합니다. 이는 최초의 기초적인 운영 체제의 형태 중 하나입니다.
- **레지던트 모니터**: 모니터에서 초기 제어를 시작하여 작업으로 제어를 이전하고, 작업이 완료되면 다시 모니터로 제어가 이전됩니다.

이러한 시스템은 사용자와 시스템 간의 상호작용이 없이 작업이 순차적으로 처리되는 것이 특징입니다. 초기 컴퓨팅 환경에서 자주 사용되었으며, 작업을 효율적으로 처리하기 위한 여러 메커니즘이 도입되었습니다.


## 멀티프로그래밍 배치 시스템
### 멀티프로그램 배치 시스템의 특징

- **주 메모리에 여러 작업 동시 유지**: 주 메모리에 여러 작업이 동시에 유지되며, CPU는 이들 작업 사이에서 다중화되어 사용됩니다. 이는 CPU 스케줄링 및 작업 스케줄링을 통해 이루어집니다.

### 멀티프로그래밍을 위해 필요한 운영 체제의 기능

- **시스템 제공 I/O 루틴**: 시스템이 입출력 처리 루틴을 제공하여, 개별 작업이 직접 입출력 장치를 관리하지 않아도 됩니다.
- **메모리 관리**: 시스템은 여러 작업에 메모리를 할당해야 합니다. 이는 작업 간에 메모리가 효율적으로 분배되고 관리되어야 함을 의미합니다.
- **CPU(또는 작업) 스케줄링**: 준비 상태에 있는 여러 작업 중에서 실행할 작업을 선택해야 합니다. 이 과정은 시스템의 효율성을 극대화하기 위해 중요합니다.
- **장치 할당**: 시스템은 연결된 입출력 장치들을 여러 작업에 효과적으로 할당하고 관리해야 합니다.

멀티프로그램 배치 시스템은 여러 작업을 효율적으로 관리하고 CPU 사용률을 최대화하여 시스템의 전체 처리량을 증가시키는 것을 목표로 합니다. 이는 단일 작업 시스템에 비해 훨씬 복잡한 운영 체제 기능을 요구합니다.


## 시분할 시스템

### 시분할 시스템의 특징

- **여러 작업에 CPU 다중 할당**: CPU는 메모리와 디스크에 유지되는 여러 작업 사이에서 다중화되어 사용됩니다. CPU는 작업이 메모리에 있을 때만 해당 작업에 할당됩니다.
- **동시 다중 사용자 접근**: 여러 사용자가 터미널을 통해 시스템에 동시에 접근할 수 있습니다.

### 온라인 시스템

- **사용자 데이터 및 코드 접근 가능**: 온라인 시스템은 사용자가 데이터와 코드에 접근할 수 있도록 항상 사용 가능해야 합니다.

### 메모리와 디스크 간 작업 스왑

- **메모리와 디스크 간 작업 교환**: 작업은 필요에 따라 메모리와 디스크 사이에서 스왑됩니다.

### 처리자 시간 공유

- **프로세서의 시간은 여러 사용자 간에 공유됩니다**: 이는 각 사용자가 시스템 리소스를 공정하게 사용할 수 있도록 보장합니다.

### 응답 시간

- **명령 제출과 결과 반환 사이의 지연**: 사용자가 명령을 제출하고 그 결과를 받는 사이의 시간 지연을 응답 시간이라고 합니다. 이는 사용자의 경험에 직접적인 영향을 미치는 중요한 요소입니다.

시분할 시스템은 컴퓨터의 자원을 효율적으로 분배하고, 여러 사용자가 시스템에 동시에 접근하면서 각자의 작업을 수행할 수 있게 하는 현대적 컴퓨팅 모델입니다. 이 시스템은 사용자에게 빠른 응답 시간과 효율적인 자원 사용을 제공하여, 대화형 컴퓨팅 환경을 가능하게 합니다.


## 멀티프로그래밍 VS 시분할 시스템

![[Pasted image 20240419222538.png]]

## OS 구조

![[Pasted image 20240419222446.png]]


## OS의 설계 목표

- **추상화 구축**: 시스템을 사용하기 편리하고 쉽게 만듭니다. 이를 통해 사용자는 복잡한 하드웨어 세부 정보를 신경 쓰지 않고 작업을 수행할 수 있습니다.
    
- **고성능 제공**:
    
    - 운영 체제의 오버헤드를 최소화합니다.
    - OS는 과도한 부하 없이 가상화를 제공하기 위해 노력해야 합니다.
- **응용 프로그램 간 보호**:
    
    - 격리: 한 프로그램의 잘못된 동작이 다른 프로그램이나 OS 자체에 해를 끼치지 않도록 합니다.
- **높은 신뢰도**:
    
    - OS는 중단 없이 지속적으로 실행되어야 합니다.
- **기타 고려 사항**:
    
    - 에너지 효율성: OS는 에너지 소비를 최소화하는 방향으로 설계되어야 합니다.
    - 보안: 시스템과 데이터를 보호하기 위해 강력한 보안 기능을 제공해야 합니다.
    - 이동성: 모바일 기기에서도 효과적으로 작동할 수 있도록 설계되어야 합니다.

이러한 목표들은 OS가 효율적이고 안정적으로 작동하여 다양한 환경에서 사용자의 요구를 충족시키기 위한 것입니다. 이를 통해 OS는 다양한 응용 프로그램과 서비스를 지원하면서 사용자 경험을 개선할 수 있습니다.

## OS Building Block
### Security(보안)
### 보호

- **보호**: 운영 시스템에 의해 정의된 자원에 대한 프로세스 또는 사용자의 접근을 제어하는 메커니즘입니다. 이는 자원 사용 권한을 관리하여 안정적인 시스템 운영을 지원합니다.

### 보안

- **보안**: 시스템을 내부 및 외부 공격으로부터 방어하는 것을 말합니다. 공격 유형에는 서비스 거부(DoS), 웜, 바이러스, 신원 도용, 서비스 도용 등이 포함됩니다.

### 사용자 식별 및 접근 제어

- **사용자 식별**: 시스템은 먼저 사용자를 구별하여 각 사용자가 무엇을 할 수 있는지 결정합니다. 사용자 신원(ID)에는 이름과 각 사용자별로 부여된 번호(보안 ID)가 포함됩니다.
- **접근 제어 연결**: 사용자 ID는 해당 사용자의 모든 파일과 프로세스와 연결되어 접근 제어를 결정합니다.
- **그룹 식별자**: 사용자 집단을 정의하고 관리할 수 있게 하는 그룹 ID를 통해, 파일이나 프로세스마다 그룹에 대한 접근 권한을 관리합니다.
- **권한 상승**: 사용자가 더 많은 권리를 가진 유효 ID로 변경할 수 있는 권한을 부여받습니다.

이러한 보호 및 보안 메커니즘은 시스템의 안정성과 사용자의 데이터를 보호하는 데 중요한 역할을 합니다.
### Virtualization(가상화)
- **물리적 자원을 가상 형태로 변환**: OS는 프로세서, 메모리, 디스크 등의 물리적 자원을 가상 형태로 변환합니다.
- **자원의 독립적 활용**: 각 응용 프로그램은 자신만의 자원을 독점적으로 사용하는 것처럼 인식합니다. 예를 들어, CPU에서는 무제한 명령 실행, 메모리에서는 무제한 메모리(바이트 배열)가 제공된 것처럼 작동합니다.
- **도전 과제**: 제한된 자원의 공유 방법을 찾는 것이 핵심적인 도전 과제입니다.
### Concurrency(동시성)
- **동시 발생 이벤트 처리**: OS는 동시에 발생하는 이벤트를 처리하고 필요에 따라 이를 정리해야 합니다.
- **동시성 관리**: 독립적인 프로세스에서는 동시성을 숨기고, 의존적인 프로세스에서는 동기화와 통신 원시 기능을 제공하여 동시성을 관리합니다.
- **도전 과제**: 적절한 원시 기능을 제공하는 것입니다.
### Persistence(지속성)
- **정보의 지속성**: 정보의 수명이 프로세스의 수명보다 길어야 합니다.
- **비휘발성 정보 접근**: 프로세스가 비휘발성 정보에 접근할 수 있도록 지원합니다.
- **데이터 저장 추상화**: 파일 시스템을 통해 데이터가 어떻게 저장되는지 추상화합니다.
- **내성 확보**: 전원 손실 등의 실패에도 견딜 수 있도록 설계합니다.
- **접근 제어**: 접근 제어를 제공합니다.
- **도전 과제**: 인증과 권한 부여 방법입니다.


## 프로세스 관리
### 프로세스의 정의

- **프로세스**: 실행 중인 프로그램을 의미하며, 시스템 내에서 작업의 단위로 취급됩니다. 프로그램은 수동적인 존재이며, 프로세스는 활동적인 존재입니다.

### 프로세스의 자원 요구

- **필요한 자원**: 프로세스는 자신의 작업을 수행하기 위해 CPU, 메모리, 입출력 장치, 파일 및 초기화 데이터와 같은 자원이 필요합니다.

### 프로세스 종료

- **자원 회수**: 프로세스가 종료될 때 재사용 가능한 모든 자원을 회수해야 합니다.

### 단일 스레드 프로세스

- **프로그램 카운터**: 단일 스레드 프로세스는 다음에 실행할 명령의 위치를 지정하는 하나의 프로그램 카운터를 가집니다.
- **순차 실행**: 프로세스는 명령을 하나씩 순차적으로 실행하며, 작업이 완료될 때까지 이를 계속합니다.

### 멀티 스레드 프로세스

- **멀티 프로그램 카운터**: 멀티 스레드 프로세스는 스레드마다 하나의 프로그램 카운터를 가지고 있습니다.

### 시스템의 프로세스

- **프로세스의 동시 실행**: 시스템은 일반적으로 많은 프로세스들을 가지고 있으며, 이들은 하나 이상의 CPU에서 동시에 실행됩니다.
- **CPU의 다중화**: 프로세스 또는 스레드 사이에서 CPU를 다중화하여 동시성을 달성합니다.

이러한 개념들은 프로세스가 시스템 내에서 어떻게 관리되고, 다양한 자원을 효율적으로 사용하며, 시스템의 전반적인 성능에 기여하는지를 보여줍니다.


## 메모리 관리
### 메모리 관리의 기본

- **메모리 데이터 관리**: 모든 데이터는 처리 전후에 메모리에 있어야 합니다.
- **명령 실행을 위한 메모리 저장**: 모든 실행 명령은 메모리에 있어야 합니다.
- **메모리 관리의 역할**: 메모리 관리는 언제 어떤 데이터나 프로그램이 메모리에 있어야 하는지 결정합니다. 이는 CPU 활용 최적화 및 사용자 반응 속도 향상에 기여합니다.

### 메모리 관리 활동

- **메모리 사용 추적**: 현재 메모리의 어느 부분이 사용 중인지, 누가 사용하고 있는지 추적합니다.
- **메모리 입출력 결정**: 어떤 프로세스(또는 그 일부)와 데이터를 메모리로 옮기거나 메모리에서 제거할지 결정합니다.
- **메모리 공간 할당 및 해제**: 필요에 따라 메모리 공간을 할당하고 해제합니다.

이러한 메모리 관리 기법은 시스템의 효율적인 운영을 보장하며, 다양한 프로세스가 메모리 자원을 공정하게 사용할 수 있도록 합니다. 메모리 관리는 시스템의 성능과 사용자 경험에 직접적인 영향을 미치는 중요한 컴퓨터 시스템 관리의 한 분야입니다.


## 저장관리
### 저장 관리의 기본

- **운영 시스템의 역할**: 운영 시스템은 정보 저장에 대한 일관되고 논리적인 관점을 제공합니다.
- **물리적 특성의 추상화**: 운영 시스템은 물리적 특성을 논리적 저장 단위인 파일로 추상화합니다.
- **저장 매체 관리**: 각 저장 매체는 해당 장치(예: 디스크 드라이브, 테이프 드라이브)에 의해 제어됩니다. 저장 매체의 특성에는 접근 속도, 용량, 데이터 전송률, 접근 방식(순차적 또는 무작위) 등이 포함됩니다.

### 파일 시스템 관리

- **파일 조직**: 파일은 대부분의 시스템에서 디렉토리로 조직됩니다.
- **접근 제어**: 대부분의 시스템에서 누가 무엇에 접근할 수 있는지 결정하기 위해 접근 제어를 사용합니다.
- **운영 시스템 활동**:
    - 파일 및 디렉토리 생성 및 삭제
    - 파일 및 디렉토리를 조작하기 위한 기본 기능 제공
    - 파일을 보조 저장소에 매핑
    - 파일을 안정적인(비휘발성) 저장 매체에 백업

이러한 저장 관리 기능은 운영 시스템이 정보를 효과적으로 저장하고 관리할 수 있도록 지원하며, 사용자와 시스템의 데이터 보안 및 접근성을 향상시키는 데 중요한 역할을 합니다.

## 대용량 저장관리
### 대용량 저장 관리의 기본

- **디스크 사용**: 데이터가 주 메모리에 들어갈 수 없거나 오랜 기간 동안 보관해야 할 경우 일반적으로 디스크가 사용됩니다.
- **컴퓨터 작업 속도**: 컴퓨터 작업의 전체 속도는 디스크 하위 시스템과 그 알고리즘에 크게 의존합니다.

### 운영 시스템 활동

- **공간 관리**: 사용하지 않는 공간을 효율적으로 관리합니다.
- **저장 공간 할당**: 필요에 따라 데이터 저장 공간을 할당합니다.
- **디스크 스케줄링**: 디스크 액세스 요청을 효율적으로 처리하기 위해 디스크 작업을 스케줄합니다.

### 느린 저장 매체

- **3차 저장 장치**: 광 저장 매체와 자기 테이프 등이 포함됩니다. 이러한 저장 매체는 빠른 속도로 데이터에 접근할 필요가 없는 경우에 사용됩니다.
- **관리 필요**: 이러한 매체도 관리가 필요하며, WORM(한 번 쓰고 여러 번 읽기)과 RW(읽기 및 쓰기) 사이에서 다양합니다.

이러한 대용량 저장 관리 기능은 데이터를 효과적으로 저장하고 접근성을 유지하는 데 중요하며, 시스템의 전반적인 성능과 효율성에 영향을 미칩니다.

## 입출력 서브 시스템
### I/O 서브시스템의 책임

- **I/O의 메모리 관리**: 데이터가 전송되는 동안 일시적으로 데이터를 저장하는 버퍼링, 성능 향상을 위해 더 빠른 저장소에 데이터 일부를 저장하는 캐싱, 한 작업의 출력과 다른 작업의 입력이 중첩되는 스풀링 등을 포함합니다.
- **일반 디바이스 드라이버 인터페이스**: 다양한 하드웨어 장치와 통신하기 위한 일반적인 드라이버 인터페이스를 제공합니다.
- **특정 하드웨어 장치의 드라이버**: 특정 하드웨어 장치를 관리하기 위한 드라이버를 제공합니다.

### 주요 기능

- **버퍼링**: 입출력 작업 중 데이터를 일시적으로 메모리에 저장하여, 데이터 전송이 물리적 장치의 속도를 기다리지 않도록 합니다.
- **캐싱**: 자주 사용되는 데이터를 더 빠른 접근이 가능한 메모리에 저장함으로써 성능을 향상시킵니다.
- **스풀링**: 출력 작업과 입력 작업을 중첩시켜, 한 작업이 종료되기를 기다리지 않고 다른 작업을 시작할 수 있게 합니다.

I/O 서브시스템은 시스템의 효율성을 극대화하고, 다양한 입출력 장치들의 효과적인 관리를 가능하게 하는 중요한 역할을 수행합니다.