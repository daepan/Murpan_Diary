### 프로세스 간 통신 (IPC)

- **독립적인 프로세스와 협력적인 프로세스**:
    
    - **독립적인 프로세스**: 다른 프로세스의 실행에 영향을 받지 않으며 영향을 미치지도 않습니다.
    - **협력적인 프로세스**: 다른 프로세스의 실행에 영향을 주거나 받을 수 있습니다.
- **협력적인 프로세스의 이유**:
    
    - 정보 공유
    - 계산 속도 향상
    - 모듈성
    - 편리성
- **협력적인 프로세스를 위한 필요성**:
    
    - 프로세스 간 통신(IPC)이 필요합니다.
- **IPC의 두 가지 모델**:
    
    - **공유 메모리**: 프로세스들이 접근할 수 있는 공유 메모리 영역을 사용하여 데이터를 교환합니다.
    - **메시지 전달**: 프로세스들이 메시지를 주고받는 방식으로 데이터를 교환합니다. 이 방법은 데이터를 명시적으로 메시지 형태로 보내고 받는 구조를 사용합니다.

이러한 IPC 기법들은 프로세스들이 서로 협력하여 작업을 수행하고, 시스템 전체의 효율성과 기능을 향상시키는 데 기여합니다.

![[Pasted image 20240420221137.png]]


## 생산자-소비자 문제

- **협력 프로세스를 위한 패러다임**:
    
    - 생산자 프로세스가 정보를 생산하고, 이 정보는 소비자 프로세스에 의해 소비됩니다.
- **버퍼 공유**:
    
    - 두 프로세스는 버퍼를 공유합니다.
- **무제한 버퍼(unbounded-buffer)**:
    
    - 버퍼의 크기에 실질적인 제한이 없습니다.
    - 생산자는 항상 새로운 아이템을 생산할 수 있습니다.
    - 소비자는 새로운 아이템을 기다려야 할 수 있습니다.
- **유한 버퍼(bounded-buffer)**:
    
    - 버퍼의 크기가 고정되어 있습니다.
    - 생산자는 버퍼가 가득 찼을 경우 생산을 기다려야 합니다.
    - 소비자는 버퍼가 비어 있을 경우 소비를 기다려야 합니다.

이 문제는 운영 체제에서 프로세스 간 동기화 및 통신을 다루는 중요한 예시 중 하나로, 다양한 동기화 기법을 통해 해결될 수 있습니다. 생산자와 소비자 간의 상호 작용을 관리하여 시스템의 전체적인 효율성을 유지합니다.

생산자-소비자 문제에 대한 유한 버퍼를 사용한 공유 메모리 해결 방식을 나타냅니다. 여기서 `BUFFER_SIZE`는 버퍼의 크기를 정의합니다. 다음은 코드의 각 부분에 대한 설명입니다:

생산자-소비자 문제에 대한 유한 버퍼를 사용한 공유 메모리 해결 방식을 나타냅니다. 여기서 `BUFFER_SIZE`는 버퍼의 크기를 정의합니다. 다음은 코드의 각 부분에 대한 설명입니다:

### 공유 데이터

cCopy code

```c
#define BUFFER_SIZE 10 
typedef struct {     
// 구조체 정의 내용이 생략되어 있음 

} 
item; item buffer[BUFFER_SIZE];
int in = 0;  
int out = 0;
```

- `BUFFER_SIZE`는 버퍼의 최대 크기를 정의합니다.
- `item`은 버퍼에 저장될 아이템의 데이터 타입을 정의하는 구조체입니다.
- `buffer`는 `item` 타입의 배열로, 데이터를 저장하는 데 사용됩니다.
- `in`과 `out`은 각각 버퍼의 삽입 위치와 삭제 위치를 추적하는 인덱스입니다.

### 생산자 프로세스


```c
while(1) 
{     
  while(((in+1)%BUFFER_SIZE) == out); 
	/* 아무 것도 하지 않음 */   
	buffer[in] = nextProduced;
	in = (in + 1) % BUFFER_SIZE; 
}
```

- 생산자는 무한 루프를 통해 지속적으로 데이터를 생산하고 버퍼에 삽입합니다.
- `while(((in+1)%BUFFER_SIZE) == out)`은 버퍼가 가득 찼는지 확인하는 조건입니다. 버퍼가 가득 차면, 즉 `in` 다음 위치가 `out`과 같아지면, 루프 내에서 아무 작업도 하지 않고 대기합니다.
- `buffer[in] = nextProduced;`는 새로 생성된 아이템을 버퍼의 현재 `in` 위치에 삽입합니다.
- `in = (in + 1) % BUFFER_SIZE;`는 `in` 위치를 순환시켜 업데이트합니다.

### 소비자 프로세스

```c
while(1) {
    while(in == out)
        ; /* 아무 것도 하지 않음 */
    nextConsumed = buffer[out];
    out = (out + 1) % BUFFER_SIZE;
}
```

- 소비자 역시 무한 루프를 통해 지속적으로 데이터를 소비합니다.
- `while(in == out)`은 버퍼가 비어 있는지 확인하는 조건입니다. 버퍼가 비어 있으면, 즉 `in`과 `out`이 같아지면, 루프 내에서 아무 작업도 하지 않고 대기합니다.
- `nextConsumed = buffer[out];`는 버퍼에서 현재 `out` 위치의 아이템을 소비합니다.
- `out = (out + 1) % BUFFER_SIZE;`는 `out` 위치를 순환시켜 업데이트합니다.

이 코드는 버퍼의 크기를 10으로 설정하고, 생산자와 소비자가 동일한 버퍼에서 작업을 수행할 수 있도록 하는 간단한 예제를 보여줍니다.

### 메시지 시스템

- 프로세스들은 공유 변수를 사용하지 않고 서로 통신할 수 있습니다.

### IPC 기능

- **두 가지 작업 제공**:
    - `send(message)`: 메시지를 보냅니다. 메시지 크기는 고정되거나 가변적일 수 있습니다.
    - `receive(message)`: 메시지를 받습니다.

- **통신을 원하는 두 프로세스 P와 Q**:
    - 서로 간의 통신 링크를 설정해야 합니다.
    - `send/receive`를 통해 메시지를 교환해야 합니다.

### 통신 링크의 구현

- **물리적 구현**: 예를 들어, 공유 메모리, 하드웨어 버스 등
- **논리적 구현**: 논리적 특성 등

### 구현 질문

1. **링크는 어떻게 설정되나요?**
    - 링크 설정은 통신하는 프로세스 간의 연결 방식을 정의합니다. 이는 프로그래밍적으로 명시적으로 정의될 수 있으며, 시스템 호출을 통해 링크를 초기화하고 구성하는 과정을 포함할 수 있습니다.
2. **링크는 두 개 이상의 프로세스와 연결될 수 있나요?**
    - 링크가 두 개 이상의 프로세스와 연결될 수 있는지 여부는 IPC 설계에 따라 다릅니다. 일부 시스템은 다대다 통신을 지원하기 위해 하나의 링크가 여러 프로세스를 연결할 수 있도록 합니다.
3. **통신하는 각 쌍의 프로세스 사이에 몇 개의 링크가 있을 수 있나요?**
    - 프로세스 쌍 사이에 여러 링크를 설정할 수 있는지는 IPC의 설계에 따라 달라집니다. 이는 통신의 복잡성과 효율성을 증가시킬 수 있습니다.
4. **링크의 용량은 어떻게 되나요?**
    - 링크의 용량은 동시에 전송할 수 있는 데이터의 양을 나타냅니다. 이는 링크의 기술적 구현과 시스템의 자원에 의존적입니다.
5. **링크가 수용할 수 있는 메시지 크기는 고정인가요, 아니면 가변적인가요?**
    - 메시지 크기가 고정인지 가변적인지는 IPC 메커니즘에 따라 다릅니다. 일부 시스템은 고정된 크기의 메시지만 처리할 수 있으며, 다른 시스템은 가변 크기의 메시지를 지원할 수 있습니다.
6. **링크는 단방향인가요, 아니면 양방향인가요?**
    - 링크가 단방향인지 양방향인지는 통신 프로토콜과 링크의 구현에 달려 있습니다. 양방향 링크는 양쪽 방향으로 데이터를 전송할 수 있습니다.

### 논리적 구현 이슈

1. **직접 또는 간접 통신**
    - 직접 통신은 프로세스가 서로를 명확히 지칭하여 통신하는 방식이고, 간접 통신은 메시지 큐 또는 버퍼와 같은 중간 엔티티를 통해 이루어집니다.
2. **대칭적 또는 비대칭적 통신**
    
    - 대칭적 통신은 모든 프로세스가 동일한 역할과 권한을 가진 상태에서 통신하는 것을 말하고, 비대칭적 통신은 통신하는 프로세스 간에 역할이나 권한에 차이가 있을 때 사용됩니다.
3. **자동 또는 명시적 버퍼링**
    
    - 자동 버퍼링은 시스템이 자동으로 메시지를 버퍼링하는 것을 말하고, 명시적 버퍼링은 프로그래머가 직접 버퍼링 과정을 제어하는 것을 말합니다.
4. **복사에 의한 전송 또는 참조에 의한 전송**
    
    - 복사에 의한 전송은 데이터를 메시지로 복사하여 전송하는 것이고, 참조에 의한 전송은 데이터에 대한 참조만을 전송하는 방식입니다.
5. **고정 크기 또는 가변 크기 메시지**
    
    - 이는 링크가 처리할 수 있는 메시지의 크기가 고정되어 있는지, 아니면 유동적으로 변할 수 있는지를 나타냅니다.

이러한 설명들은 프로세스 간 통신(IPC)이 어떻게 구성되고, 어떤 이슈들을 고려해야 하는지를 보여줍니다. 프로세스 간 효율적인 데이터 교환을 가능하게 하는 다양한 메커니즘과 방법론에 대한 이해를 돕습니다.

### 직접 통신

- **프로세스는 서로를 명시적으로 지정해야 합니다**:
    - `send(P, message)`: 프로세스 P에게 메시지를 보냅니다.
    - `receive(Q, message)`: 프로세스 Q로부터 메시지를 받습니다.

### 통신 링크의 특성

- **링크는 자동으로 설정됩니다**:
    - 통신을 위해 프로세스는 서로의 신원만 알고 있으면 됩니다.
- **링크는 정확히 한 쌍의 통신하는 프로세스와 연결됩니다**:
    - 두 프로세스 간에만 연결됩니다.
- **각 프로세스 쌍 사이에는 정확히 하나의 링크가 존재합니다**:
    - 하나의 쌍에는 오직 하나의 통신 경로만 설정됩니다.
- **링크는 단방향일 수 있지만, 보통은 양방향입니다**:
    - 대부분의 경우 통신은 양방향으로 이루어집니다.

이러한 직접 통신 방식은 통신하는 프로세스들이 서로를 명확하게 식별하고, 그에 따라 메시지를 주고받는 방식을 특징으로 합니다. 이는 간단하고 명확한 통신 방법을 제공하지만, 통신할 대상을 미리 알아야 하는 제한이 있습니다.