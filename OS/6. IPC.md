### 프로세스 간 통신 (IPC)

- **독립적인 프로세스와 협력적인 프로세스**:
    
    - **독립적인 프로세스**: 다른 프로세스의 실행에 영향을 받지 않으며 영향을 미치지도 않습니다.
    - **협력적인 프로세스**: 다른 프로세스의 실행에 영향을 주거나 받을 수 있습니다.
- **협력적인 프로세스의 이유**:
    
    - 정보 공유
    - 계산 속도 향상
    - 모듈성
    - 편리성
- **협력적인 프로세스를 위한 필요성**:
    
    - 프로세스 간 통신(IPC)이 필요합니다.
- **IPC의 두 가지 모델**:
    
    - **공유 메모리**: 프로세스들이 접근할 수 있는 공유 메모리 영역을 사용하여 데이터를 교환합니다.
    - **메시지 전달**: 프로세스들이 메시지를 주고받는 방식으로 데이터를 교환합니다. 이 방법은 데이터를 명시적으로 메시지 형태로 보내고 받는 구조를 사용합니다.

이러한 IPC 기법들은 프로세스들이 서로 협력하여 작업을 수행하고, 시스템 전체의 효율성과 기능을 향상시키는 데 기여합니다.

![[Pasted image 20240420221137.png]]


## 생산자-소비자 문제

- **협력 프로세스를 위한 패러다임**:
    
    - 생산자 프로세스가 정보를 생산하고, 이 정보는 소비자 프로세스에 의해 소비됩니다.
- **버퍼 공유**:
    
    - 두 프로세스는 버퍼를 공유합니다.
- **무제한 버퍼(unbounded-buffer)**:
    
    - 버퍼의 크기에 실질적인 제한이 없습니다.
    - 생산자는 항상 새로운 아이템을 생산할 수 있습니다.
    - 소비자는 새로운 아이템을 기다려야 할 수 있습니다.
- **유한 버퍼(bounded-buffer)**:
    
    - 버퍼의 크기가 고정되어 있습니다.
    - 생산자는 버퍼가 가득 찼을 경우 생산을 기다려야 합니다.
    - 소비자는 버퍼가 비어 있을 경우 소비를 기다려야 합니다.

이 문제는 운영 체제에서 프로세스 간 동기화 및 통신을 다루는 중요한 예시 중 하나로, 다양한 동기화 기법을 통해 해결될 수 있습니다. 생산자와 소비자 간의 상호 작용을 관리하여 시스템의 전체적인 효율성을 유지합니다.

생산자-소비자 문제에 대한 유한 버퍼를 사용한 공유 메모리 해결 방식을 나타냅니다. 여기서 `BUFFER_SIZE`는 버퍼의 크기를 정의합니다. 다음은 코드의 각 부분에 대한 설명입니다:

생산자-소비자 문제에 대한 유한 버퍼를 사용한 공유 메모리 해결 방식을 나타냅니다. 여기서 `BUFFER_SIZE`는 버퍼의 크기를 정의합니다. 다음은 코드의 각 부분에 대한 설명입니다:

### 공유 데이터

cCopy code

```c
#define BUFFER_SIZE 10 
typedef struct {     
// 구조체 정의 내용이 생략되어 있음 

} 
item; item buffer[BUFFER_SIZE];
int in = 0;  
int out = 0;
```

- `BUFFER_SIZE`는 버퍼의 최대 크기를 정의합니다.
- `item`은 버퍼에 저장될 아이템의 데이터 타입을 정의하는 구조체입니다.
- `buffer`는 `item` 타입의 배열로, 데이터를 저장하는 데 사용됩니다.
- `in`과 `out`은 각각 버퍼의 삽입 위치와 삭제 위치를 추적하는 인덱스입니다.

### 생산자 프로세스


```c
while(1) 
{     
  while(((in+1)%BUFFER_SIZE) == out); 
	/* 아무 것도 하지 않음 */   
	buffer[in] = nextProduced;
	in = (in + 1) % BUFFER_SIZE; 
}
```

- 생산자는 무한 루프를 통해 지속적으로 데이터를 생산하고 버퍼에 삽입합니다.
- `while(((in+1)%BUFFER_SIZE) == out)`은 버퍼가 가득 찼는지 확인하는 조건입니다. 버퍼가 가득 차면, 즉 `in` 다음 위치가 `out`과 같아지면, 루프 내에서 아무 작업도 하지 않고 대기합니다.
- `buffer[in] = nextProduced;`는 새로 생성된 아이템을 버퍼의 현재 `in` 위치에 삽입합니다.
- `in = (in + 1) % BUFFER_SIZE;`는 `in` 위치를 순환시켜 업데이트합니다.

### 소비자 프로세스

```c
while(1) {
    while(in == out)
        ; /* 아무 것도 하지 않음 */
    nextConsumed = buffer[out];
    out = (out + 1) % BUFFER_SIZE;
}
```

- 소비자 역시 무한 루프를 통해 지속적으로 데이터를 소비합니다.
- `while(in == out)`은 버퍼가 비어 있는지 확인하는 조건입니다. 버퍼가 비어 있으면, 즉 `in`과 `out`이 같아지면, 루프 내에서 아무 작업도 하지 않고 대기합니다.
- `nextConsumed = buffer[out];`는 버퍼에서 현재 `out` 위치의 아이템을 소비합니다.
- `out = (out + 1) % BUFFER_SIZE;`는 `out` 위치를 순환시켜 업데이트합니다.

이 코드는 버퍼의 크기를 10으로 설정하고, 생산자와 소비자가 동일한 버퍼에서 작업을 수행할 수 있도록 하는 간단한 예제를 보여줍니다.

### 메시지 시스템

- 프로세스들은 공유 변수를 사용하지 않고 서로 통신할 수 있습니다.

### IPC 기능

- **두 가지 작업 제공**:
    - `send(message)`: 메시지를 보냅니다. 메시지 크기는 고정되거나 가변적일 수 있습니다.
    - `receive(message)`: 메시지를 받습니다.

- **통신을 원하는 두 프로세스 P와 Q**:
    - 서로 간의 통신 링크를 설정해야 합니다.
    - `send/receive`를 통해 메시지를 교환해야 합니다.

### 통신 링크의 구현

- **물리적 구현**: 예를 들어, 공유 메모리, 하드웨어 버스 등
- **논리적 구현**: 논리적 특성 등

### 구현 질문

1. **링크는 어떻게 설정되나요?**
    - 링크 설정은 통신하는 프로세스 간의 연결 방식을 정의합니다. 이는 프로그래밍적으로 명시적으로 정의될 수 있으며, 시스템 호출을 통해 링크를 초기화하고 구성하는 과정을 포함할 수 있습니다.
2. **링크는 두 개 이상의 프로세스와 연결될 수 있나요?**
    - 링크가 두 개 이상의 프로세스와 연결될 수 있는지 여부는 IPC 설계에 따라 다릅니다. 일부 시스템은 다대다 통신을 지원하기 위해 하나의 링크가 여러 프로세스를 연결할 수 있도록 합니다.
3. **통신하는 각 쌍의 프로세스 사이에 몇 개의 링크가 있을 수 있나요?**
    - 프로세스 쌍 사이에 여러 링크를 설정할 수 있는지는 IPC의 설계에 따라 달라집니다. 이는 통신의 복잡성과 효율성을 증가시킬 수 있습니다.
4. **링크의 용량은 어떻게 되나요?**
    - 링크의 용량은 동시에 전송할 수 있는 데이터의 양을 나타냅니다. 이는 링크의 기술적 구현과 시스템의 자원에 의존적입니다.
5. **링크가 수용할 수 있는 메시지 크기는 고정인가요, 아니면 가변적인가요?**
    - 메시지 크기가 고정인지 가변적인지는 IPC 메커니즘에 따라 다릅니다. 일부 시스템은 고정된 크기의 메시지만 처리할 수 있으며, 다른 시스템은 가변 크기의 메시지를 지원할 수 있습니다.
6. **링크는 단방향인가요, 아니면 양방향인가요?**
    - 링크가 단방향인지 양방향인지는 통신 프로토콜과 링크의 구현에 달려 있습니다. 양방향 링크는 양쪽 방향으로 데이터를 전송할 수 있습니다.

### 논리적 구현 이슈

1. **직접 또는 간접 통신**
    - 직접 통신은 프로세스가 서로를 명확히 지칭하여 통신하는 방식이고, 간접 통신은 메시지 큐 또는 버퍼와 같은 중간 엔티티를 통해 이루어집니다.
2. **대칭적 또는 비대칭적 통신**
    
    - 대칭적 통신은 모든 프로세스가 동일한 역할과 권한을 가진 상태에서 통신하는 것을 말하고, 비대칭적 통신은 통신하는 프로세스 간에 역할이나 권한에 차이가 있을 때 사용됩니다.
3. **자동 또는 명시적 버퍼링**
    
    - 자동 버퍼링은 시스템이 자동으로 메시지를 버퍼링하는 것을 말하고, 명시적 버퍼링은 프로그래머가 직접 버퍼링 과정을 제어하는 것을 말합니다.
4. **복사에 의한 전송 또는 참조에 의한 전송**
    
    - 복사에 의한 전송은 데이터를 메시지로 복사하여 전송하는 것이고, 참조에 의한 전송은 데이터에 대한 참조만을 전송하는 방식입니다.
5. **고정 크기 또는 가변 크기 메시지**
    
    - 이는 링크가 처리할 수 있는 메시지의 크기가 고정되어 있는지, 아니면 유동적으로 변할 수 있는지를 나타냅니다.

이러한 설명들은 프로세스 간 통신(IPC)이 어떻게 구성되고, 어떤 이슈들을 고려해야 하는지를 보여줍니다. 프로세스 간 효율적인 데이터 교환을 가능하게 하는 다양한 메커니즘과 방법론에 대한 이해를 돕습니다.

### 직접 통신

- **프로세스는 서로를 명시적으로 지정해야 합니다**:
    - `send(P, message)`: 프로세스 P에게 메시지를 보냅니다.
    - `receive(Q, message)`: 프로세스 Q로부터 메시지를 받습니다.

### 통신 링크의 특성

- **링크는 자동으로 설정됩니다**:
    - 통신을 위해 프로세스는 서로의 신원만 알고 있으면 됩니다.
- **링크는 정확히 한 쌍의 통신하는 프로세스와 연결됩니다**:
    - 두 프로세스 간에만 연결됩니다.
- **각 프로세스 쌍 사이에는 정확히 하나의 링크가 존재합니다**:
    - 하나의 쌍에는 오직 하나의 통신 경로만 설정됩니다.
- **링크는 단방향일 수 있지만, 보통은 양방향입니다**:
    - 대부분의 경우 통신은 양방향으로 이루어집니다.

이러한 직접 통신 방식은 통신하는 프로세스들이 서로를 명확하게 식별하고, 그에 따라 메시지를 주고받는 방식을 특징으로 합니다. 이는 간단하고 명확한 통신 방법을 제공하지만, 통신할 대상을 미리 알아야 하는 제한이 있습니다.

### 간접 통신

- **메일박스를 통한 메시지 전달**:
    - 메시지는 메일박스를 통해 전송되고 수신됩니다.
    - 각 메일박스는 고유한 ID를 가집니다.
    - 프로세스들은 메일박스를 공유할 때만 통신할 수 있습니다.
    - `send(A, message)`: 메일박스 A로 메시지를 보냅니다.
    - `receive(A, message)`: 메일박스 A에서 메시지를 받습니다.

### 통신 링크의 특성

- **공통 메일박스를 공유하는 경우에만 링크 설정**:
    - 여러 프로세스가 링크와 연결될 수 있습니다.
    - 각 프로세스 쌍은 여러 통신 링크를 공유할 수 있습니다.
    - 링크는 단방향 또는 양방향일 수 있습니다.

### 작업

- **새로운 메일박스 생성**
- **메일박스를 통해 메시지 보내기 및 받기**
- **메일박스 파괴**

### 메일박스 공유

- **메일박스 A를 공유하는 P1, P2, P3**:
    - P1은 메시지를 보내고, P2와 P3은 메시지를 받습니다.
    - 메시지를 누가 받을지는 어떻게 결정할까요?

### 해결책

- **링크를 최대 두 개의 프로세스와만 연결하도록 허용**.
- **한 번에 한 프로세스만 수신 작업을 수행하도록 허용**.
- **시스템이 수신자를 임의로 선택하게 허용**. 발신자는 수신자가 누구인지 통보받습니다.

### 동기화

- **메시지 전달은 차단(blocking) 또는 비차단(non-blocking)일 수 있습니다**:
    - **차단(동기적)**: 차단 전송은 발신자가 메시지가 수신될 때까지 대기하게 하고, 차단 수신은 수신자가 메시지를 받을 때까지 대기하게 합니다.
    - **비차단(비동기적)**: 비차단 전송은 발신자가 메시지를 보낸 후 계속 진행하고, 비차단 수신은 수신자가 유효한 메시지 또는 null을 받습니다.

### 버퍼링

- **링크에 첨부된 메시지 큐**; 세 가지 방식 중 하나로 구현됩니다:
    1. **제로 용량**: 0개의 메시지. 발신자는 수신자가 준비될 때까지 기다려야 합니다(랑데뷰).
    2. **유한 용량**: n개의 메시지 길이. 링크가 가득 차면 발신자는 기다려야 합니다.
    3. **무한 용량**: 무한한 길이. 발신자는 기다리지 않습니다.

이러한 간접 통신 방식은 프로세스 간에 중간 엔터티를 통해 통신하는 구조를 제공하며, 메시지 전달과 동기화 방식에 따라 다양한 통신 패턴을 지원합니다.

### 예외 조건 – 오류 복구

- **프로세스 종료**: 메시지 처리 전에 발신자 또는 수신자가 종료될 수 있습니다.
    
    - 수신자 P가 Q로부터의 메시지를 기다리고 있지만, Q가 종료되면 P는 영원히 차단됩니다.
    - 시스템은 P를 종료시키거나 P에게 Q가 종료되었음을 알릴 수 있습니다.
- **메시지 손실**: 하드웨어 또는 통신 라인 실패
    
    - 운영 시스템은 이 이벤트를 감지하고 메시지를 재전송하는 책임이 있습니다.
    - 발신자는 이 이벤트를 감지하고 원할 경우 메시지를 재전송하는 책임이 있습니다.
    - 운영 시스템은 이 이벤트를 감지하고 발신자에게 메시지가 손실되었음을 알립니다. 그러면 발신자는 자신이 선택한 대로 진행할 수 있습니다.
    - 메시지가 손실되었는지 어떻게 감지할까요? → 타임아웃 사용
- **메시지 오류**: (통신 채널의 노이즈)
    
    - 패리티나 CRC와 같은 오류 검사 코드를 사용합니다.

### 클라이언트-서버 시스템에서의 통신

- **파이프 (이름 없는 파이프)**:
    - 표준 생산자-소비자 방식으로 두 프로세스 간의 통신을 가능하게 합니다.
    - 예: `ls | grep x`
- **명명된 파이프 (FIFO)**:
    - 파일 시스템 내의 파일 이름입니다.
    - 여러 프로세스가 명명된 파이프를 통해 통신할 수 있습니다.
    - 예: `mkfifo pipe1; ls -l > pipe1 ; cat < pipe1`
- **소켓**: 통신을 위한 엔드포인트(네트워크를 통해)
    - IP:포트 (예: 146.86.5.20:80)
    - 잘 알려진 포트 (telnet:23, FTP:21, HTTP:80)
    - 연결 지향적(TCP) 소켓
    - 비연결성(UDP) 소켓

이러한 메커니즘은 시스템의 신뢰성을 유지하고, 오류 발생 시 적절한 대응을 가능하게 합니다.

### 원격 프로시저 호출 (RPC)

- **네트워크 시스템 간 프로세스에서의 프로시저 호출을 추상화**:
    
    - 네트워크를 통해 다른 시스템의 프로세스에서 함수를 호출하고, 그 결과를 받는 방식입니다.
- **스텁 (Stub)**:
    
    - **클라이언트 측 스텁**: 서버에서 실제로 수행되는 절차에 대한 클라이언트 측 프록시입니다.
    - 클라이언트 측 스텁은 서버를 찾고 매개변수를 정리(marshals)하는 역할을 합니다.
        - **XDR (eXternal Data Representation)**: 서로 다른 컴퓨터 시스템 간에 데이터를 교환할 수 있게 해주는 데이터 형식입니다.
        - **Big-endian 또는 little-endian**: 데이터의 바이트 순서를 정의합니다. 예를 들어, `12 34` 또는 `34 12`의 순서로 표현될 수 있습니다.
- **서버 측 스텁**:
    
    - 이 메시지를 수신하고, 정리된(marshaled) 매개변수를 풀고(unpacks), 서버에서 절차를 수행합니다.
![[Pasted image 20240420222024.png]]
RPC는 클라이언트와 서버 간의 통신을 마치 로컬 환경에서 함수를 호출하는 것처럼 간단하게 만들어 줍니다. 이를 통해 개발자는 네트워크의 복잡성을 신경 쓰지 않고 원격 위치에서 코드를 실행할 수 있습니다.

# 쓰레드(Thread)

- **프로세스 내에서 자원을 공유하고 동시에 접근**:
    
    - 스레드는 CPU 사용의 기본 단위로서, 가벼운 프로세스라고도 불립니다.
- **스레드 구성 요소**:
    
    1. **프로그램 카운터**: 스레드가 다음에 실행할 명령어의 주소를 가리킵니다.
    2. **레지스터 세트**: 현재 작업의 상태를 나타내는 레지스터들의 집합입니다.
    3. **스택 공간**: 함수 호출과 로컬 변수 등을 위한 메모리 공간입니다.
- **스레드가 공유하는 요소**:
    
    - **코드 섹션, 데이터 섹션, 운영 시스템 자원**: 이들은 동일 프로세스(또는 작업) 내의 다른 스레드와 공유됩니다.
- **전통적인 또는 무거운 프로세스**:
    
    - 하나의 스레드를 가진 작업과 동일합니다.
- **웹 브라우저의 예**:
    
    - 이미지나 텍스트를 표시하고,
    - 네트워크에서 데이터를 검색하는 작업 등을 스레드를 사용하여 처리합니다.
![[Pasted image 20240420222347.png]]
스레드는 하나의 프로세스 내에서 멀티태스킹을 가능하게 하여, 자원의 효율적 사용과 더 빠른 실행 속도를 도모합니다. 또한, 개별 스레드가 각각의 작업을 독립적으로 수행할 수 있도록 함으로써 전체 시스템의 성능을 향상시킬 수 있습니다.

### 스레드의 이점

- **응답성**:
    
    - 동일 프로세스 내에서 여러 스레드를 사용하여 동시에 여러 작업을 수행함으로써 사용자에게 더 빠른 반응을 제공할 수 있습니다.
- **자원 공유**:
    
    - 스레드는 메모리, 파일 등의 프로세스 자원을 공유할 수 있어, 효율적인 자원 사용이 가능합니다.
- **경제성**:
    
    - 스레드 생성 비용이 프로세스 생성 비용보다 적습니다. 이는 시스템 자원을 절약할 수 있게 합니다.
- **확장성**:
    
    - 멀티프로세서 아키텍처의 활용을 통해 시스템 성능을 향상시킬 수 있습니다. 스레드는 멀티 코어 또는 멀티 CPU 시스템에서 효과적으로 작업을 분산시킬 수 있습니다.
- **일반적인 이점**:
    
    - 새 스레드를 생성하고 종료하는 시간이 프로세스에 비해 적습니다.
    - 같은 프로세스 내의 두 스레드 간 전환 시간도 적습니다.
    - 같은 프로세스 내의 스레드들은 메모리와 파일을 공유하므로, 커널 호출 없이 서로 통신할 수 있습니다.

이러한 이점들은 스레드를 사용함으로써 시스템의 전반적인 성능과 자원 사용의 효율성을 높이는 데 기여합니다.

## 쓰레드의 유형
### 커널 스레드

- **커널에 의해 지원됩니다**:
    
    - 커널은 프로세스 및 스레드에 대한 컨텍스트 정보를 유지 관리합니다.
    - 스레드 간 전환이 커널을 필요로 합니다.
- **예시**:
    
    - Windows XP/2000, Solaris, Linux, Tru64 UNIX, Mac OS X 등에서 커널 스레드를 지원합니다.

### 사용자 스레드

- **모든 스레드 관리가 사용자 레벨 스레드 라이브러리에 의해 이루어집니다**:
    
    - 커널은 스레드의 존재를 인식하지 못합니다.
    - 스레드 전환이 커널 모드 권한을 요구하지 않습니다.
    - 스케줄링은 애플리케이션에 특화되어 있습니다.
- **예시**:
    
    - POSIX Pthreads, Win32 스레드, Java 스레드 등이 사용자 스레드의 예입니다.

### 하이브리드 접근

- **사용자 수준 및 커널 지원 스레드를 모두 구현합니다**:
    - 이 접근법은 사용자 수준의 유연성과 커널 스레드의 효율성을 결합합니다.

이러한 각 유형의 스레드는 특정 시스템 설계 및 애플리케이션 요구에 따라 선택될 수 있으며, 각각의 장단점이 있습니다. 커널 스레드는 보다 안정적인 운영 시스템 통합을 제공하는 반면, 사용자 스레드는 더 빠른 스레드 관리와 커스터마이징을 가능하게 합니다. 하이브리드 접근 방식은 두 접근법의 장점을 혼합하여 제공합니다.

### 멀티스레딩 모델

- **매니-투-원 (Many-to-One)**:
    
    - 여러 사용자 레벨 스레드가 단일 커널 스레드에 매핑됩니다.
    - 커널 스레드를 지원하지 않는 시스템에서 사용됩니다.
- **원-투-원 (One-to-One)**:
    
    - 각 사용자 레벨 스레드가 하나의 커널 스레드에 매핑됩니다.
    - 이 모델은 사용자 레벨 스레드가 커널 스레드와 직접 연결되어 있기 때문에, 스레드 관리가 더 효율적이고 각 스레드가 시스템 자원을 직접 제어할 수 있게 합니다.
- **매니-투-매니 (Many-to-Many)**:
    
    - 많은 사용자 레벨 스레드를 많은 커널 스레드에 매핑할 수 있습니다 (멀티플렉싱).
    - 운영 시스템이 충분한 수의 커널 스레드를 생성할 수 있도록 합니다.
    - 이 모델은 유연성이 높고, 시스템 자원을 보다 효율적으로 활용할 수 있도록 해줍니다.

각각의 멀티스레딩 모델은 특정한 시나리오와 시스템 요구에 따라 장단점을 가지고 있습니다. 선택은 시스템의 설계 목표와 지원하는 기능에 따라 결정됩니다.

![[Pasted image 20240420222626.png]]