## 서론
최근 동아리 프로젝트 리더가 추진안 현재 동아리 인원의 규모가 커졌기에 각 기능별로 팀을 나누어서 기능을 개발하기로 하였습니다. 이러한 팀 분할을 통해 누군가의 작업 공간이 확실해졌고 다른 팀에서 기능 문의 시 해당 팀이나 파트장에게 직관적으로 질문할 수 있게 변경되었습니다. 하지만 이런 팀 분할은 작업관리에 관련해서 문제가 생겼습니다.

![[Pasted image 20240406153053.png]]
현재 KOIN_RECODE의 git 상황입니다. 현재 굉장히 많은 머지를 통해 브런치가 합쳐지고 늘어나면서 기능들이 난잡하게 늘어져 있습니다. 다른 사람들이 본다면 뭐가 문제지? 라는 생각이 들 수 있습니다. 이 뒤로 현재 저희들의 git 전략이 어떻게 되어있고 문제가 되는 상황을 분석하고, 이에 대한 문제를 해결하기 위한 방안을 몇가지 제시해보겠습니다.

## 현재 프로젝트 작업 관리 현황

초기 KOIN_RECODE 프로젝트는 2~3명의 소수 인원의 개발을 통해 만들어졌습니다. 그러한 과정에서 서로의 코드 품질을 높히기 위해 코드의 가독성을 높힐 수 있는 Lint Action 검사, 리뷰를 필수적인 및 approve 인원 조건 등의 방식을 추가하였습니다.

이러한 과정에서 Pull Request 과정을 필수적으로 거치고 `Merge`를 통해 붙여두는 식으로 하였습니다.
내용을 정리해 보겠습니다.

> 초기 개발 당시 코드 품질을 높히기 위한 Lint 도입, 머지 규칙 도입
> 소수 인원 개발이었기에 서로의 작업내용을 알고 있기에 개발 당시 커뮤니케이션 비용이 적음


## 현 프로젝트의 상황

그러다면 현재의 상황은 어떻게 되었을까요. 본격적인 KOIN_RECODE 프로젝트가 기존 프로젝트를 밀어내고 실제 프로덕션으로 올라오면서 문제가 되었습니다. 
### Merge 방식의 문제
먼저 기본적으로 각 팀이 나누어진면서 기능을 개발하는 기간이 조금씩 달라지면서 `develop` 브런치에 대한 관리가 어려워졌습니다.

기본적으로 우리들의 `develop` 브런치 하나에 작업을 쌓아두게 되는데 이러한 과정에서 서로의 작업을 위해 `develop` 브런치를 `Merge`로 작업내용을 가져가게 되는데 이러한 과정에서 자신의 git 내용들이 `develop`에 작업되는 내용들이 계속해서 업데이트하게 됩니다.

혹시나 `feature` 브런치 중 현재 올라가지 말아야할 기능이 포함되어 실수로 배포되었을 경우에는, 서비스 운영에 지장이 생길 것입니다.

또한 이러한 무분별한 머지는 git의 내용을 복잡하게 만듭니다.

![[Pasted image 20240406161605.png]]

어디부터 누가 누구의 작업인지 어느 `feature/#~~`가 어떤 기능인지 이해하고 올리기까지 시간이 상당히 걸립니다.

> 현재의 문제상황 정리
> 1. 팀이 늘어나면서 `develop` 브런치에 merge하는 일이 빈번하게 발생. `develop` 브런치 자체에 내용이 많아지고 작업 추적에 어려움이 발생함.
> 2. 이외에도 초기에 강하게 잡아둔 룰에 `main`에 대한 배포의 유연성이 감소함


## How to Solve?
### 1.  Squash Merge의 도입
먼저 도입해야할 것은 `Squash Merge`입니다. 이는 feature 브런치에 수많은 커밋을 올리지만, 이에 대한 `develop` 브런치에 머지되는 경우에는 하나의 커밋을 축약되어 올라가는 것입니다.
`Squash Merge`가 이루어질 경우 git에는 아래와 같이 기록됩니다.
![[Pasted image 20240406162616.png]]`
`develop` 브런치에서 커밋 이름으로는 자신이 만든 PR의 제목으로 들어가고 설명으로는 자신의 커밋 기록이 들어가게 됩니다.

아래와 같이 PR 옵션으로 선택해서 진행할 수 있습니다.
![[Pasted image 20240406162446.png]]

왜 이렇게 하나요? 이렇게 하면 잔디가 많이 안올라가지 않나요? 예 맞습니다. 하지만 잔디가 문제가 아니라 효율성이 문제입니다. 

만약 `develop`이나 `main` 브런치를 최신화 하기위해 작업자가 `main` 브런치로 `git pull` 명령어를 통해 작업을 확인하는 경우에는 아래와 같은 상황을 맞이할 수 있습니다.

![[Pasted image 20240406163057.png]]
이렇게 모든 커밋 기록이 `main` 브런치에 머지되는 내용이기에 130개의 커밋을 확인해야하는 문제가 발생할 수 있습니다.
그렇기에 `main` 브런치에 대한 불필요한 커밋 내용을 없애기 위해 `Squash Merge` 도입이 필요합니다.

> 요약
> `Squash Merge`를 도입하여 `develop` 브런치에 쌓이는 불필요한 커밋 기록을 제거함.
> 이를 통해 git을 깔끔하게 하여 다른 팀들의 작업 추적이 용이해짐 또한팀 간의 커뮤니케이션 비용이 확실하게 감소를 기대할 수 있음.

### Merge 대신 Rebase를 사용하자
기본적으로 Merge 방식 자체는 깃을 합치는 것으로 해당 작업을 모든 것을 올리게되지만, 머지가 많으면 많아질 수록 git을 트래킹하기 어려워지는 것은 사실입니다.

현재처럼 `develop` 브런치를 여러 팀이 머지하게 된다면 점점 작업관리가 어려워질 것입니다. 그렇기에 모든 작업은 develop 브런치 내용추적을 Merge가 아닌 rebase를 활용하고, 실제 작업을 올리는 경우 Squash Merge를 진행하여 `develop` 브런치를 한줄로 관리하는 것을 목표로하면 좋을 것 같습니다.

> 요약
> `Merge`가 아닌 `Rebase`를 통해 develop 브런치의 내용을 추적함. 
> 이를 통해 develop 에 대한 일반 머지를 통해 늘어나는 커밋 기록들을 제거. 
## Rebase와 Squash Merge 콜라보의 기대효과
먼저 작업 시작 전 develop을 pull로 땡겨온 이후 자신의 브런치를 `develop`브런치에 rebase를 하게 됩니다. 이러한 과정에서 기본적으로 `develop` 브런치와  동일한 작업 현황이 맞게 시작됩니다. 또한 개발 이후 `Squash Merge`를 하게된다면 자신이 한 수많은 커밋은 하나의 커밋으로 보이게 될 것입니다.





이 2개의 git 중 여러분은 어떤게 더 관리하기 쉬울까요? 물론 아래와 같이 유지하기 위해서는 많은 노력이 필요할 것 입니다. `git rebase`부터 시작해서 `git cherry-pick`, 혹시라도 잘못된 경우를 대비해 `git reset` 까지 명령어를 더 많이 활용할 수 있을 것입니다.
