### 멀티프로세서 스케줄링

- **멀티코어 프로세서의 등장**:
    
    - 멀티코어: 여러 CPU 코어가 단일 칩에 패키징됩니다.
- **CPU 추가는 단일 애플리케이션을 더 빠르게 실행시키지 않음**:
    
    - 애플리케이션을 병렬로 실행할 수 있도록 다시 작성해야 하며, 이때 스레드를 사용합니다.
- **여러 CPU가 사용 가능할 때 CPU 스케줄링이 더 복잡해짐**:
    
    - 여러 프로세서에 작업을 할당하고 관리하는 것이 단일 프로세서 시스템보다 복잡합니다.

### 다중 프로세서 스케줄링

- **부하 공유**:
    
    - 프로세스가 특정 프로세서에 할당되지 않습니다.
    - 부하는 프로세서들 사이에 고르게 분배됩니다.
    - 어떤 프로세서도 유휴 상태로 남지 않도록 보장합니다.
    - 전역 큐를 사용합니다.
- **단점**:
    
    - 중앙 큐는 상호 배타적 접근이 필요하며, 여러 프로세서가 동시에 작업을 찾을 때 병목 현상이 발생할 수 있습니다.
    - 선점형 스레드는 같은 프로세서에서 실행을 재개할 가능성이 낮으며, 이는 캐시 사용의 효율성이 떨어질 수 있습니다.
    - 모든 스레드가 전역 큐에 있을 경우, 하나의 프로그램의 모든 스레드가 동시에 프로세서에 접근하지 못할 수 있습니다.

이러한 멀티프로세서 스케줄링 방식은 시스템의 자원을 최대한 활용하려는 목적을 가지고 있으며, 부하 분산 및 효율적인 작업 처리를 위해 여러 전략을 사용합니다.

### 부하 균형(Load Balancing)

- **부하 균형**은 SMP(대칭 다중 처리) 시스템에서 모든 프로세서에 걸쳐 작업 부하를 고르게 분배하려고 시도합니다.
    - 각 프로세서는 프로세스를 위한 개별 큐를 가지고 있습니다.
    - **푸시 마이그레이션**: 특정 작업이 주기적으로 각 프로세서의 부하를 점검하고 불균형을 발견하면 과부하된 프로세서로부터 유휴 또는 덜 바쁜 프로세서로 프로세스를 이동시켜 부하를 균등하게 분배합니다.
    - **풀 마이그레이션**: 유휴 프로세서가 바쁜 프로세서로부터 대기 중인 작업을 가져옵니다.
    - 프로세서 친화도의 이점을 상쇄할 수 있습니다.

### 프로세서 친화도(Processor Affinity)

- **프로세서 친화도**는 프로세스를 동일한 프로세서에서 계속 실행하려고 시도합니다.
    - 선점형 스레드가 동일한 프로세서에서 실행을 재개할 가능성은 낮으며, 이로 인해 캐시 사용이 덜 효율적일 수 있습니다.
    - **소프트 친화도(Soft Affinity)**: 최선을 다하여 동일한 프로세서에 프로세스를 유지합니다.
    - **하드 친화도(Hard Affinity)**: 다른 프로세서로의 마이그레이션을 허용하지 않습니다.

이러한 다중 프로세서 스케줄링 전략은 시스템의 성능과 효율성을 최대화하기 위해 프로세서 간의 작업 부하를 균등하게 분배하고자 합니다. 프로세서 친화도는 특정 프로세스가 동일한 프로세서에서 지속적으로 실행되어 캐시 효율성을 높이는 것을 목표로 하지만, 이로 인해 부하 균형에 어려움이 발생할 수도 있습니다.

### 캐시 일관성(Cache Coherence)

- **여러 캐시에 저장된 공유 자원 데이터의 일관성을 유지하는 것**입니다.
- 예를 들어, CPU1이 올바른 값인 𝑫′ 대신 오래된 값 𝑫를 가져오는 상황이 발생할 수 있습니다.

### 버스 스누핑(Bus Snooping)

- **각 캐시는 버스를 관찰함으로써 메모리 업데이트를 주의 깊게 살펴봅니다**.
- CPU가 자신의 캐시에 있는 데이터 항목에 대한 업데이트를 보게 되면, 이 변경을 인지하고 자신의 복사본을 무효화하거나 업데이트합니다.

캐시 일관성은 멀티프로세서 시스템에서 중요한 역할을 합니다. 여러 프로세서의 캐시 사이에서 데이터가 일관되게 유지되도록 보장함으로써, 데이터 불일치로 인한 오류를 방지하고 시스템의 전반적인 신뢰성을 향상시킵니다. 버스 스누핑은 이러한 일관성을 유지하기 위한 효과적인 기술 중 하나로, 모든 캐시가 메모리 접근을 감시하고 필요한 조치를 취할 수 있도록 합니다.

### 상호 배제 (Mutual Exclusion)

- **CPU 간에 공유 데이터에 접근할 때는 상호 배제 원시를 사용하여 정확성을 보장해야 합니다**:
    - 공유 데이터에 동시에 접근하는 것을 방지하여 데이터 불일치와 충돌을 막습니다.

### 캐시 친화성 (Cache Affinity)

- **가능한 한 프로세스를 동일한 CPU에 유지**:
    - 프로세스는 CPU의 캐시에 상당한 상태 정보를 구축합니다.
    - 프로세스가 다음에 실행될 때, 그 상태 일부가 이미 해당 CPU의 캐시에 존재한다면 더 빠르게 실행될 수 있습니다.
- **멀티프로세서 스케줄러는 스케줄링 결정을 내릴 때 캐시 친화성을 고려해야 합니다**.

### 다중 프로세서 스케줄링

- **다중 프로세서 스케줄링**:
    - **갱 스케줄링 (Gang Scheduling)**:
        - 관련된 일련의 프로세스가 동시에 일련의 프로세서에서 실행되도록 스케줄됩니다.
    - **전용 프로세서 할당 (Dedicated Processor Assignment)**:
        - 프로세스가 특정 프로세서에 할당됩니다.
    - **동적 스케줄링 (Dynamic Scheduling)**:
        - 실행 과정에서 프로세스 수가 변경될 수 있습니다.

이러한 개념들은 다중 프로세서 시스템에서 데이터의 일관성을 유지하고, 프로세스의 실행 효율을 극대화하기 위해 필수적인 방법론입니다. 상호 배제는 데이터 접근 시 충돌을 방지하고, 캐시 친화성은 프로세스의 성능을 최적화합니다. 다중 프로세서 스케줄링은 이러한 요소들을 고려하여 시스템의 전체적인 성능을 향상시키는 데 중요한 역할을 합니다.

### 대칭 다중 스레딩 (Symmetric Multithreading)

- **논리 프로세서 – 하이퍼스레딩 기술**:
    - 여러 명령어 페치 유닛과 프로그램 카운터를 갖추고 있습니다.
    - 슈퍼스칼라 아키텍처와 유사합니다.

### 단일 큐 다중 프로세서 스케줄링 (Single Queue Multiprocessor Scheduling, SQMS)

- **스케줄링이 필요한 모든 작업을 단일 큐에 넣습니다**:
    
    - 각 CPU는 글로벌하게 공유된 큐에서 다음 작업을 선택합니다.
- **단점**:
    
    - 어떤 형태의 락이 필요하므로 확장성이 부족할 수 있습니다.
    - 캐시 친화성을 고려해야 합니다.
- **예시**:
    
    - CPU 간의 가능한 작업 스케줄러:
        - 큐 A, B, C, D, E, NULL

### 캐시 친화성을 고려한 스케줄링 예시

- **대부분의 작업은 프로세서 간에 이동되지 않도록 유지**:
    
    - A부터 D까지의 작업은 프로세서 간에 이동되지 않습니다.
    - 오직 작업 E만 CPU 간에 이동됩니다.
- **이러한 계획을 구현하는 것은 복잡할 수 있습니다**:
    
    - 작업을 특정 CPU에 고정하여 캐시 친화성을 유지하려고 시도하지만, 작업 로드 균형 및 성능 최적화를 위해 때때로 작업을 다른 CPU로 이동시켜야 할 수도 있습니다.

이러한 스케줄링 접근 방식은 프로세스를 효율적으로 관리하면서도 시스템 자원을 최대한 활용하려는 목표를 가지고 있습니다. 각각의 방식은 특정 시스템 요구와 상황에 따라 유용할 수 있습니다.

### 리얼타임 시스템

- **실험실 실험, 공정 제어 공장, 로봇공학, 항공교통 관제, 통신 등에서 사용됩니다**.
- **하드 리얼타임 시스템**: 보장된 시간 내에 중요한 작업을 완료해야 합니다.
- **소프트 리얼타임 컴퓨팅**: 중요한 프로세스가 우선적으로 처리되어야 하지만, 엄격한 시간 제한은 없습니다.

### 우선순위 반전 (Priority Inversion)

- **고 우선순위 프로세스가 낮은 우선순위 프로세스에 의해 블록될 때 발생합니다**.
- **예**: 고 우선순위 프로세스가 낮은 우선순위 프로세스가 접근 중인 리소스를 기다리는 경우.

### 우선순위 상속 프로토콜 (Priority Inheritance Protocol)

- **낮은 우선순위 프로세스가 높은 우선순위를 상속하여 리소스를 사용하는 동안 우선순위를 높일 수 있습니다**.
- **이를 통해 우선순위 반전 문제를 해결할 수 있습니다**.

리얼타임 운영체제는 시간에 민감한 작업을 다루는데 필수적이며, 하드웨어 또는 소프트웨어의 결함으로 인해 시스템이 예기치 않게 동작하는 것을 방지합니다. 우선순위 반전 문제를 해결하기 위해 우선순위 상속 프로토콜을 사용할 수 있으며, 이를 통해 리얼타임 시스템의 신뢰성을 높일 수 있습니다.