## 리스트란? 
노드로 이루어진 동적인 배열

노드 하나하나가 연결된 구조
여기서 데이터를 담는 노드 목록에서 첫 번째를 head, 마지막을 Tail 이라고 한다.

> 연산 종류
> 리스트에 노드 추가 Append
> 노드 사이에 노드를 삽입하는 연산 Insert
> 노드를 제거하는 연산 Remove
> 특정 위치에 있는 노드를 반환하는 연산 GetAt


## 리스트 vs 배열
배열처럼 데이터 집합 보관 기능을 가지면서도 배열과 달리 유연하게 크기를 바꿀 수 있는 자료구조

리스트를 구성하는 노드는
데이터를 보관하는 필드, 다음 노드와 연결 고리 역할을 하는 포인터로 구성된다.

링크드 리스트의 주요 연산 중에는
삭제와 소멸의 차이
소멸: 노드를 메모리에서 없애는 연산
삭제: 리스트에서 노드를 제외하는 연산


## 링크드 리스트의 노드 생성/소멸 연산
생성과 소멸 연산의 구현을 결정하는 과정에서 노드를 자유저장소, 자동메모리 둘 중에 어느 곳에 할지 선택해야하는데

자동 메모리의 경우 노드 생성 함수를 이후 retrurn &newNode를 하게 될 경우 함수가 종료되면서 newNode가 자동메모리에서 제거 되면서 잘못된 메모리를 잡게 되기 때문에 자유 저장소를 활용해야한다.

자유 저장소를 활용하는 경우에는 메모리를 할당하는 malloc 함수가 필요하다.

노드의 소멸의 경우에는 `free()`를 통해 가능하다.

## 링크드 리스트에 대한 고찰

`**`를 사용하는 이유
만약 `*`만  넘겼을 경우에는 List 포인터가 담고 있는 주솟값만 Head에 복사되고 정작 list 포인터 변수의 주소는 전달되지 않는 다면 호출 이후 자동메모리에 의해 제거 되고 List는 여전히 NULL인 채로 남아, 함수가 실행되기 이전과 동일한 상태가 됩니다.

*포인터가 가진 값이 아닌, 포인터 자신의 주소를 넘겨야 된다*

### 링크드 리스트의 탐색 연산
링크드 리스트는 헤드부터 시작해서 다음노드에 대한 포인터를 징검다리 삼아서 하나씩 거쳐야만 원하는 요소에 접근이 가능하다.

### 링크드 리스트의 삭제 연산
삭제하고자 하는 노드를 찾은 이후 해당 노드의 다음 노드를 이전 노드의 NextNode 포인터에 연결

(제거한 노드는 완전히 소멸시킨다.)

### 링크드 리스트의 삽입 연산
노드와 노드사이에 새로운 노드를 끼워넣는 연산
이전 노드의 NextNode 포인터가 새 노드를 가리키게 하고 새노드의 NextNode 포인터가 다음 노드를 가리키게 한다.

### 링크드 리스트의 장단점
단점: 특정 위치에 있는 노드에 접근하는 연산이 느리다.
장점: 노드의 추가 삽입 삭제 연산이 빠르다.

---
## 더블 링크드 링크드 리스트
노드에 앞을 가리킬 수 있는 포인터가 추가 됨
![[Pasted image 20240418021910.png]]
---
## 환형 링크드 리스트
Tail 에 접근하는 비용이 거의 없는 것이나 다름 없을 정도로 작아지기에 노드 Append 기능이 획기적으로 개선된 특징이며,뒤에서부터 노드를 찾아 나가는 노드 탐색 루틴 구현이 가능하다.

![[Pasted image 20240418021849.png]]