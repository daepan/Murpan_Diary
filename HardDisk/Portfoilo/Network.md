### OSI 7계층 모델의 각 계층과 그 역할에 대해 설명해 주세요.

OSI 7계층 모델은 네트워크 통신을 7개의 계층으로 나눈 모델로, 각 계층은 특정 기능을 담당합니다.

1. **물리 계층(Physical Layer):** 물리적 전송 매체를 통해 데이터 비트를 전송합니다. 케이블, 스위치, 허브 등이 해당됩니다.
2. **데이터 링크 계층(Data Link Layer):** 물리 계층에서의 데이터 전송 오류를 검출하고 수정합니다. MAC 주소를 사용하며, 스위치와 브리지 등이 있습니다.
3. **네트워크 계층(Network Layer):** 데이터 패킷을 목적지까지 최적 경로로 전송합니다. IP 주소를 사용하며, 라우터가 대표적인 장치입니다.
4. **전송 계층(Transport Layer):** 데이터 전송의 신뢰성을 보장합니다. TCP와 UDP가 이 계층에서 작동합니다.
5. **세션 계층(Session Layer):** 통신 세션을 설정, 관리, 종료합니다. 세션 복구와 동기화를 담당합니다.
6. **표현 계층(Presentation Layer):** 데이터의 형식과 변환을 담당합니다. 데이터 암호화와 압축을 포함합니다.
7. **응용 계층(Application Layer):** 사용자와 직접 상호작용하는 응용 프로그램 서비스 제공. HTTP, FTP, SMTP 등이 있습니다.


### TCP 3-way 및 4-way 핸드셰이크 과정에 대해 설명해 주세요.

TCP는 신뢰성 있는 연결을 위해 3-way 핸드셰이크와 4-way 핸드셰이크를 사용합니다.

- **3-way 핸드셰이크:**
    
    1. **SYN:** 클라이언트가 서버에 연결 요청을 보냅니다.
    2. **SYN-ACK:** 서버가 클라이언트의 요청을 받고, 응답과 함께 연결 요청을 보냅니다.
    3. **ACK:** 클라이언트가 서버의 응답을 확인하고, 연결이 설정됩니다.
- **4-way 핸드셰이크:**
    
    1. **FIN:** 클라이언트가 연결 종료 요청을 보냅니다.
    2. **ACK:** 서버가 클라이언트의 종료 요청을 확인합니다.
    3. **FIN:** 서버가 연결 종료 요청을 보냅니다.
    4. **ACK:** 클라이언트가 서버의 종료 요청을 확인하고, 연결이 종료됩니다.

### TCP/IP의 흐름제어와 혼잡제어에 대해 설명해 주세요.

TCP/IP는 데이터 전송의 효율성을 위해 흐름제어와 혼잡제어를 사용합니다.

- **흐름제어(Flow Control):** 송신자가 수신자의 수용 능력을 초과하지 않도록 조절합니다. 주요 기법은 슬라이딩 윈도우(Sliding Window)입니다. 수신자는 자신의 버퍼 크기를 윈도우 크기로 알려주고, 송신자는 이를 바탕으로 데이터 전송 속도를 조절합니다.
    
- **혼잡제어(Congestion Control):** 네트워크 혼잡을 방지하고 완화하기 위해 송신 속도를 조절합니다. 주요 알고리즘은 다음과 같습니다:
    
    - **Slow Start:** 처음에는 작은 윈도우 크기로 시작하여 점차적으로 증가시킵니다.
    - **Congestion Avoidance:** 혼잡이 예상되면 윈도우 크기를 서서히 증가시킵니다.
    - **Fast Retransmit:** 패킷 손실을 감지하면 즉시 재전송합니다.
    - **Fast Recovery:** 손실이 발생한 후 혼잡 윈도우 크기를 줄이고 서서히 증가시킵니다.


### UDP 프로토콜의 특징과 사용 사례에 대해 설명해 주세요.

UDP(User Datagram Protocol)는 비연결형 프로토콜로, 데이터 전송의 신속성을 중요시합니다.

- **특징:**
    
    - 비연결형: 연결 설정 없이 데이터를 전송합니다.
    - 신뢰성 없음: 패킷 손실, 중복, 순서 변경에 대한 보장이 없습니다.
    - 낮은 오버헤드: 헤더가 간단하여 전송 속도가 빠릅니다.
    - 데이터그램 전송: 독립적인 데이터그램 단위로 전송합니다.
- **사용 사례:**
    
    - 실시간 스트리밍: 지연 시간 최소화가 중요한 음성 및 영상 스트리밍
    - 온라인 게임: 빠른 응답이 중요한 게임 데이터 전송
    - DNS: 짧은 요청-응답 시간과 낮은 오버헤드가 중요한 도메인 네임 조회


### 대칭키 암호화와 공개키 암호화의 차이점과 장단점에 대해 설명해 주세요.

대칭키 암호화와 공개키 암호화는 데이터를 안전하게 보호하는 두 가지 방법입니다.

- **대칭키 암호화:**
    
    - **특징:** 하나의 키를 사용하여 데이터를 암호화하고 복호화합니다.
    - **장점:** 암호화와 복호화 속도가 빠릅니다.
    - **단점:** 키 분배가 어려우며, 키가 유출되면 보안이 위협받습니다.
    - **사용 사례:** 대량 데이터 암호화, 내부 시스템 통신
- **공개키 암호화:**
    
    - **특징:** 공개키로 데이터를 암호화하고, 대응되는 비밀키로 복호화합니다. 비밀키는 비밀로 유지되며, 공개키는 공개됩니다.
    - **장점:** 키 분배가 용이하며, 키 유출 위험이 낮습니다.
    - **단점:** 암호화와 복호화 속도가 느립니다.
    - **사용 사례:** 디지털 서명, SSL/TLS 인증, 전자 메일 암호화




### HTTP와 HTTPS의 차이점에 대해 설명해 주세요.

 HTTP와 HTTPS는 웹 통신을 위한 프로토콜로, 주요 차이점은 보안 수준입니다.

- **HTTP (HyperText Transfer Protocol):**
    
    - **특징:** 기본 웹 통신 프로토콜로, 텍스트, 이미지, 동영상 등을 전송합니다.
    - **보안:** 데이터가 평문으로 전송되므로 도청과 위조에 취약합니다.
    - **포트:** 기본 포트는 80입니다.
- **HTTPS (HyperText Transfer Protocol Secure):**
    
    - **특징:** HTTP에 SSL/TLS를 적용하여 보안을 강화한 프로토콜입니다.
    - **보안:** 데이터가 암호화되어 전송되므로 도청과 위조로부터 안전합니다.
    - **포트:** 기본 포트는 443입니다.
    - **인증:** 서버 인증서를 사용하여 서버의 신원을 확인할 수 있습니다.


### TLS/SSL HandShake 과정에 대해 설명해 주세요.

TLS/SSL HandShake는 클라이언트와 서버 간의 안전한 통신 채널을 설정하기 위한 과정입니다.

1. **Client Hello:** 클라이언트가 지원하는 암호화 방법, 프로토콜 버전, 난수 등을 서버에 전송합니다.
2. **Server Hello:** 서버가 선택한 암호화 방법, 프로토콜 버전, 난수 등을 클라이언트에 전송합니다.
3. **Server Certificate:** 서버가 자신의 인증서를 클라이언트에 전송하여 신원을 확인합니다.
4. **Server Key Exchange (Optional):** 필요시 서버가 추가 키 교환 정보를 전송합니다.
5. **Server Hello Done:** 서버가 초기 설정 완료를 알립니다.
6. **Client Key Exchange:** 클라이언트가 세션 키를 생성하고, 서버의 공개키로 암호화하여 전송합니다.
7. **Change Cipher Spec:** 클라이언트가 암호화 통신을 시작한다고 알립니다.
8. **Client Finished:** 클라이언트가 핸드셰이크 완료 메시지를 암호화하여 전송합니다.
9. **Change Cipher Spec:** 서버가 암호화 통신을 시작한다고 알립니다.
10. **Server Finished:** 서버가 핸드셰이크 완료 메시지를 암호화하여 전송합니다.

핸드셰이크가 완료되면 클라이언트와 서버는 대칭키를 사용하여 암호화된 데이터를 안전하게 주고받습니다.


### 로드밸런싱이란 무엇이며, 주요 기법과 사용 사례에 대해 설명해 주세요.

로드밸런싱은 네트워크 트래픽을 여러 서버에 분산시켜 서버 과부하를 방지하고, 가용성과 성능을 향상시키는 기술입니다.

- **주요 기법:**
    
    - **라운드 로빈(Round Robin):** 순차적으로 각 서버에 요청을 분배합니다.
    - **가중 라운드 로빈(Weighted Round Robin):** 서버의 성능에 따라 가중치를 부여하여 요청을 분배합니다.
    - **최소 연결(Least Connections):** 현재 연결 수가 가장 적은 서버에 요청을 분배합니다.
    - **IP 해싱(IP Hashing):** 클라이언트의 IP 주소를 해싱하여 특정 서버에 요청을 분배합니다.
    - **응답 시간 기반(Response Time):** 응답 시간이 가장 빠른 서버에 요청을 분배합니다.
- **사용 사례:**
    
    - **웹 서버:** 높은 트래픽을 처리하기 위해 웹 서버에 로드밸런서를 적용하여 요청을 분산합니다.
    - **데이터베이스 서버:** 데이터베이스 서버의 부하를 분산하여 성능을 향상시킵니다.
    - **클라우드 서비스:** 클라우드 환경에서 가용성과 확장성을 확보하기 위해 사용됩니다.

### Blocking/Non-blocking과 Synchronous/Asynchronous의 차이점에 대해 설명해 주세요.

Blocking/Non-blocking과 Synchronous/Asynchronous는 프로세스와 스레드의 작업 처리 방식에 관한 개념입니다.

- **Blocking:** 작업이 완료될 때까지 제어권을 반환하지 않고 기다립니다.
    
- **Non-blocking:** 작업이 바로 완료되지 않으면 즉시 제어권을 반환합니다.
    
- **Synchronous:** 작업을 순차적으로 실행하며, 이전 작업이 완료된 후 다음 작업을 시작합니다.
    
- **Asynchronous:** 작업을 동시에 실행할 수 있으며, 이전 작업이 완료될 때까지 기다리지 않고 다음 작업을 시작합니다.
    

**차이점:**

- **Blocking vs Non-blocking:**
    
    - 블로킹 방식은 작업이 완료될 때까지 기다리는 반면, 논블로킹 방식은 작업이 완료되지 않아도 다른 작업을 수행할 수 있습니다.
- **Synchronous vs Asynchronous:**
    
    - 동기 방식은 작업이 순차적으로 실행되는 반면, 비동기 방식은 동시에 여러 작업을 처리할 수 있습니다.

### Blocking I/O와 Non-blocking I/O의 차이점에 대해 설명해 주세요.

Blocking I/O와 Non-blocking I/O는 입출력 작업의 처리 방식에 대한 개념입니다.

- **Blocking I/O:**
    
    - 입출력 작업이 완료될 때까지 제어권을 반환하지 않고 기다립니다.
    - 작업이 완료되기 전까지 프로세스나 스레드는 대기 상태에 머뭅니다.
    - **장점:** 구현이 간단하며, 이해하기 쉽습니다.
    - **단점:** 입출력 작업이 지연되면 전체 시스템 성능이 저하될 수 있습니다.
- **Non-blocking I/O:**
    
    - 입출력 작업이 바로 완료되지 않으면 제어권을 즉시 반환합니다.
    - 프로세스나 스레드는 입출력 작업이 완료되지 않아도 다른 작업을 수행할 수 있습니다.
    - **장점:** 시스템 자원을 효율적으로 사용할 수 있으며, 대기 시간이 줄어듭니다.
    - **단점:** 구현이 복잡하며, 추가적인 제어 로직이 필요합니다.

이를 통해 입출력 작업을 처리할 때 시스템 성능과 자원 활용도를 최적화할 수 있습니다.