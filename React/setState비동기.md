## setState의 비동기
`Props`, `state`는 현재 화면에 대한 영향을 준다는 것을 이해하셨을 것입니다.

여기서 `setState`는 비동기적 호출방식을 사용합니다. 
`setState` 호출 이후에 `this.state`에 의존하여 계산하는 방식은 지양하도록 합니다.
현재 `state`를 기반으로 값을 계산해야 하는 경우 객체 대신 업데이터 함수를 전달합니다


> setState는 비동기적으로 호출된다.
> 그렇기 때문에 setState로 호출한 이후에 즉각적으로 this.state를 통해 접근한다면 개발자의 예상과 벗어난 결과를 초래할 것이다.
> 이를 방지하기 위해 객체 대신 함수를 활용하여 값을 전달한다.

## setState의 비동기 상황 탈출 방법
`setState`가 비동기적이라면 우리는 개발에 있어서 많은 어려움을 겪을 것이다.
하지만 이를 방지하는 방법이 있다.

setState의 호출을 항상 최신으로 하는 방법은 객체가 아닌 함수를 통해 값을 전달하는 방식이다.

방식의 차이를 예를 들어 비교해서 보여주면 아래 코드와 같다.
```js
//객체를 통한 값 전달
incrementCount() {
  this.setState({count: this.state.count + 1});
}

//익명함수를 통한 값 전달
incrementCount() {
  this.setState((state) => {
    return {count: state.count + 1}
  });
}
```

> 이 둘의 차이점은 그렇다면 무엇인가?
> 함수를 통해 호출하면 함수 내에서 내부의 현재 상태값에 접근한 이후 변경이 이루어진다.
> 이렇게 함수를 호출하는 순서가 정해지기 때문에 setState의 값이 변경이 서로 충돌하지 않고 빌드된다.