## setState의 비동기
`Props`, `state`는 현재 화면에 대한 영향을 준다는 것을 이해하셨을 것입니다.

여기서 `setState`는 비동기적 호출방식을 사용합니다. 
`setState` 호출 이후에 `this.state`에 의존하여 계산하는 방식은 지양하도록 합니다.
현재 `state`를 기반으로 값을 계산해야 하는 경우 객체 대신 업데이터 함수를 전달합니다


> setState는 비동기적으로 호출된다.
> 그렇기 때문에 setState로 호출한 이후에 즉각적으로 this.state를 통해 접근한다면 개발자의 예상과 벗어난 결과를 초래할 것이다.
> 이를 방지하기 위해 객체 대신 함수를 활용하여 값을 전달한다.

## setState의 비동기 상황 탈출 방법
`setState`가 비동기적이라면 우리는 개발에 있어서 많은 어려움을 겪을 것이다.
하지만 이를 방지하는 방법이 있다.

setState의 호출을 항상 최신으로 하는 방법은 객체가 아닌 함수를 통해 값을 전달하는 방식이다.

방식의 차이를 예를 들어 비교해서 보여주면 아래 코드와 같다.
```js
//객체를 통한 값 전달
incrementCount() {
  this.setState({count: this.state.count + 1});
}

//익명함수를 통한 값 전달
incrementCount() {
  this.setState((state) => {
    return {count: state.count + 1}
  });
}
```

> 이 둘의 차이점은 그렇다면 무엇인가?  </br>
> 함수를 통해 호출하면 함수 내에서 내부의 현재 상태값에 접근한 이후 변경이 이루어진다. </br>
> 이렇게 함수를 호출하는 순서가 정해지기 때문에 setState의 값이 변경이 서로 충돌하지 않고 빌드된다. </br>

### setState는 언제 비동기일까?
`setState`는 현재 이벤트 핸들러내부에서 비동기적으로 작동합니다.

이렇게 하면 부모와 자식간의 관계에서 동시에 클릭이벤트가 발생시켰을 때  자식은 두 번 재렌더링 하지 않습니다.
대신 React는 브라우저 이벤트가 끝날 때 상태 업데이트를 한꺼번에 합니다.
이러한 동작 방식은 리액트의 성능에 큰 향상을 불러옵니다.

</br>


> 그렇다면 왜 setState는 비동기적으로 할까요? </br>
> 이유는 총 세가지가 있습니다. </br>
> React는 모든 변경사항을 한번에 처리하기 때문에 다시 렌더링을 하기전에 이벤트 핸들에서 호출할 때까지 의도적으로 기다립니다. 이렇게 해야 불필요한 렌더링을 줄일 수 있기 때문입니다. </br>
> 두 번째로는 Props와 state의 지속성이 붕괴되어 디버깅이 어려워진다입니다. </br>
> 세 번째는 리액트팀에서 앞으로 만들 기능들에 대해 구현을 어렵게 한다는 이유입니다.</br>

Reference: [Component State – React](https://reactjs.org/docs/faq-state.html)