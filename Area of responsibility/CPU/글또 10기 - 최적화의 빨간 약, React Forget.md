## 들어가며
리액트를 사용할 때, 성능 최적화는 중요한 과제 중 하나입니다. 작은 규모의 애플리케이션에서는 크게 체감되지 않겠지만, 컴포넌트 구조가 복잡해지고 데이터가 자주 변동하는 상황에서는 불필요한 렌더링이 사용자 경험에 영향을 미칠 수 있습니다. 이런 이유로 성능 최적화가 필요한 시점을 잘 판단하고, 적절한 기법을 사용하는 것이 중요합니다.
### 최적화가 필요한 경우
리액트 애플리케이션에서 최적화가 필요한 대표적인 상황은 다음과 같습니다:

- **상위 컴포넌트의 상태 변화**로 인해 하위 컴포넌트가 불필요하게 다시 렌더링될 때.
- **비용이 많이 드는 계산**(예: 복잡한 연산, API 호출)이나 데이터 처리가 자주 발생할 때.
- 대량의 데이터를 **렌더링하거나 필터링**하는 경우 성능 저하가 발생할 때.

이런 상황에서 자주 사용하는 것이 바로 `useCallback`과 `useMemo`입니다.

21년도 React Conference에서 소개된 테마 색상을 변경할 수 있는 기능이 추가된 간단한 Todo List에서의 경우를 보여드리겠습니다.

![](https://i.imgur.com/gJUQahL.png)

위의 코드에서 themeColor가 드래그를 통해 변경하면 themeColor를 상속 받고 있는 TodoList가 불필요하게 계속해서 재렌더링되는 성능 이슈가 발생합니다.
이에 대해서 `memoization`이나 `debounce`등의 테크닉을 활용하는게 좋아 보인다고 생각하고 우리는 열심히 구현할 것입니다.

### 최적화를 위한 useCallback과 useMemo
React로 개발하면서 위에 제시된 최적화가 필요한 상황을 맞이하였을 때, 생각할 수 있는 것은 여러가지가 있을 수 있습니다. Throttle, debounce 같은 처리방식도 있고, React에서는 `useCallback`, `useMemo`와 같은 메모이제이션 훅을 통해 성능을 향상시킬 수 있습니다.

간단하게 두 개의 훅이 어떤 것인지 정리해보겠습니다.

>1.  useCallback
> `useCallback`은 **함수를 메모이제이션**하여, 의존성 배열이 변경되지 않는 한 동일한 함수 객체를 반환합니다. 주로 자식 컴포넌트에 함수를 props로 넘길 때, 불필요한 리렌더링을 방지하기 위해 사용합니다

```js
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
```

> 2. useMemo
> `useMemo`는 **값을 메모이제이션**하여, 의존성 배열이 변경되지 않는 한 계산을 다시 하지 않고 저장된 값을 반환합니다. 주로 **비용이 많이 드는 계산**을 반복하지 않도록 할 때 사용합니다.

```js
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```


### 사용 시 주의점

## 이런 고민할 필요가 없는걸 개발하고 있다!?

### React forget

### 어떤식으로 동작하는가?
### 실제 효과는?

## 나에 대한 생각