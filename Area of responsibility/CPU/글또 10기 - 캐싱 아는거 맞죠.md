## 들어가며
저번에 최적화에 대한 이야기를 하면서 캐싱이라는 단어를 언급한 적이 있었습니다. 그런데 문득 “과연 나는 캐싱을 제대로 알고 있을까?”라는 생각이 들었고, 지금까지 웹 개발을 하며 캐싱과 관련된 다양한 경험들을 되짚어보기로 했습니다. React Query 같은 라이브러리에서도 캐싱을 자주 접하게 되는데, 이 기회를 통해 **프론트엔드에서 캐싱이 어떤 방식으로 활용되는지** 면밀하게 분석하고, 그 내용을 여러분께도 공유하고자 합니다. 이번 글이 캐싱에 대한 실질적인 이해와 도움을 줄 수 있기를 바라면서 시작합니다.

## 캐싱이란?

*캐싱(Cache)**은 자주 접근하는 데이터를 미리 저장해 두고, 다시 필요할 때 빠르게 가져오는 방식입니다. 네트워크 요청을 매번 새로 하지 않고, 이전 데이터를 재사용함으로써 **성능을 최적화**하고 **응답 속도를 향상**시키는 것이 주요 목적입니다. 캐싱은 데이터 소모를 줄여주고, 특히 사용자 경험을 높이는 데 큰 역할을 합니다. 예를 들어, 매번 같은 이미지를 로드하기보다 캐시에 저장해 두었다가 재사용하면 훨씬 빠르게 화면을 렌더링할 수 있습니다.

캐싱이 필요한 이유는 크게 두 가지로 요약됩니다:

1. **빠른 데이터 접근**: 자주 사용하는 데이터를 미리 준비해 두어 불필요한 요청을 줄임.
2. **비용 절감 및 리소스 최적화**: 데이터 요청 빈도를 줄여 서버와 네트워크 자원을 아끼고, 사용자의 로딩 대기 시간을 줄임.

## FrontEnd에서의 캐싱

프론트엔드 개발자가 캐싱을 이해하고 사용할 때 중요한 점은, **캐싱의 범위와 목적을 고려하여 필요한 캐싱 전략을 선택하는 것**입니다. 데이터가 어떤 특성을 가지고 있고, 어디에 저장되느냐에 따라 캐싱 방식이 달라지기 때문입니다.

프론트엔드에서 캐싱을 분류하는 방법으로는 **상태 기반 캐싱, 웹 캐싱, 외부 서버 캐싱**의 세 가지가 있습니다. 각 방식은 서로 다른 특성을 가지며, 특정 상황에서 효과적으로 활용할 수 있습니다.

1. **상태 기반 캐싱**은 애플리케이션에서 자주 호출되는 데이터를 상태로 관리하면서, 중복 요청을 줄여 컴포넌트 간 효율적인 데이터 흐름을 유지합니다.
2. **웹 캐싱**은 브라우저와 서버의 상호작용을 최적화하는 것으로, 페이지를 미리 렌더링하거나 브라우저 캐시를 활용해 불필요한 네트워크 요청을 줄이는 방식입니다.
3. **외부 서버 캐싱**은 대규모 애플리케이션에서 빠른 데이터 접근을 보장하고, 여러 지역에 분산된 사용자에게 빠르게 서비스를 제공할 수 있게 해 줍니다.

이제, 각각의 캐싱 방식이 어떤 역할을 하고 어떻게 활용되는지 자세히 살펴보겠습니다.

### ## 1. 상태 기반에서의 캐싱

상태 기반 캐싱은 애플리케이션에서 자주 요청하는 API 데이터나 컴포넌트 상태를 효율적으로 관리하기 위한 방식입니다. 예를 들어, `React Query`와 같은 라이브러리를 사용하면 서버 데이터를 상태로 관리하면서도, **캐싱을 통해 불필요한 네트워크 요청을 줄일 수 있습니다**. 캐싱된 데이터는 일정 시간 이후 자동으로 갱신되거나, 사용자 인터랙션이 발생할 때 갱신될 수 있어 매우 유연하게 동작합니다.

**주요 방법**은 다음과 같습니다.

- **React Query / SWR**: 클라이언트에서 서버 데이터를 캐싱하고 필요한 경우만 다시 요청하여 성능을 높입니다.
- **컴포넌트 최적화**: `useMemo`와 `useCallback`을 사용하여 데이터 상태에 따라 필요한 컴포넌트만 렌더링하고, 불필요한 렌더링을 줄입니다.
- **상태 관리 라이브러리**(예: Redux, Recoil): 전역 상태에서 자주 사용하는 데이터를 캐시해 재사용하여 데이터 흐름을 최적화합니다.

### ## 2. 웹에서의 캐싱

웹 캐싱은 **브라우저 캐싱**과 **서버에서의 미리 렌더링된 캐싱**으로 나눌 수 있습니다. 예를 들어, **Next.js의 SSG, ISR, SSR**과 같은 기능은 웹 캐싱 전략의 일부로, 페이지를 미리 렌더링하여 사용자에게 빠르게 콘텐츠를 제공할 수 있습니다.

**주요 방법**:

- **브라우저 캐싱**: 브라우저는 Cache-Control 헤더와 ETag를 통해 캐싱 정책을 설정합니다. 예를 들어, Cache-Control 헤더를 통해 리소스의 만료 시간을 지정하여, 일정 시간 동안 리소스를 캐싱할 수 있습니다.
- **Next.js의 SSG/ISR**: 정적 페이지를 미리 생성해 브라우저에 제공하며, 사용자가 요청할 때 서버의 부하를 줄이고 페이지 로딩 속도를 높입니다.
- **프리페칭과 프리로딩**: Next.js의 `getStaticProps`와 같은 기능으로 자주 사용되는 리소스를 미리 가져와 캐싱하여 사용자 경험을 개선합니다.


### ## 3. 외부 서버를 통한 캐싱

외부 서버 캐싱은 **Redis나 CDN**을 이용해 데이터를 캐싱하여 전체 애플리케이션 성능을 최적화하는 방식입니다. 특히 많은 사용자가 동시에 접근하는 대규모 서비스에서는 이 방식이 유용합니다. CDN을 통해 사용자와 가까운 서버에서 데이터를 가져오면 지연 시간을 줄이고, Redis를 활용하면 데이터베이스 요청을 줄일 수 있어 더욱 빠른 응답을 제공합니다.

**주요 방법**:

- **CDN (Content Delivery Network)**: 클라우드플레어, AWS CloudFront 같은 CDN을 사용하여 정적 리소스를 전 세계 여러 서버에 분산하고, 사용자와 가장 가까운 위치에서 데이터를 제공해 성능을 극대화합니다.
- **Redis, Memcached**: 데이터를 메모리에 저장해 빠르게 액세스할 수 있도록 합니다. API 호출에 필요한 응답을 캐싱해두고, 변경 사항이 있을 때만 데이터베이스를 재호출합니다.
- **캐시 무효화 전략**: 캐시된 데이터가 업데이트될 때 이를 자동으로 갱신하는 정책을 수립해 최신 상태를 유지합니다.


## 캐싱에 대한 생각
캐싱은 결국 비용