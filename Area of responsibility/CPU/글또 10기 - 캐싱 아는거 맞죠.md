## 들어가며
저번에 최적화에 대한 이야기를 하면서 캐싱이라는 단어를 언급한 적이 있었습니다. 그런데 문득 “과연 나는 캐싱을 제대로 알고 있을까?”라는 생각이 들었고, 지금까지 웹 개발을 하며 캐싱과 관련된 다양한 경험들을 되짚어보기로 했습니다. React Query 같은 라이브러리에서도 캐싱을 자주 접하게 되는데, 이 기회를 통해 **프론트엔드에서 캐싱이 어떤 방식으로 활용되는지** 면밀하게 분석하고, 그 내용을 여러분께도 공유하고자 합니다. 이번 글이 캐싱에 대한 실질적인 이해와 도움을 줄 수 있기를 바라면서 시작합니다.

## 캐싱이란?

*캐싱(Cache)**은 자주 접근하는 데이터를 미리 저장해 두고, 다시 필요할 때 빠르게 가져오는 방식입니다. 네트워크 요청을 매번 새로 하지 않고, 이전 데이터를 재사용함으로써 **성능을 최적화**하고 **응답 속도를 향상**시키는 것이 주요 목적입니다. 캐싱은 데이터 소모를 줄여주고, 특히 사용자 경험을 높이는 데 큰 역할을 합니다. 예를 들어, 매번 같은 이미지를 로드하기보다 캐시에 저장해 두었다가 재사용하면 훨씬 빠르게 화면을 렌더링할 수 있습니다.

캐싱이 필요한 이유는 크게 두 가지로 요약됩니다:

1. **빠른 데이터 접근**: 자주 사용하는 데이터를 미리 준비해 두어 불필요한 요청을 줄임.
2. **비용 절감 및 리소스 최적화**: 데이터 요청 빈도를 줄여 서버와 네트워크 자원을 아끼고, 사용자의 로딩 대기 시간을 줄임.

## FrontEnd에서의 캐싱

프론트엔드 개발자가 캐싱을 이해하고 사용할 때 중요한 점은, **캐싱의 범위와 목적을 고려하여 필요한 캐싱 전략을 선택하는 것**입니다. 데이터가 어떤 특성을 가지고 있고, 어디에 저장되느냐에 따라 캐싱 방식이 달라지기 때문입니다.

프론트엔드에서 캐싱을 분류하는 방법으로는 **상태 기반 캐싱, 웹 캐싱, 외부 서버 캐싱**의 세 가지가 있습니다. 각 방식은 서로 다른 특성을 가지며, 특정 상황에서 효과적으로 활용할 수 있습니다.

1. **상태 기반 캐싱**은 애플리케이션에서 자주 호출되는 데이터를 상태로 관리하면서, 중복 요청을 줄여 컴포넌트 간 효율적인 데이터 흐름을 유지합니다.
2. **웹 캐싱**은 브라우저와 서버의 상호작용을 최적화하는 것으로, 페이지를 미리 렌더링하거나 브라우저 캐시를 활용해 불필요한 네트워크 요청을 줄이는 방식입니다.
3. **외부 서버 캐싱**은 대규모 애플리케이션에서 빠른 데이터 접근을 보장하고, 여러 지역에 분산된 사용자에게 빠르게 서비스를 제공할 수 있게 해 줍니다.

이제, 각각의 캐싱 방식이 어떤 역할을 하고 어떻게 활용되는지 자세히 살펴보겠습니다.

### ## 1. 상태 기반에서의 캐싱

상태 기반 캐싱은 애플리케이션에서 자주 요청하는 API 데이터나 컴포넌트 상태를 효율적으로 관리하기 위한 방식입니다. 예를 들어, `React Query`와 같은 라이브러리를 사용하면 서버 데이터를 상태로 관리하면서도, **캐싱을 통해 불필요한 네트워크 요청을 줄일 수 있습니다**. 캐싱된 데이터는 일정 시간 이후 자동으로 갱신되거나, 사용자 인터랙션이 발생할 때 갱신될 수 있어 매우 유연하게 동작합니다.

###  React Query / SWR
클라이언트에서 서버 데이터를 캐싱하고 필요한 경우만 다시 요청하여 성능을 높입니다.
사용자 프로필 데이터를 React Query로 관리하면 컴포넌트가 언마운트된 후에도 데이터가 캐시에 남아, 다른 컴포넌트에서 중복된 API 호출을 방지합니다.

```JS
import { useQuery } from 'react-query';

function UserProfile({ userId }) {
  const { data: user, isLoading } = useQuery(['user', userId], () =>
    fetch(`/api/users/${userId}`).then((res) => res.json())
  );

  if (isLoading) return <p>Loading...</p>;
  return <div>{user.name}</div>;
}
```
React Query Documentation - Caching  
SWR Documentation - Revalidation
### 컴포넌트 최적화
`useMemo`와 `useCallback`을 사용하여 데이터 상태에 따라 필요한 컴포넌트만 렌더링하고, 불필요한 렌더링을 줄입니다.


### 상태 관리 라이브러리
전역 상태에서 자주 사용하는 데이터를 캐시해 재사용하여 데이터 흐름을 최적화합니다.

### ## 2. 웹에서의 캐싱

웹 캐싱은 **브라우저 캐싱**과 **서버에서의 미리 렌더링된 캐싱**으로 나눌 수 있습니다. 예를 들어, **Next.js의 SSG, ISR, SSR**과 같은 기능은 웹 캐싱 전략의 일부로, 페이지를 미리 렌더링하여 사용자에게 빠르게 콘텐츠를 제공할 수 있습니다.

### 브라우저 캐싱
브라우저는 Cache-Control 헤더와 ETag를 통해 캐싱 정책을 설정합니다. 예를 들어, Cache-Control 헤더를 통해 리소스의 만료 시간을 지정하여, 일정 시간 동안 리소스를 캐싱할 수 있습니다.


### Next.js의 SSG/ISR
정적 페이지를 미리 생성해 브라우저에 제공하며, 사용자가 요청할 때 서버의 부하를 줄이고 페이지 로딩 속도를 높입니다.


### 프리페칭과 프리로딩
Next.js의 `getStaticProps`와 같은 기능으로 자주 사용되는 리소스를 미리 가져와 캐싱하여 사용자 경험을 개선합니다.


### ## 3. 외부 서버를 통한 캐싱

외부 서버 캐싱은 **Redis나 CDN**을 이용해 데이터를 캐싱하여 전체 애플리케이션 성능을 최적화하는 방식입니다. 특히 많은 사용자가 동시에 접근하는 대규모 서비스에서는 이 방식이 유용합니다. CDN을 통해 사용자와 가까운 서버에서 데이터를 가져오면 지연 시간을 줄이고, Redis를 활용하면 데이터베이스 요청을 줄일 수 있어 더욱 빠른 응답을 제공합니다.


### CDN (Content Delivery Network)
AWS CloudFront 같은 CDN을 사용하여 정적 리소스를 전 세계 여러 서버에 분산하고, 사용자와 가장 가까운 위치에서 데이터를 제공해 성능을 극대화합니다.

### Redis, Memcached
데이터를 메모리에 저장해 빠르게 액세스할 수 있도록 합니다. API 호출에 필요한 응답을 캐싱해두고, 변경 사항이 있을 때만 데이터베이스를 재호출합니다.


## 캐싱에 대한 생각: 캐싱은 결국 비용

캐싱 전략은 성능 최적화에 큰 효과가 있지만, 이를 위한 **비용**을 이해하고 관리하는 것이 필수적입니다. 캐싱이 불러오는 **저장 공간, 관리 복잡성, 무효화 비용** 등의 문제는 단순히 캐시를 사용한다고 해서 해결되지 않습니다. 따라서 다음과 같은 비용 요소를 신중히 고려해야 합니다.

1. **저장 공간 비용**: 캐싱할 데이터의 양이 많아질수록 캐시에 필요한 저장 공간이 늘어나며, 특히 서버 캐시를 사용할 때는 비용이 증가합니다.
2. **무효화 비용**: 캐시된 데이터가 오래될 경우, 이를 갱신하거나 무효화해야 하며, 이 과정에서 원본 데이터베이스 접근 비용이 발생합니다.
3. **복잡성 증가**: 캐시 시스템이 추가되면 데이터 일관성을 유지하기 위한 로직과 테스트가 필요해 코드 관리가 복잡해집니다.

캐싱의 효과를 극대화하면서도 비용을 줄일 수 있는 최적의 전략을 찾는 것이 중요합니다. 이 글이 프론트엔드 개발자들이 캐싱을 도입할 때 성능과 비용을 균형 있게 고려할 수 있는 도움을 주기를 바랍니다.