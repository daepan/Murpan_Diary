`### 1. **Dynamic Programming (DP)**  #### - Top-down (Memoization) ```C++ int fib(int n, vector<int>& dp) {     if (n <= 1) return n;     if (dp[n] != -1) return dp[n];     return dp[n] = fib(n-1, dp) + fib(n-2, dp); }`

- **사용 예시**: DP를 활용한 문제에서 재귀적으로 풀면서 중복 연산을 피하는 구조입니다.
- **주요 포인트**: 메모이제이션 테이블을 이용해 중복 계산 방지.

#### - Bottom-up

C++

코드 복사

`int fib(int n) {     vector<int> dp(n+1);     dp[0] = 0; dp[1] = 1;     for (int i = 2; i <= n; i++) dp[i] = dp[i-1] + dp[i-2];     return dp[n]; }`

- **사용 예시**: 재귀를 피하고 반복문을 사용해 효율적으로 계산.

---

### 2. **다익스트라 알고리즘**

C++

코드 복사

`void dijkstra(int start, vector<vector<pair<int, int>>>& graph, vector<int>& dist) {     priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;     dist[start] = 0; pq.push({0, start});          while (!pq.empty()) {         int distance = pq.top().first, node = pq.top().second;         pq.pop();         if (dist[node] < distance) continue;                  for (auto& edge : graph[node]) {             int next = edge.first, nextDist = distance + edge.second;             if (nextDist < dist[next]) {                 dist[next] = nextDist;                 pq.push({nextDist, next});             }         }     } }`

- **사용 예시**: 그래프에서 최단 경로를 찾아야 할 때.
- **주요 포인트**: 우선순위 큐를 사용하여 탐색 속도를 최적화.

---

### 3. **세그먼트 트리**

C++

코드 복사

`void build(int node, int start, int end) {     if (start == end) segtree[node] = arr[start];     else {         int mid = (start + end) / 2;         build(2 * node, start, mid);         build(2 * node + 1, mid + 1, end);         segtree[node] = segtree[2 * node] + segtree[2 * node + 1];     } }`

- **사용 예시**: 구간 합, 구간 최대값/최소값을 빠르게 처리할 때.
- **주요 포인트**: 특정 구간의 값을 빠르게 업데이트하거나 쿼리 처리.

---

### 4. **트라이 (Trie)**

C++

코드 복사

`void insert(string word) {     TrieNode* node = root;     for (char ch : word) {         if (!node->children.count(ch)) node->children[ch] = new TrieNode();         node = node->children[ch];     }     node->isEndOfWord = true; }`

- **사용 예시**: 문자열 검색, 자동 완성 기능 구현.
- **주요 포인트**: 접두사를 효율적으로 관리하고 검색할 때 유용.

---

### 5. **미니맥스 알고리즘**

C++

코드 복사

`int minimax(vector<int>& values, int depth, bool isMax) {     if (depth == values.size()) return 0;     int best = isMax ? -INF : INF;     for (int i = 0; i < values.size(); i++) {         best = isMax ? max(best, minimax(values, depth + 1, !isMax))                      : min(best, minimax(values, depth + 1, !isMax));     }     return best; }`

- **사용 예시**: 체스, 틱택토 같은 게임에서 최적의 수를 계산할 때.
- **주요 포인트**: 게임 트리를 탐색하여 최적의 수를 찾는 방식.

---

### 6. **허프만 코딩 (Huffman Coding)**

C++

코드 복사

`void huffmanCoding(string text) {     unordered_map<char, int> freq;     for (char ch : text) freq[ch]++;          priority_queue<Node*, vector<Node*>, Compare> pq;     for (auto& pair : freq) pq.push(new Node(pair.first, pair.second));          while (pq.size() > 1) {         Node* left = pq.top(); pq.pop();         Node* right = pq.top(); pq.pop();         pq.push(new Node('#', left->freq + right->freq, left, right));     } }`

- **사용 예시**: 텍스트 압축 알고리즘 구현에 사용.
- **주요 포인트**: 각 문자 빈도수를 기반으로 압축 트리 생성.

코드 복사

`이제 전체를 한 번에 복사할 수 있습니다. 이 코드를 마크다운 파일에 넣으시면 됩니다.`