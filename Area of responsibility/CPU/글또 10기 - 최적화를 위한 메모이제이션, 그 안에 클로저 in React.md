## 들어가며
리액트를 사용할 때, 성능 최적화는 중요한 과제 중 하나입니다. 작은 규모의 애플리케이션에서는 크게 체감되지 않겠지만, 컴포넌트 구조가 복잡해지고 데이터가 자주 변동하는 상황에서는 불필요한 렌더링이 사용자 경험에 영향을 미칠 수 있습니다. 이런 이유로 성능 최적화가 필요한 시점을 잘 판단하고, 적절한 기법을 사용하는 것이 중요합니다.
### 최적화가 필요한 경우
리액트 애플리케이션에서 최적화가 필요한 대표적인 상황은 다음과 같습니다:

- **상위 컴포넌트의 상태 변화**로 인해 하위 컴포넌트가 불필요하게 다시 렌더링될 때.
- **비용이 많이 드는 계산**(예: 복잡한 연산, API 호출)이나 데이터 처리가 자주 발생할 때.
- 대량의 데이터를 **렌더링하거나 필터링**하는 경우 성능 저하가 발생할 때.

이런 상황에서 자주 사용하는 것이 바로 `useCallback`과 `useMemo`입니다.

21년도 React Conference에서 소개된 테마 색상을 변경할 수 있는 기능이 추가된 간단한 Todo List에서의 경우를 보여드리겠습니다.

![](https://i.imgur.com/gJUQahL.png)

위의 코드에서 themeColor가 드래그를 통해 변경하면 themeColor를 상속 받고 있는 TodoList가 불필요하게 계속해서 재렌더링되는 성능 이슈가 발생합니다.
이에 대해서 `memoization`이나 `debounce`등의 테크닉을 활용하는게 좋아 보인다고 생각하고 우리는 열심히 구현할 것입니다.

구현 예시 : [React Conf: React without memo](https://www.youtube.com/watch?v=lGEMwh32soc)
### 최적화를 위한 useCallback과 useMemo
React로 개발하면서 위에 제시된 최적화가 필요한 상황을 맞이하였을 때, 생각할 수 있는 것은 여러가지가 있을 수 있습니다. Throttle, debounce 같은 처리방식도 있고, React에서는 `useCallback`, `useMemo`와 같은 메모이제이션 훅을 통해 성능을 향상시킬 수 있습니다.

간단하게 두 개의 훅이 어떤 것인지 정리해보겠습니다.

>1.  useCallback
> `useCallback`은 **함수를 메모이제이션**하여, 의존성 배열이 변경되지 않는 한 동일한 함수 객체를 반환합니다. 주로 자식 컴포넌트에 함수를 props로 넘길 때, 불필요한 리렌더링을 방지하기 위해 사용합니다

```js
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
```

> 2. useMemo
> `useMemo`는 **값을 메모이제이션**하여, 의존성 배열이 변경되지 않는 한 계산을 다시 하지 않고 저장된 값을 반환합니다. 주로 **비용이 많이 드는 계산**을 반복하지 않도록 할 때 사용합니다.

```js
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

둘 다 성능 최적화 용도로 사용되지만, **useCallback은 함수 재생성 방지**에, **useMemo는 값 재계산 방지**에 초점이 맞춰져 있습니다.
### 사용 시 주의점

결국 모든 렌더링 하는 함수나 값에 몽땅 메모이제이션 해두면 완전 럭키비키 아닌가라는 생각을 할 수 있습니다. 하지만 이것은 웹에서 이러한 동작이 어떻게 발생하는지 모른다면 그런다는 것이 위의 메모이제이션 훅이나 함수를 사용할때 반드시 아래를 기억해야합니다.

> **성능 최적화는 무료가 아닙니다. 항상 비용이 들지만 실제로는 그렇습니다. 항상 비용을 상쇄할 수 있는 이점이 있는 것은 아닙니다.**

## 그렇다면 실제로 어떻게 동작하길래 메모리 이슈가 발생할 수 있는가?

React에서 `useMemo`와 `useCallback`은 컴포넌트가 렌더링될 때마다 매번 새로 값을 계산하거나 함수를 생성하는 대신, **이전 계산 결과를 메모리에 저장**해 둠으로써 성능을 최적화합니다. 이를 **메모이제이션**이라고 부르며, 이 과정에서 **클로저**가 중요한 역할을 합니다.

### 클로저와 메모이제이션의 관계

React의 메모이제이션 훅들은 **클로저**를 통해 함수나 값을 메모리에 저장하고, 다음 렌더링 시 저장된 값을 사용합니다. 이때, 의존성 배열에 정의된 값이 바뀌지 않으면 **이전에 저장된 값**을 그대로 사용하게 됩니다.
```js
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

위 코드에서 `a`나 `b`가 변하지 않는다면, **`computeExpensiveValue(a, b)`** 함수는 실행되지 않고, 메모리에 저장된 **이전 값**을 반환하게 됩니다. 이러한 방식으로 **불필요한 재계산**을 방지함으로써 성능을 최적화할 수 있습니다.

### 메모리 이슈는 어떻게 발생하는가?

하지만 여기서 중요한 것은, 메모이제이션된 값은 **메모리**에 저장된다는 점입니다. 그리고 이 값은 의존성 배열에 있는 값이 변경되지 않으면 계속해서 메모리에 남아있습니다. 즉, 메모이제이션을 남발하면 **메모리 사용량이 증가**하고, **캐시된 값**이 불필요하게 오래 유지될 수 있습니다.

1. **불필요한 메모이제이션**:
    - 값이 자주 바뀌지 않는 경우나, 무거운 계산이 아닌 값에도 메모이제이션을 남용하면, 메모리만 차지하고 실제 성능 개선에는 도움이 되지 않습니다.
2. **대량의 데이터나 복잡한 연산**:
    - 메모이제이션된 값이 큰 데이터라면, 메모리에 남아있는 값들이 쌓이면서 **메모리 누수**가 발생할 수 있습니다. 특히, 의존성 배열이 길어질수록 메모리 관리가 더욱 어려워질 수 있습니다.

따라서, **성능 최적화는 무료가 아니다**라는 말은 여기에서 비롯됩니다. 메모이제이션은 불필요한 재계산을 줄이는 대신, **메모리라는 비용**을 지불해야 합니다. 항상 비용 대비 효과가 있는지 고려해야 하며, 적절한 상황에서만 사용해야 합니다.