### 데이터베이스에서 키(Key)의 역할과 종류에 대해 설명해 주세요.

키는 데이터베이스에서 각 레코드를 고유하게 식별하는 데 사용됩니다. 주요 키의 종류에는 기본 키(Primary Key), 후보 키(Candidate Key), 대체 키(Alternate Key), 외래 키(Foreign Key)가 있습니다.

- **기본 키(Primary Key):** 테이블 내의 각 레코드를 고유하게 식별하는 필드입니다. NULL 값을 가질 수 없습니다.
- **후보 키(Candidate Key):** 기본 키로 사용할 수 있는 필드입니다. 기본 키는 후보 키 중 하나입니다.
- **대체 키(Alternate Key):** 기본 키로 선택되지 않은 후보 키입니다.
- **외래 키(Foreign Key):** 한 테이블에서 다른 테이블의 기본 키를 참조하는 필드입니다. 테이블 간의 관계를 설정하는 데 사용됩니다.


###  조인의 종류와 각각의 사용 사례에 대해 설명해 주세요.

조인은 두 개 이상의 테이블을 결합하여 데이터를 조회하는 데 사용됩니다. 주요 조인의 종류는 다음과 같습니다:

- **내부 조인(Inner Join):** 두 테이블의 공통된 값을 가진 레코드만 반환합니다
- **왼쪽 외부 조인(Left Outer Join):** 왼쪽 테이블의 모든 레코드와 오른쪽 테이블의 일치하는 레코드를 반환합니다. 오른쪽 테이블에 일치하는 레코드가 없으면 NULL로 채워집니다.
- **오른쪽 외부 조인(Right Outer Join):** 오른쪽 테이블의 모든 레코드와 왼쪽 테이블의 일치하는 레코드를 반환합니다. 왼쪽 테이블에 일치하는 레코드가 없으면 NULL로 채워집니다.
- **전체 외부 조인(Full Outer Join):** 두 테이블의 모든 레코드를 반환하며, 일치하지 않는 레코드는 NULL로 채워집니다. 두 테이블의 모든 데이터를 조회할 때 사용됩니다.
- **교차 조인(Cross Join):** 두 테이블의 모든 조합을 반환합니다. 조인 조건이 없을 때 사용되며, 결과는 Cartesian Product입니다.



###  SQL Injection이 무엇인지 설명하고 이를 방지하기 위한 방법에 대해 설명해 주세요.

SQL Injection은 악의적인 사용자가 SQL 쿼리에 임의의 코드를 삽입하여 데이터베이스를 공격하는 기법입니다. 이를 통해 데이터 유출, 변경, 삭제 등의 피해를 입을 수 있습니다. 방지 방법은 다음과 같습니다:

- **파라미터화된 쿼리 사용:** SQL 쿼리에 사용자 입력을 직접 포함하지 않고, 파라미터로 전달하여 실행합니다.
- **준비된 문(Prepared Statement) 사용:** 미리 컴파일된 SQL 문을 사용하여 인젝션 공격을 막습니다.
- **ORM(Object-Relational Mapping) 사용:** 데이터베이스 쿼리를 객체 지향적으로 처리하는 ORM 라이브러리를 사용하면 SQL 인젝션을 방지할 수 있습니다.
- **입력 검증:** 사용자 입력을 철저히 검증하고, 허용된 문자나 패턴만 허용합니다.
- **최소 권한 원칙 적용:** 데이터베이스 사용자에게 최소한의 권한만 부여하여 피해를 최소화합니다.

### SQL vs NOSQL

### SQL과 NoSQL 데이터베이스의 차이점과 각각의 장단점에 대해 설명해 주세요.

**이상적인 대답:** SQL 데이터베이스는 관계형 데이터베이스로, 정형화된 데이터와 고정된 스키마를 사용합니다. NoSQL 데이터베이스는 비관계형 데이터베이스로, 유연한 스키마와 다양한 데이터 모델을 지원합니다.

- **SQL의 장점:**
    
    - ACID 속성: 트랜잭션의 원자성, 일관성, 고립성, 지속성을 보장합니다.
    - 구조화된 쿼리 언어(SQL): 복잡한 쿼리를 쉽게 작성할 수 있습니다.
    - 데이터 무결성: 엄격한 스키마와 제약 조건을 통해 데이터의 일관성을 유지합니다.
- **SQL의 단점:**
    
    - 수직적 확장(Scale-up) 한계: 데이터베이스 성능을 높이기 위해 하드웨어를 업그레이드해야 합니다.
    - 유연성 부족: 스키마 변경이 어렵고, 비정형 데이터를 처리하기 힘듭니다.
- **NoSQL의 장점:**
    
    - 수평적 확장(Scale-out) 용이: 여러 서버에 데이터를 분산하여 성능을 향상시킬 수 있습니다.
    - 유연한 스키마: 스키마 없이 다양한 형식의 데이터를 저장할 수 있습니다.
    - 높은 성능: 특정 작업에서 매우 높은 읽기 및 쓰기 성능을 제공합니다.
- **NoSQL의 단점:**
    
    - 일관성 문제: CAP 이론에 따라 일관성과 가용성 중 하나를 선택해야 할 수 있습니다.
    - 복잡한 쿼리: 복잡한 쿼리를 작성하기 어려울 수 있습니다.
    - 제한된 트랜잭션 지원: 일부 NoSQL 데이터베이스는 ACID 트랜잭션을 완벽하게 지원하지 않습니다.

###  데이터베이스 이상(Anomaly)이란 무엇인지 설명하고, 이를 방지하기 위한 방법에 대해 설명해 주세요.

데이터베이스 이상은 데이터의 불일치 또는 오류가 발생하는 현상을 의미합니다. 주요 이상에는 삽입 이상(Insertion Anomaly), 갱신 이상(Update Anomaly), 삭제 이상(Deletion Anomaly)이 있습니다.

- **삽입 이상:** 데이터를 삽입할 때 불필요한 정보가 필요하거나, 특정 데이터를 삽입할 수 없는 문제입니다.
- **갱신 이상:** 데이터를 수정할 때 여러 곳을 수정해야 하며, 일부만 수정될 경우 데이터 불일치가 발생하는 문제입니다.
- **삭제 이상:** 데이터를 삭제할 때 필요한 정보까지 함께 삭제되는 문제입니다.

이상을 방지하기 위한 방법은 데이터베이스 정규화를 통해 데이터 구조를 개선하는 것입니다. 정규화는 데이터 중복을 최소화하고, 각 테이블을 논리적으로 분리하여 이상을 방지합니다.



###  데이터베이스에서 인덱스(Index)의 역할과 종류에 대해 설명해 주세요.

 인덱스는 데이터베이스에서 검색 성능을 향상시키기 위해 사용되는 데이터 구조입니다. 인덱스를 사용하면 테이블의 특정 컬럼에 대한 검색 속도를 빠르게 할 수 있습니다. 주요 인덱스의 종류는 다음과 같습니다:

- **클러스터형 인덱스(Clustered Index):** 테이블의 실제 데이터가 인덱스에 따라 정렬되어 저장됩니다. 각 테이블에는 하나의 클러스터형 인덱스만 가질 수 있습니다.
- **비클러스터형 인덱스(Non-Clustered Index):** 인덱스는 별도의 데이터 구조로 저장되며, 테이블의 데이터는 정렬되지 않습니다. 하나의 테이블에 여러 개의 비클러스터형 인덱스를 생성할 수 있습니다.
- **고유 인덱스(Unique Index):** 인덱스가 적용된 컬럼의 값이 고유하도록 보장합니다.
- **전체 텍스트 인덱스(Full-Text Index):** 텍스트 데이터의 빠른 검색을 위해 사용됩니다.

인덱스를 사용하면 검색 성능이 향상되지만, 데이터 삽입, 수정, 삭제 시 성능 저하가 발생할 수 있습니다. 따라서 적절한 컬럼에 인덱스를 생성하는 것이 중요합니다.



###  데이터베이스 정규화(Normalization)에 대해 설명하고, 정규화의 장단점에 대해 이야기해 주세요.

 정규화는 데이터베이스 설계에서 데이터 중복을 줄이고, 데이터 무결성을 유지하기 위해 테이블을 구조화하는 과정입니다. 주요 정규형은 제1정규형(1NF), 제2정규형(2NF), 제3정규형(3NF), 보이스-코드 정규형(BCNF) 등이 있습니다.

- **제1정규형(1NF):** 테이블의 모든 필드가 원자 값을 가져야 합니다.
- **제2정규형(2NF):** 1NF를 만족하고, 기본 키가 아닌 모든 필드가 기본 키에 완전 종속적이어야 합니다.
- **제3정규형(3NF):** 2NF를 만족하고, 기본 키가 아닌 모든 필드가 기본 키에 이행적 종속성이 없어야 합니다.
- **보이스-코드 정규형(BCNF):** 3NF를 만족하고, 모든 결정자가 후보 키여야 합니다.

**장점:**

- 데이터 중복 최소화: 저장 공간을 절약하고, 데이터 일관성을 유지합니다.
- 데이터 무결성 향상: 불필요한 데이터 수정, 삭제, 삽입 이상을 방지합니다.

**단점:**

- 복잡성 증가: 테이블이 많아지고, 조인이 복잡해질 수 있습니다.
- 성능 저하: 과도한 정규화는 쿼리 성능을 저하시킬 수 있습니다.



### 트랜잭션이란 무엇인지 설명하고, 트랜잭션의 ACID 속성에 대해 설명해 주세요.

트랜잭션은 데이터베이스에서 하나의 논리적 작업 단위로 처리되는 일련의 연산입니다. 트랜잭션의 ACID 속성은 다음과 같습니다:

- **원자성(Atomicity):** 트랜잭션 내의 모든 연산이 모두 성공하거나 모두 실패해야 합니다. 부분적인 실행은 허용되지 않습니다.
- **일관성(Consistency):** 트랜잭션이 완료된 후 데이터베이스는 일관성 있는 상태를 유지해야 합니다.
- **고립성(Isolation):** 각 트랜잭션은 독립적으로 실행되어야 하며, 다른 트랜잭션의 영향을 받아서는 안 됩니다.
- **지속성(Durability):** 트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 저장되어야 합니다.

트랜잭션은 데이터베이스의 일관성과 무결성을 유지하는 데 중요한 역할을 합니다.


###  트랜잭션 격리 수준(Isolation Level)에 대해 설명하고, 각각의 특징을 이야기해 주세요.

 트랜잭션 격리 수준은 여러 트랜잭션이 동시에 실행될 때 데이터의 일관성을 유지하기 위한 규칙을 정의합니다. 주요 격리 수준은 다음과 같습니다:

- **Read Uncommitted:** 다른 트랜잭션이 아직 커밋하지 않은 데이터를 읽을 수 있습니다. 가장 낮은 격리 수준이며, 더티 리드(Dirty Read)가 발생할 수 있습니다.
- **Read Committed:** 다른 트랜잭션이 커밋한 데이터만 읽을 수 있습니다. 더티 리드는 발생하지 않지만, 반복 읽기(Non-repeatable Read)가 발생할 수 있습니다.
- **Repeatable Read:** 트랜잭션 동안 읽은 데이터는 변경되지 않습니다. 더티 리드와 반복 읽기는 발생하지 않지만, 팬텀 리드(Phantom Read)가 발생할 수 있습니다.
- **Serializable:** 가장 높은 격리 수준으로, 트랜잭션이 직렬화되어 실행됩니다. 모든 종류의 읽기 문제를 방지하지만, 성능이 저하될 수 있습니다.


###  Redis에 대해 설명하고, 주요 특징과 사용 사례에 대해 이야기해 주세요.

Redis는 오픈 소스 인메모리 데이터 구조 저장소로, 키-값 저장소로 사용됩니다. 주요 특징은 다음과 같습니다:

- **빠른 성능:** 인메모리 데이터 저장을 통해 매우 높은 읽기 및 쓰기 성능을 제공합니다.
- **다양한 데이터 구조 지원:** 문자열, 해시, 리스트, 셋, 정렬된 셋, 비트맵 등 다양한 데이터 구조를 지원합니다.
- **복제 및 지속성:** 데이터 복제를 통해 가용성을 높이고, 디스크에 데이터를 저장하여 지속성을 보장합니다.
- **스케일링:** 수평적 확장을 통해 성능을 높일 수 있습니다.

**사용 사례:**

- **캐싱:** 자주 조회되는 데이터를 캐싱하여 응답 시간을 단축할 수 있습니다.
- **세션 관리:** 사용자 세션 데이터를 저장하여 빠르게 접근할 수 있습니다.
- **실시간 분석:** 실시간 통계와 분석 데이터를 저장하고 처리할 수 있습니다.
- **메시지 큐:** Pub/Sub 모델을 사용하여 메시지 큐로 활용할 수 있습니다.



###  저장 프로시저(Stored Procedure)에 대해 설명하고, 사용 장단점에 대해 이야기해 주세요.

저장 프로시저는 데이터베이스에 저장된 SQL 코드 블록으로, 특정 작업을 수행하기 위해 미리 작성된 SQL 쿼리의 집합입니다. 저장 프로시저는 호출 시 실행되며, 입력 매개변수를 받아 복잡한 로직을 수행할 수 있습니다.

**장점:**

- **성능 향상:** 미리 컴파일된 상태로 저장되어 있어, 반복적인 쿼리 실행 시 성능이 향상됩니다.
- **코드 재사용:** 자주 사용되는 쿼리 로직을 중앙에서 관리하고 재사용할 수 있습니다.
- **보안 강화:** 데이터베이스 접근 권한을 제한하고, 비즈니스 로직을 데이터베이스 계층에 캡슐화하여 보안을 강화할 수 있습니다.
- **일관성 유지:** 동일한 로직을 여러 곳에서 사용할 때 일관성을 유지할 수 있습니다.

**단점:**

- **유지 보수 어려움:** 복잡한 로직이 데이터베이스에 집중될 경우, 유지 보수가 어려울 수 있습니다.
- **이식성 문제:** 특정 DBMS에 종속적인 SQL 코드를 사용할 경우, 다른 DBMS로의 이식이 어려울 수 있습니다.
- **디버깅 어려움:** 데이터베이스 내에서 실행되는 로직의 디버깅이 어렵습니다.

이러한 질문과 이상적인 답변을 통해 면접에서 지원자의 데이터베이스에 대한 깊은 이해와 실무적인 지식을 평가할 수 있습니다.