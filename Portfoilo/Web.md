### 브라우저 동작 방법

브라우저는 사용자가 URL을 입력하면 DNS를 통해 IP 주소를 조회하고, HTTP 요청을 서버에 보냅니다. 서버는 HTML, CSS, JavaScript 파일을 응답합니다. 브라우저는 이를 파싱하여 DOM 트리와 CSSOM 트리를 생성하고, 렌더 트리를 구성하여 화면에 페이지를 렌더링합니다. JavaScript를 실행하여 동적 컨텐츠를 처리합니다.

### 쿠키 & 세션

- **쿠키**: 클라이언트 측에 저장되는 작은 데이터 조각으로, 서버가 클라이언트의 상태를 기억하기 위해 사용합니다. 만료 시간, 도메인, 경로 등의 속성을 가질 수 있습니다.
- **세션**: 서버 측에서 사용자별로 상태를 저장하는 방법으로, 서버에 저장된 세션 데이터와 클라이언트가 제공한 세션 ID를 통해 사용자를 식별합니다.
![[Pasted image 20240608194615.png]]
### HTTP Request Method

- **GET**: 서버로부터 데이터를 요청합니다.
- **POST**: 서버에 데이터를 제출합니다.
- **PUT**: 서버의 데이터를 업데이트합니다.
- **DELETE**: 서버의 데이터를 삭제합니다.
- **PATCH**: 서버의 데이터를 부분적으로 업데이트합니다.
- **HEAD**: GET 요청과 동일하지만, 응답 본문을 포함하지 않습니다.
- **OPTIONS**: 서버가 지원하는 메서드를 확인합니다.

### HTTP Status Code
- 10x : 정보 확인
- 20x : 통신 성공
- 30x : 리다이렉트
- 40x : 클라이언트 오류
- 50x : 서버 오류

- **200 OK**: 요청이 성공적으로 처리되었습니다.
- **201 Created**: 요청이 성공적으로 처리되었으며, 리소스가 생성되었습니다.
- **400 Bad Request**: 잘못된 요청입니다.
- **401 Unauthorized**: 인증이 필요합니다.
- **403 Forbidden**: 접근이 금지되었습니다.
- **404 Not Found**: 요청한 리소스를 찾을 수 없습니다.
- **500 Internal Server Error**: 서버 내부 오류입니다.

### REST API

REST(Representational State Transfer)는 HTTP를 기반으로 하는 웹 서비스 아키텍처 스타일입니다. 자원을 URI로 식별하고, HTTP 메서드를 통해 자원에 대한 작업을 수행합니다. Stateless, 클라이언트-서버 구조, 캐시 가능성을 특징으로 합니다.

### Web Server & WAS

- **Web Server**: 클라이언트로부터 HTTP 요청을 받아 정적인 콘텐츠(HTML, CSS, 이미지 등)를 제공하는 서버입니다. 예: Apache, Nginx
- **WAS (Web Application Server)**: 동적인 콘텐츠를 생성하고 제공하는 서버로, 웹 서버와 달리 애플리케이션 로직을 수행합니다. 예: Tomcat, JBoss

### OAuth

OAuth는 서드파티 애플리케이션이 사용자 자원에 접근할 수 있도록 허용하는 인증 프레임워크입니다. 사용자는 자격 증명을 제공하지 않고도 자원을 공유할 수 있으며, 주로 OAuth 2.0이 사용됩니다.

### JWT (JSON Web Token)

JWT는 JSON 객체를 안전하게 전송하기 위한 토큰 형식입니다. 헤더, 페이로드, 서명으로 구성되며, 사용자는 JWT를 사용하여 인증된 상태를 유지합니다.

### 인증 방식

- **기본 인증**: 사용자 이름과 비밀번호를 사용하여 인증합니다.
- **토큰 기반 인증**: 서버에서 발급한 토큰을 사용하여 인증합니다. (예: JWT)
- **OAuth**: 서드파티 인증을 통해 자원에 접근합니다.
- **SSO (Single Sign-On)**: 하나의 인증으로 여러 시스템에 접근할 수 있게 합니다.

### 로깅 레벨

- **DEBUG**: 디버깅 정보를 출력합니다.
- **INFO**: 일반적인 정보를 출력합니다.
- **WARN**: 경고를 출력합니다.
- **ERROR**: 오류를 출력합니다.
- **FATAL**: 치명적인 오류를 출력합니다.

### UI/UX

- **UI (User Interface)**: 사용자와 시스템 간의 상호작용이 이루어지는 화면 디자인을 의미합니다.
- **UX (User Experience)**: 사용자가 시스템과 상호작용할 때 느끼는 전반적인 경험을 의미합니다.

### CSR & SSR

- **CSR (Client-Side Rendering)**: 클라이언트에서 JavaScript를 사용하여 페이지를 렌더링합니다. 초기 로딩 속도가 느리지만, 이후 페이지 전환이 빠릅니다.
- **SSR (Server-Side Rendering)**: 서버에서 HTML을 렌더링하여 클라이언트에 전송합니다. 초기 로딩 속도가 빠르지만, 서버 부하가 증가할 수 있습니다.

### 네이티브 앱 & 웹앱 & 하이브리드 앱

- **네이티브 앱**: 특정 플랫폼에 최적화된 앱으로, 성능이 뛰어나고 플랫폼 기능을 모두 사용할 수 있습니다.
- **웹앱**: 웹 기술(HTML, CSS, JavaScript)을 사용하여 만든 앱으로, 브라우저에서 실행됩니다.
- **하이브리드 앱**: 웹 기술을 사용하여 개발하고, 네이티브 쉘을 통해 배포되는 앱으로, 네이티브 기능을 일부 사용할 수 있습니다. 예: Ionic, React Native
![[Pasted image 20240608195440.png]]
### VueJS와 React

- **VueJS**: 경량화된 MVVM 프레임워크로, 반응형 데이터 바인딩과 컴포넌트 기반 아키텍처를 제공합니다.
- **React**: Facebook에서 개발한 UI 라이브러리로, 가상 DOM을 사용하여 효율적인 렌더링을 지원합니다. 컴포넌트 기반 아키텍처를 제공합니다.

### PWA (Progressive Web App)

PWA는 웹 애플리케이션을 네이티브 애플리케이션처럼 사용할 수 있게 하는 기술입니다. 오프라인 동작, 푸시 알림, 홈 화면 추가 등의 기능을 제공합니다.

### CSRF & XSS

### CSRF (Cross-Site Request Forgery)

사용자가 의도하지 않은 요청을 보내도록 하는 공격입니다. 이를 방지하기 위해서는 CSRF 토큰을 사용합니다.

웹 어플리케이션 취약점 중 하나로, 인터넷 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위 (modify, delete, register 등)를 특정한 웹사이트에 request하도록 만드는 공격을 말한다.

주로 해커들이 많이 이용하는 것으로, 유저의 권한을 도용해 중요한 기능을 실행하도록 한다.

우리가 실생활에서 CSRF 공격을 볼 수 있는 건, 해커가 사용자의 SNS 계정으로 광고성 글을 올리는 것이다.

정확히 말하면, CSRF는 해커가 사용자 컴퓨터를 감염시거나 서버를 해킹해서 공격하는 것이 아니다. CSRF 공격은 아래와 같은 조건이 만족할 때 실행된다.

- 사용자가 해커가 만든 피싱 사이트에 접속한 경우
- 위조 요청을 전송하는 서비스에 사용자가 로그인을 한 상황

보통 자동 로그인을 해둔 경우에 이런 피싱 사이트에 접속하게 되면서 피해를 입는 경우가 많다. 또한, 해커가 XSS 공격을 성공시킨 사이트라면, 피싱 사이트가 아니더라도 CSRF 공격이 이루어질 수 있다.

#### 대응법
- ##### 리퍼러(Refferer) 검증
    백엔드 단에서 Refferer 검증을 통해 승인된 도메인으로 요청시에만 처리하도록 한다.
 * #### Token 사용
    사용자의 세션에 임의의 난수 값을 저장하고, 사용자의 요청시 해당 값을 포함하여 전송시킨다. 백엔드 단에서는 요청을 받을 때 세션에 저장된 토큰값과 요청 파라미터로 전달받는 토큰 값이 일치하는 지 검증 과정을 거치는 방법이다.

####  **XSS (Cross-Site Scripting)**

공격자가 악성 스크립트를 삽입하여 다른 사용자의 세션을 가로채거나, 데이터 탈취 등의 공격을 수행하는 것입니다. 이를 방지하기 위해 입력 값 검증과 출력 값 이스케이핑을 수행해야 합니다.

CSRF와 같이 웹 어플리케이션 취약점 중 하나로, 관리자가 아닌 권한이 없는 사용자가 웹 사이트에 스크립트를 삽입하는 공격 기법을 말한다.

악의적으로 스크립트를 삽입하여 이를 열람한 사용자의 쿠키가 해커에게 전송시키며, 이 탈취한 쿠키를 통해 세션 하이재킹 공격을 한다. 해커는 세션ID를 가진 쿠키로 사용자의 계정에 로그인이 가능해지는 것이다.

공격 종류로는 지속성, 반사형, DOM 기반 XSS 등이 있다.

- **지속성** : 말 그대로 지속적으로 피해를 입히는 유형으로, XSS 취약점이 존재하는 웹 어플리케이션에 악성 스크립트를 삽입하여 열람한 사용자의 쿠키를 탈취하거나 리다이렉션 시키는 공격을 한다. 이때 삽입된 스크립트를 데이터베이스에 저장시켜 지속적으로 공격을 하기 때문에 Persistent XSS라고 불린다.
- **반사형** : 사용자에게 입력 받은 값을 서버에서 되돌려 주는 곳에서 발생한다. 공격자는 악의 스크립트와 함께 URL을 사용자에게 누르도록 유도하고, 누른 사용자는 이 스크립트가 실행되어 공격을 당하게 되는 유형이다.
- **DOM 기반** : 악성 스크립트가 포함된 URL을 사용자가 요청하게 되면서 브라우저를 해석하는 단계에서 발생하는 공격이다. 이 스크립트로 인해 클라이언트 측 코드가 원래 의도와 다르게 실행된다. 이는 다른 XSS 공격과는 달리 서버 측에서 탐지가 어렵다.

#### 대응
- ##### 입출력 값 검증
	- XSS Cheat Sheet에 대한 필터 목록을 만들어 모든 Cheat Sheet에 대한 대응을 가능하도록 사전에 대비한다. XSS 필터링을 적용 후 스크립트가 실행되는지 직접 테스트 과정을 거쳐볼 수도 있다,
    
- ##### XSS 방어 라이브러리, 확장앱
	- Anti XSS 라이브러리를 제공해주는 회사들이 많다. 이 라이브러리는 서버단에서 추가하며, 사용자들은 각자 브라우저에서 악성 스크립트가 실행되지 않도록 확장앱을 설치하여 방어할 수 있다.
    
* ##### 웹 방화벽
	* 웹 방화벽은 웹 공격에 특화된 것으로, 다양한 Injection을 한꺼번에 방어할 수 있는 장점이 있다.
    
- #### CORS, SOP 설정
	- CORS(Cross-Origin Resource Sharing), SOP(Same-Origin-Policy)를 통해 리소스의 Source를 제한 하는것이 효과적인 방어 방법이 될 수 있다. 웹 서비스상 취약한 벡터에 공격 스크립트를 삽입 할 경우, 치명적인 공격을 하기 위해 스크립트를 작성하면 입력값 제한이나 기타 요인 때문에 공격 성공이 어렵다. 그러나 공격자의 서버에 위치한 스크립트를 불러 올 수 있다면 이는 상대적으로 쉬워진다. 그렇기 떄문에 CORS, SOP를 활용 하여 사전에 지정된 도메인이나 범위가 아니라면 리소스를 가져올 수 없게 제한해야 한다.